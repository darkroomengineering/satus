---
alwaysApply: true
---
---
description: Project overview and cross-cutting concerns
globs: *.tsx, *.jsx, *.css, *.js, *.ts
---

# Satus Project Guidelines

## Technology Stack

- **Next.js 15.6.0** - App Router with Turbopack support
- **React 19.2.0** - Latest features including `<Activity />`, `useEffectEvent`, and `cacheSignal`
- **React Compiler enabled** - Automatically optimizes most component re-renders and memoization; manual memoization is rarely needed
- **TypeScript** - Strict mode enabled
- **Tailwind CSS 4.1.14** - CSS-first configuration
- **Biome 2.2.5** - Linting and formatting
- **Bun** - JavaScript runtime and package manager

## React 19.2 New Features

### 1. `<Activity />` Component
Manage off-screen component visibility and defer updates for better performance.

```tsx
import { Activity } from 'react'

// Hide tab content when not visible
<Activity mode={isActive ? 'visible' : 'hidden'}>
  <ExpensiveComponent />
</Activity>
```

**Use Cases:**
- Tab systems or carousels
- Off-screen WebGL scenes  
- Accordion components
- Drawer/modal systems

**Benefits:**
- Pre-render content without performance impact
- Automatic effect cleanup when hidden
- Better resource management for complex UIs

### 2. `useEffectEvent` Hook
Separate event logic from effect dependencies to prevent unnecessary re-runs.

```tsx
import { useEffect, useEffectEvent } from 'react'

function Component({ url, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme) // theme changes won't trigger reconnect
  })

  useEffect(() => {
    const connection = createConnection(url)
    connection.on('connected', onConnected)
    connection.connect()
    return () => connection.disconnect()
  }, [url]) // Only reconnect when url changes
}
```

**Use Cases:**
- Complex event handlers with multiple dependencies
- Scroll/transform callbacks
- WebGL mouse/interaction handlers
- Animation callbacks

**Benefits:**
- Reduces unnecessary effect re-runs
- Cleaner dependency arrays
- Better separation of concerns

### 3. `cacheSignal` (Server Components Only)
Provides an `AbortSignal` that triggers when the component's cache scope expires.

```tsx
import { cacheSignal } from 'react'

async function fetchUserData(id: string) {
  const signal = cacheSignal() // Auto-aborts on cache expiry
  const response = await fetch(`/api/users/${id}`, { signal })
  return response.json()
}
```

**Use Cases:**
- Sanity CMS queries
- Shopify API calls
- Any server component data fetching
- Replace custom timeout logic with automatic cleanup

**Benefits:**
- Automatic cleanup of stale requests
- Better resource management
- Simpler than manual AbortController

### 4. Performance Tracks in Chrome DevTools
React 19.2 integrates custom performance tracks into Chrome DevTools:
- **Scheduler Track:** Displays React's workload prioritization
- **Components Track:** Shows component hierarchy and timing

**Usage:** Open Chrome DevTools → Performance tab → Record a profile → Look for React-specific tracks

## File Organization

```
├── app/                  # Next.js pages and routes
├── components/           # Reusable UI components
├── hooks/                # Custom React hooks
├── integrations/         # Third-party integrations
├── libs/                 # Utility libraries
│   ├── cleanup-integrations.ts  # Remove unused integrations
│   ├── fetch-with-timeout.ts    # API resilience
│   ├── metadata.ts              # SEO/metadata helpers
│   ├── validate-env.ts          # Environment validation
│   └── ...
├── orchestra/            # Debug tools (dev-only)
├── styles/               # Styling configuration
└── webgl/                # WebGL and 3D graphics
```

## Cross-Cutting Concerns

### React Compiler & Memoization

**React Compiler is enabled and handles ALL optimization automatically.**

- **DO NOT use `useMemo`, `useCallback`, or `React.memo` in new code.**
- The compiler optimizes all component re-renders, memoization, and dependencies automatically.
- Only use manual memoization if you encounter a proven edge case where the compiler cannot optimize (extremely rare).
- If you see these in existing code, they can likely be removed safely.
- **CRITICAL EXCEPTION: Use `useRef` for object instantiation** - Creating new object instances on every render creates new references that trigger effects, causing infinite loops.
- Refer to the [React Compiler documentation](https://react.dev/reference/react/compiler) for edge cases.

```tsx
// ❌ DON'T: Manual memoization for simple calculations (compiler handles this)
const memoizedValue = useMemo(() => computeExpensive(a, b), [a, b])
const memoizedCallback = useCallback(() => doSomething(a), [a])

// ✅ DO: Let React Compiler optimize automatically
const value = computeExpensive(a, b)
const handleClick = () => doSomething(a)

// ⚠️ EXCEPTION: Object instantiation MUST use useRef
// ❌ DON'T: This causes infinite re-renders when passed to effects/deps
const instance = new SomeClass()

// ✅ DO: Use useRef for object instantiation
const instanceRef = useRef<SomeClass | null>(null)
if (!instanceRef.current) {
  instanceRef.current = new SomeClass(params)
}
const instance = instanceRef.current
```

### Image Optimization

**Always use the custom Image component for all images.**

- **DO NOT use `next/image` directly**
- Use `~/components/image` for standard images
- **In WebGL contexts, use `~/webgl/components/image`** which wraps the custom Image component for DOM fallback and WebGL texture integration

```tsx
import { Image } from '~/components/image'
// For WebGL:
import { Image as WebGLImage } from '~/webgl/components/image'
```

### Development vs Production

**Console logs are automatically stripped in production** by Next.js compiler (except `console.error` and `console.warn`)

- **Always gate debug UI components** - these are NOT automatically removed
- **Gate expensive debug computations** - avoid running heavy operations in production

```tsx
// ✅ Simple logs: Optional to gate (Next.js strips them automatically)
console.log('Debug info:', data)

// ✅ Better: Gate expensive operations to avoid computation overhead
if (process.env.NODE_ENV === 'development') {
  console.log('Heavy computation:', expensiveDebugCalculation())
}

// ⚠️ REQUIRED: Always gate debug UI components (not auto-removed)
{process.env.NODE_ENV === 'development' && <DebugPanel />}
{process.env.NODE_ENV === 'development' && <Stats />}
```

**Bundle Size Optimization:**
- Keep production bundles minimal by excluding dev-only code
- Use tree-shaking friendly imports
- Check bundle size impact of new dependencies
- Debug UI components must be gated (Next.js won't remove them automatically)

## Core Utility Libraries

### Available Utilities
- **`~/libs/validate-env`** - Validate required environment variables at runtime
- **`~/libs/cleanup-integrations`** - Remove unused integration code to optimize bundle size
- **`~/libs/fetch-with-timeout`** - Resilient API calls with configurable timeouts (5-10s standard)
- **`~/libs/metadata`** - Centralized SEO and metadata generation for consistent OpenGraph, Twitter cards, etc.

### Usage Examples

```typescript
// Validate environment variables
import { validateEnv } from '~/libs/validate-env'
validateEnv(['NEXT_PUBLIC_API_KEY', 'DATABASE_URL'])

// Fetch with timeout
import { fetchWithTimeout } from '~/libs/fetch-with-timeout'
const response = await fetchWithTimeout(url, options, 10000)

// Generate metadata
import { generateSanityMetadata } from '~/libs/metadata'
export async function generateMetadata({ params }) {
  const page = await fetchPage(params.slug)
  return generateSanityMetadata(page)
}
```

## Getting Started

1. Review relevant best practices before starting work in a specific area
2. Follow the project structure guidelines
3. Use the provided development tools and debugging features
4. Consult the documentation for specific implementation details
5. Use utility libraries for common patterns (API calls, env validation, metadata)

## Updates

These best practices are regularly updated to reflect:
- New dependencies and versions
- Improved patterns and practices
- Community feedback and learnings
- Project-specific requirements

Last updated: 2025-10-07
