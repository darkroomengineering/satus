---
description: Main index of best practices for Satūs
globs: **/*
alwaysApply: false
---
---
description: Global rules
globs: *.tsx, *.jsx, *.css, *.js, *.ts
---

1. **Type Safety**
   - Use TypeScript for all new code
   - Maintain strict type checking
   - Avoid `any` types unless absolutely necessary
   - Use proper type imports (`import type` when importing only types)

2. **Performance**
   - Use React Server Components by default
   - Enable Turbopack for development (`bun dev` uses `--turbopack`)
   - Implement proper code splitting with `next/dynamic`
   - Follow recommended caching strategies
   - Optimize assets and bundles
   - **Always use the custom `Image` component (`~/components/image`) for all images. Do not use `next/image` directly.**
   - **In WebGL contexts, use `webgl/components/image`, which wraps the custom `Image` component for DOM fallback and WebGL texture integration.**

3. **Code Quality**
   - Follow Biome linting rules
   - Maintain consistent code style
   - Write meaningful comments and documentation
   - Use meaningful variable and function names
   - Prefer named exports for components

4. **Testing & Debugging**
   - Write unit tests for critical functionality
   - Use Orchestra tools for debugging (CMD+O)
   - Implement proper error boundaries
   - Follow error handling best practices
   - Use Theatre.js Studio for animation debugging

5. **Security**
   - Follow security best practices
   - Properly handle environment variables
   - Implement proper authentication
   - Follow CSP guidelines
   - Use server-side validation for forms

6. **Architecture**
   - Follow the defined project structure
   - Maintain separation of concerns
   - Use proper state management (Zustand when needed)
   - Follow component composition patterns
   - Keep client/server boundaries clear

## Technology Stack

- **Next.js 15.3.2** - App Router with Turbopack support
- **React 19.1.0** - Latest features including simplified ref handling
- **React Compiler enabled** - Automatically optimizes most component re-renders and memoization; manual memoization is rarely needed
- **TypeScript** - Strict mode enabled
- **Tailwind CSS 4.1.7** - CSS-first configuration
- **Biome 1.9.4** - Linting and formatting
- **Bun** - JavaScript runtime and package manager

## File Organization

```
├── app/                  # Next.js pages and routes
├── components/           # Reusable UI components
├── hooks/                # Custom React hooks
├── integrations/         # Third-party integrations
├── libs/                 # Utility libraries
│   ├── cleanup-integrations.ts  # Remove unused integrations
│   ├── fetch-with-timeout.ts    # API resilience
│   ├── metadata.ts              # SEO/metadata helpers
│   ├── validate-env.ts          # Environment validation
│   └── ...
├── orchestra/            # Debug tools (dev-only)
├── styles/               # Styling configuration
└── webgl/                # WebGL and 3D graphics
```

## Development Guidelines

1. **Component Development**
   - Use CSS modules for component styling
   - Import styles as `s` (e.g., `import s from './component.module.css'`)
   - Use `cn` from `clsx` for conditional classes
   - Implement responsive design with custom viewport functions
   - **DO NOT use manual memoization** - React Compiler handles optimization

2. **State Management**
   - Prefer React's built-in state for component state
   - Use Zustand for global state when needed
   - Keep state as close to where it's used as possible

3. **Routing & Navigation**
   - Use Next.js App Router conventions
   - Implement proper loading and error states
   - Use `next/link` for internal navigation
   - Use `~/libs/metadata` for SEO optimization

4. **Styling**
   - Follow Tailwind CSS v4 conventions
   - Use CSS variables for theming
   - Implement responsive design with breakpoints
   - Use custom viewport units (mobile-vw, desktop-vw)

5. **API Integration**
   - **Always use `fetchWithTimeout` for external API calls**
   - Standard timeouts: 8-10 seconds for most integrations
   - Handle errors gracefully with try-catch
   - Import from `~/libs/fetch-with-timeout`

6. **Environment & Configuration**
   - Use `~/libs/validate-env` to validate required environment variables
   - Use `~/libs/cleanup-integrations` to remove unused integration code
   - Gate debug features to development with `process.env.NODE_ENV === 'development'`

## Core Utility Libraries

### New Utilities (2025)
- **`~/libs/validate-env`** - Validate required environment variables at runtime
- **`~/libs/cleanup-integrations`** - Remove unused integration code to optimize bundle size
- **`~/libs/fetch-with-timeout`** - Resilient API calls with configurable timeouts (5-10s standard)
- **`~/libs/metadata`** - Centralized SEO and metadata generation for consistent OpenGraph, Twitter cards, etc.

### Usage Examples
```typescript
// Validate environment variables
import { validateEnv } from '~/libs/validate-env'
validateEnv(['NEXT_PUBLIC_API_KEY', 'DATABASE_URL'])

// Fetch with timeout
import { fetchWithTimeout } from '~/libs/fetch-with-timeout'
const response = await fetchWithTimeout(url, options, 10000)

// Generate metadata
import { generateSanityMetadata } from '~/libs/metadata'
export async function generateMetadata({ params }) {
  const page = await fetchPage(params.slug)
  return generateSanityMetadata(page)
}
```

## Getting Started

1. Review relevant best practices before starting work in a specific area
2. Follow the project structure guidelines
3. Use the provided development tools and debugging features
4. Consult the documentation for specific implementation details
5. Use utility libraries for common patterns (API calls, env validation, metadata)

## Updates

These best practices are regularly updated to reflect:
- New dependencies and versions
- Improved patterns and practices
- Community feedback and learnings
- Project-specific requirements

Last updated: 2025-06-01 