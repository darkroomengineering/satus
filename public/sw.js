/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/chunks/quotaErrorCallbacks.js":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/chunks/quotaErrorCallbacks.js ***!
  \******************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: function() { return /* binding */ SerwistError; },\n/* harmony export */   a: function() { return /* binding */ canConstructResponseFromBodyStream; },\n/* harmony export */   c: function() { return /* binding */ cacheNames; },\n/* harmony export */   f: function() { return /* binding */ finalAssertExports; },\n/* harmony export */   l: function() { return /* binding */ logger; },\n/* harmony export */   q: function() { return /* binding */ quotaErrorCallbacks; }\n/* harmony export */ });\nconst _cacheNameDetails = {\n    googleAnalytics: \"googleAnalytics\",\n    precache: \"precache-v2\",\n    prefix: \"serwist\",\n    runtime: \"runtime\",\n    suffix: typeof registration !== \"undefined\" ? registration.scope : \"\"\n};\nconst _createCacheName = (cacheName)=>{\n    return [\n        _cacheNameDetails.prefix,\n        cacheName,\n        _cacheNameDetails.suffix\n    ].filter((value)=>value && value.length > 0).join(\"-\");\n};\nconst eachCacheNameDetail = (fn)=>{\n    for (const key of Object.keys(_cacheNameDetails)){\n        fn(key);\n    }\n};\nconst cacheNames = {\n    updateDetails: (details)=>{\n        eachCacheNameDetail((key)=>{\n            const detail = details[key];\n            if (typeof detail === \"string\") {\n                _cacheNameDetails[key] = detail;\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: ()=>{\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: ()=>{\n        return _cacheNameDetails.suffix;\n    }\n};\n\nconst messages = {\n    \"invalid-value\": ({ paramName, validValueDescription, value })=>{\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n    },\n    \"not-an-array\": ({ moduleName, className, funcName, paramName })=>{\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n    },\n    \"incorrect-type\": ({ expectedType, paramName, moduleName, className, funcName })=>{\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n    },\n    \"incorrect-class\": ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem })=>{\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        if (isReturnValueProblem) {\n            return `The return value from '${moduleName}.${classNameStr}${funcName}()' must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    },\n    \"missing-a-method\": ({ expectedMethod, paramName, moduleName, className, funcName })=>{\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n    },\n    \"add-to-cache-list-unexpected-type\": ({ entry })=>{\n        return `An unexpected entry was passed to '@serwist/precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(entry)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`;\n    },\n    \"add-to-cache-list-conflicting-entries\": ({ firstEntry, secondEntry })=>{\n        if (!firstEntry || !secondEntry) {\n            throw new Error(\"Unexpected input to \" + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to '@serwist/precaching.PrecacheController.addToCacheList()' had the URL ${firstEntry} but different revision details. Serwist is unable to cache and version the asset correctly. Please remove one of the entries.`;\n    },\n    \"plugin-error-request-will-fetch\": ({ thrownErrorMessage })=>{\n        if (!thrownErrorMessage) {\n            throw new Error(\"Unexpected input to \" + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugin's 'requestWillFetch()' method. The thrown error message was: '${thrownErrorMessage}'.`;\n    },\n    \"invalid-cache-name\": ({ cacheNameId, value })=>{\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for setCacheDetails({${cacheNameId}: '...'}). Received a value of '${JSON.stringify(value)}'`;\n    },\n    \"unregister-route-but-not-found-with-method\": ({ method })=>{\n        if (!method) {\n            throw new Error(\"Unexpected input to \" + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously registered for the method type '${method}'.`;\n    },\n    \"unregister-route-route-not-registered\": ()=>{\n        return `The route you're trying to unregister was not previously ` + \"registered.\";\n    },\n    \"queue-replay-failed\": ({ name })=>{\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    \"duplicate-queue-name\": ({ name })=>{\n        return `The Queue name '${name}' is already being used. All instances of backgroundSync.Queue must be given unique names.`;\n    },\n    \"expired-test-without-max-age\": ({ methodName, paramName })=>{\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n    },\n    \"unsupported-route-type\": ({ moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter was an unsupported type. Please check the docs for ${moduleName}.${className}.${funcName} for valid input types.`;\n    },\n    \"not-array-of-class\": ({ value, expectedClass, moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter must be an array of '${expectedClass}' objects. Received '${JSON.stringify(value)},'. Please check the call to ${moduleName}.${className}.${funcName}() to fix the issue.`;\n    },\n    \"max-entries-or-age-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.maxEntries' or 'config.maxAgeSeconds' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"statuses-or-headers-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.statuses' or 'config.headers' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"invalid-string\": ({ moduleName, funcName, paramName })=>{\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${moduleName}.${funcName}() for more info.`;\n    },\n    \"channel-name-required\": ()=>{\n        return \"You must provide a channelName to construct a \" + \"BroadcastCacheUpdate instance.\";\n    },\n    \"invalid-responses-are-same-args\": ()=>{\n        return \"The arguments passed into responsesAreSame() appear to be \" + \"invalid. Please ensure valid Responses are used.\";\n    },\n    \"expire-custom-caches-only\": ()=>{\n        return `You must provide a 'cacheName' property when using the ` + \"expiration plugin with a runtime caching strategy.\";\n    },\n    \"unit-must-be-bytes\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"single-range-only\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"invalid-range-values\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"no-range-header\": ()=>{\n        return \"No Range header was found in the Request provided.\";\n    },\n    \"range-not-satisfiable\": ({ size, start, end })=>{\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n    },\n    \"attempt-to-cache-non-get-request\": ({ url, method })=>{\n        return `Unable to cache '${url}' because it is a '${method}' request and only 'GET' requests can be cached.`;\n    },\n    \"cache-put-with-no-response\": ({ url })=>{\n        return `There was an attempt to cache '${url}' but the response was not defined.`;\n    },\n    \"no-response\": ({ url, error })=>{\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    \"bad-precaching-response\": ({ url, status })=>{\n        return `The precaching request for '${url}' failed${status ? ` with an HTTP status of ${status}.` : \".\"}`;\n    },\n    \"non-precached-url\": ({ url })=>{\n        return `'createHandlerBoundToURL(\"${url}\")' was called, but that URL is not precached. Please pass in a URL that is precached instead.`;\n    },\n    \"add-to-cache-list-conflicting-integrities\": ({ url })=>{\n        return `Two of the entries passed to '@serwist/precaching.PrecacheController.addToCacheList()' had the URL ${url} with different integrity values. Please remove one of them.`;\n    },\n    \"missing-precache-entry\": ({ cacheName, url })=>{\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    \"cross-origin-copy-response\": ({ origin })=>{\n        return `'@serwist/core.copyResponse()' can only be used with same-origin responses. It was passed a response with origin ${origin}.`;\n    },\n    \"opaque-streams-source\": ({ type })=>{\n        const message = `One of the '@serwist/streams' sources resulted in an '${type}' response.`;\n        if (type === \"opaqueredirect\") {\n            return `${message} Please do not use a navigation request that results in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    }\n};\n\nconst fallback = (code, ...args)=>{\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {})=>{\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nconst messageGenerator =  false ? 0 : generatorFunction;\n\nclass SerwistError extends Error {\n    details;\n    constructor(errorCode, details){\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\n\nlet supportStatus;\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response(\"\");\n        if (\"body\" in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            } catch (error) {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\n\nconst isArray = (value, details)=>{\n    if (!Array.isArray(value)) {\n        throw new SerwistError(\"not-an-array\", details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details)=>{\n    const type = typeof object[expectedMethod];\n    if (type !== \"function\") {\n        details.expectedMethod = expectedMethod;\n        throw new SerwistError(\"missing-a-method\", details);\n    }\n};\nconst isType = (object, expectedType, details)=>{\n    if (typeof object !== expectedType) {\n        details.expectedType = expectedType;\n        throw new SerwistError(\"incorrect-type\", details);\n    }\n};\nconst isInstance = (object, expectedClass, details)=>{\n    if (!(object instanceof expectedClass)) {\n        details.expectedClassName = expectedClass.name;\n        throw new SerwistError(\"incorrect-class\", details);\n    }\n};\nconst isOneOf = (value, validValues, details)=>{\n    if (!validValues.includes(value)) {\n        details.validValueDescription = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new SerwistError(\"invalid-value\", details);\n    }\n};\nconst isArrayOfClass = (value, expectedClass, details)=>{\n    const error = new SerwistError(\"not-array-of-class\", details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value){\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports =  false ? 0 : {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isType,\n    isArrayOfClass\n};\n\nconst logger =  false ? 0 : (()=>{\n    if (!(\"__WB_DISABLE_DEV_LOGS\" in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n    }\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: \"#7f8c8d\",\n        log: \"#2ecc71\",\n        warn: \"#f39c12\",\n        error: \"#c0392b\",\n        groupCollapsed: \"#3498db\",\n        groupEnd: null\n    };\n    const print = (method, args)=>{\n        if (self.__WB_DISABLE_DEV_LOGS) {\n            return;\n        }\n        if (method === \"groupCollapsed\") {\n            if (typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            \"border-radius: 0.5em\",\n            \"color: white\",\n            \"font-weight: bold\",\n            \"padding: 2px 0.5em\"\n        ];\n        const logPrefix = inGroup ? [] : [\n            \"%cserwist\",\n            styles.join(\";\")\n        ];\n        console[method](...logPrefix, ...args);\n        if (method === \"groupCollapsed\") {\n            inGroup = true;\n        }\n        if (method === \"groupEnd\") {\n            inGroup = false;\n        }\n    };\n    const loggerMethods = Object.keys(methodToColorMap);\n    return loggerMethods.reduce((api, method)=>{\n        api[method] = (...args)=>{\n            print(method, args);\n        };\n        return api;\n    }, {});\n})();\n\nconst quotaErrorCallbacks = new Set();\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrY29yZUA5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L2NvcmUvZGlzdC9jaHVua3MvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSwrREFBK0QsdUJBQXVCLDJCQUEyQixzQkFBc0I7QUFDeEssS0FBSztBQUNMLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsc0JBQXNCLFdBQVcsR0FBRyxVQUFVLEdBQUcsU0FBUztBQUNyRyxLQUFLO0FBQ0wseUJBQXlCLDBEQUEwRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RCxpQ0FBaUMsVUFBVSxzQkFBc0IsV0FBVyxHQUFHLGFBQWEsT0FBTyxTQUFTLHNCQUFzQixhQUFhO0FBQy9JLEtBQUs7QUFDTCwwQkFBMEIscUZBQXFGO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0EsNkNBQTZDLFdBQVcsR0FBRyxhQUFhLEVBQUUsU0FBUyxtQ0FBbUMsa0JBQWtCO0FBQ3hJO0FBQ0EsaUNBQWlDLFVBQVUsc0JBQXNCLFdBQVcsR0FBRyxhQUFhLEVBQUUs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCxDQUFDOztBQUVEOztBQUV1SiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrY29yZUA5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L2NvcmUvZGlzdC9jaHVua3MvcXVvdGFFcnJvckNhbGxiYWNrcy5qcz9iZThmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF9jYWNoZU5hbWVEZXRhaWxzID0ge1xuICAgIGdvb2dsZUFuYWx5dGljczogXCJnb29nbGVBbmFseXRpY3NcIixcbiAgICBwcmVjYWNoZTogXCJwcmVjYWNoZS12MlwiLFxuICAgIHByZWZpeDogXCJzZXJ3aXN0XCIsXG4gICAgcnVudGltZTogXCJydW50aW1lXCIsXG4gICAgc3VmZml4OiB0eXBlb2YgcmVnaXN0cmF0aW9uICE9PSBcInVuZGVmaW5lZFwiID8gcmVnaXN0cmF0aW9uLnNjb3BlIDogXCJcIlxufTtcbmNvbnN0IF9jcmVhdGVDYWNoZU5hbWUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIHJldHVybiBbXG4gICAgICAgIF9jYWNoZU5hbWVEZXRhaWxzLnByZWZpeCxcbiAgICAgICAgY2FjaGVOYW1lLFxuICAgICAgICBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXhcbiAgICBdLmZpbHRlcigodmFsdWUpPT52YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKS5qb2luKFwiLVwiKTtcbn07XG5jb25zdCBlYWNoQ2FjaGVOYW1lRGV0YWlsID0gKGZuKT0+e1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF9jYWNoZU5hbWVEZXRhaWxzKSl7XG4gICAgICAgIGZuKGtleSk7XG4gICAgfVxufTtcbmNvbnN0IGNhY2hlTmFtZXMgPSB7XG4gICAgdXBkYXRlRGV0YWlsczogKGRldGFpbHMpPT57XG4gICAgICAgIGVhY2hDYWNoZU5hbWVEZXRhaWwoKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IGRldGFpbHNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgX2NhY2hlTmFtZURldGFpbHNba2V5XSA9IGRldGFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRHb29nbGVBbmFseXRpY3NOYW1lOiAodXNlckNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5nb29nbGVBbmFseXRpY3MpO1xuICAgIH0sXG4gICAgZ2V0UHJlY2FjaGVOYW1lOiAodXNlckNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5wcmVjYWNoZSk7XG4gICAgfSxcbiAgICBnZXRQcmVmaXg6ICgpPT57XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXg7XG4gICAgfSxcbiAgICBnZXRSdW50aW1lTmFtZTogKHVzZXJDYWNoZU5hbWUpPT57XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMucnVudGltZSk7XG4gICAgfSxcbiAgICBnZXRTdWZmaXg6ICgpPT57XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXg7XG4gICAgfVxufTtcblxuY29uc3QgbWVzc2FnZXMgPSB7XG4gICAgXCJpbnZhbGlkLXZhbHVlXCI6ICh7IHBhcmFtTmFtZSwgdmFsaWRWYWx1ZURlc2NyaXB0aW9uLCB2YWx1ZSB9KT0+e1xuICAgICAgICBpZiAoIXBhcmFtTmFtZSB8fCAhdmFsaWRWYWx1ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtdmFsdWUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgZ2l2ZW4gYSB2YWx1ZSB3aXRoIGFuIGAgKyBgdW5leHBlY3RlZCB2YWx1ZS4gJHt2YWxpZFZhbHVlRGVzY3JpcHRpb259IFJlY2VpdmVkIGEgdmFsdWUgb2YgYCArIGAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uYDtcbiAgICB9LFxuICAgIFwibm90LWFuLWFycmF5XCI6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KT0+e1xuICAgICAgICBpZiAoIW1vZHVsZU5hbWUgfHwgIWNsYXNzTmFtZSB8fCAhZnVuY05hbWUgfHwgIXBhcmFtTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdub3QtYW4tYXJyYXknIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICsgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpJyBtdXN0IGJlIGFuIGFycmF5LmA7XG4gICAgfSxcbiAgICBcImluY29ycmVjdC10eXBlXCI6ICh7IGV4cGVjdGVkVHlwZSwgcGFyYW1OYW1lLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pPT57XG4gICAgICAgIGlmICghZXhwZWN0ZWRUeXBlIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC10eXBlJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGFzc05hbWVTdHIgPSBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LmAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZVN0cn1gICsgYCR7ZnVuY05hbWV9KCknIG11c3QgYmUgb2YgdHlwZSAke2V4cGVjdGVkVHlwZX0uYDtcbiAgICB9LFxuICAgIFwiaW5jb3JyZWN0LWNsYXNzXCI6ICh7IGV4cGVjdGVkQ2xhc3NOYW1lLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIGlzUmV0dXJuVmFsdWVQcm9ibGVtIH0pPT57XG4gICAgICAgIGlmICghZXhwZWN0ZWRDbGFzc05hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2luY29ycmVjdC1jbGFzcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xhc3NOYW1lU3RyID0gY2xhc3NOYW1lID8gYCR7Y2xhc3NOYW1lfS5gIDogXCJcIjtcbiAgICAgICAgaWYgKGlzUmV0dXJuVmFsdWVQcm9ibGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gYFRoZSByZXR1cm4gdmFsdWUgZnJvbSAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZVN0cn0ke2Z1bmNOYW1lfSgpJyBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGNsYXNzICR7ZXhwZWN0ZWRDbGFzc05hbWV9LmA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcGFyYW1ldGVyICcke3BhcmFtTmFtZX0nIHBhc3NlZCBpbnRvIGAgKyBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWVTdHJ9JHtmdW5jTmFtZX0oKScgYCArIGBtdXN0IGJlIGFuIGluc3RhbmNlIG9mIGNsYXNzICR7ZXhwZWN0ZWRDbGFzc05hbWV9LmA7XG4gICAgfSxcbiAgICBcIm1pc3NpbmctYS1tZXRob2RcIjogKHsgZXhwZWN0ZWRNZXRob2QsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KT0+e1xuICAgICAgICBpZiAoIWV4cGVjdGVkTWV0aG9kIHx8ICFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWNsYXNzTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnbWlzc2luZy1hLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSgpIGV4cGVjdGVkIHRoZSBgICsgYCcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB0byBleHBvc2UgYSAnJHtleHBlY3RlZE1ldGhvZH0nIG1ldGhvZC5gO1xuICAgIH0sXG4gICAgXCJhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGVcIjogKHsgZW50cnkgfSk9PntcbiAgICAgICAgcmV0dXJuIGBBbiB1bmV4cGVjdGVkIGVudHJ5IHdhcyBwYXNzZWQgdG8gJ0BzZXJ3aXN0L3ByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIFRoZSBlbnRyeSAnJHtKU09OLnN0cmluZ2lmeShlbnRyeSl9JyBpc24ndCBzdXBwb3J0ZWQuIFlvdSBtdXN0IHN1cHBseSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggb25lIG9yIG1vcmUgY2hhcmFjdGVycywgb2JqZWN0cyB3aXRoIGEgdXJsIHByb3BlcnR5IG9yIFJlcXVlc3Qgb2JqZWN0cy5gO1xuICAgIH0sXG4gICAgXCJhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzXCI6ICh7IGZpcnN0RW50cnksIHNlY29uZEVudHJ5IH0pPT57XG4gICAgICAgIGlmICghZmlyc3RFbnRyeSB8fCAhc2Vjb25kRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaW5wdXQgdG8gXCIgKyBgJ2FkZC10by1jYWNoZS1saXN0LWR1cGxpY2F0ZS1lbnRyaWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gJ0BzZXJ3aXN0L3ByZWNhY2hpbmcuUHJlY2FjaGVDb250cm9sbGVyLmFkZFRvQ2FjaGVMaXN0KCknIGhhZCB0aGUgVVJMICR7Zmlyc3RFbnRyeX0gYnV0IGRpZmZlcmVudCByZXZpc2lvbiBkZXRhaWxzLiBTZXJ3aXN0IGlzIHVuYWJsZSB0byBjYWNoZSBhbmQgdmVyc2lvbiB0aGUgYXNzZXQgY29ycmVjdGx5LiBQbGVhc2UgcmVtb3ZlIG9uZSBvZiB0aGUgZW50cmllcy5gO1xuICAgIH0sXG4gICAgXCJwbHVnaW4tZXJyb3ItcmVxdWVzdC13aWxsLWZldGNoXCI6ICh7IHRocm93bkVycm9yTWVzc2FnZSB9KT0+e1xuICAgICAgICBpZiAoIXRocm93bkVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBpbnB1dCB0byBcIiArIGAncGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaCcsIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgQW4gZXJyb3Igd2FzIHRocm93biBieSBhIHBsdWdpbidzICdyZXF1ZXN0V2lsbEZldGNoKCknIG1ldGhvZC4gVGhlIHRocm93biBlcnJvciBtZXNzYWdlIHdhczogJyR7dGhyb3duRXJyb3JNZXNzYWdlfScuYDtcbiAgICB9LFxuICAgIFwiaW52YWxpZC1jYWNoZS1uYW1lXCI6ICh7IGNhY2hlTmFtZUlkLCB2YWx1ZSB9KT0+e1xuICAgICAgICBpZiAoIWNhY2hlTmFtZUlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgJ2NhY2hlTmFtZUlkJyBmb3IgZXJyb3IgJ2ludmFsaWQtY2FjaGUtbmFtZSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IHByb3ZpZGUgYSBuYW1lIGNvbnRhaW5pbmcgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBmb3Igc2V0Q2FjaGVEZXRhaWxzKHske2NhY2hlTmFtZUlkfTogJy4uLid9KS4gUmVjZWl2ZWQgYSB2YWx1ZSBvZiAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9J2A7XG4gICAgfSxcbiAgICBcInVucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZFwiOiAoeyBtZXRob2QgfSk9PntcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaW5wdXQgdG8gXCIgKyBgJ3VucmVnaXN0ZXItcm91dGUtYnV0LW5vdC1mb3VuZC13aXRoLW1ldGhvZCcgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcm91dGUgeW91J3JlIHRyeWluZyB0byB1bnJlZ2lzdGVyIHdhcyBub3QgIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBmb3IgdGhlIG1ldGhvZCB0eXBlICcke21ldGhvZH0nLmA7XG4gICAgfSxcbiAgICBcInVucmVnaXN0ZXItcm91dGUtcm91dGUtbm90LXJlZ2lzdGVyZWRcIjogKCk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgcm91dGUgeW91J3JlIHRyeWluZyB0byB1bnJlZ2lzdGVyIHdhcyBub3QgcHJldmlvdXNseSBgICsgXCJyZWdpc3RlcmVkLlwiO1xuICAgIH0sXG4gICAgXCJxdWV1ZS1yZXBsYXktZmFpbGVkXCI6ICh7IG5hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBSZXBsYXlpbmcgdGhlIGJhY2tncm91bmQgc3luYyBxdWV1ZSAnJHtuYW1lfScgZmFpbGVkLmA7XG4gICAgfSxcbiAgICBcImR1cGxpY2F0ZS1xdWV1ZS1uYW1lXCI6ICh7IG5hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgUXVldWUgbmFtZSAnJHtuYW1lfScgaXMgYWxyZWFkeSBiZWluZyB1c2VkLiBBbGwgaW5zdGFuY2VzIG9mIGJhY2tncm91bmRTeW5jLlF1ZXVlIG11c3QgYmUgZ2l2ZW4gdW5pcXVlIG5hbWVzLmA7XG4gICAgfSxcbiAgICBcImV4cGlyZWQtdGVzdC13aXRob3V0LW1heC1hZ2VcIjogKHsgbWV0aG9kTmFtZSwgcGFyYW1OYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlICcke21ldGhvZE5hbWV9KCknIG1ldGhvZCBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGAgKyBgJyR7cGFyYW1OYW1lfScgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3IuYDtcbiAgICB9LFxuICAgIFwidW5zdXBwb3J0ZWQtcm91dGUtdHlwZVwiOiAoeyBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lLCBwYXJhbU5hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgc3VwcGxpZWQgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHdhcyBhbiB1bnN1cHBvcnRlZCB0eXBlLiBQbGVhc2UgY2hlY2sgdGhlIGRvY3MgZm9yICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9IGZvciB2YWxpZCBpbnB1dCB0eXBlcy5gO1xuICAgIH0sXG4gICAgXCJub3QtYXJyYXktb2YtY2xhc3NcIjogKHsgdmFsdWUsIGV4cGVjdGVkQ2xhc3MsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZSBzdXBwbGllZCAnJHtwYXJhbU5hbWV9JyBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBhcnJheSBvZiAnJHtleHBlY3RlZENsYXNzfScgb2JqZWN0cy4gUmVjZWl2ZWQgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSwnLiBQbGVhc2UgY2hlY2sgdGhlIGNhbGwgdG8gJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0oKSB0byBmaXggdGhlIGlzc3VlLmA7XG4gICAgfSxcbiAgICBcIm1heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZFwiOiAoeyBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgZGVmaW5lIGVpdGhlciAnY29uZmlnLm1heEVudHJpZXMnIG9yICdjb25maWcubWF4QWdlU2Vjb25kcycgaW4gJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9J2A7XG4gICAgfSxcbiAgICBcInN0YXR1c2VzLW9yLWhlYWRlcnMtcmVxdWlyZWRcIjogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IGRlZmluZSBlaXRoZXIgJ2NvbmZpZy5zdGF0dXNlcycgb3IgJ2NvbmZpZy5oZWFkZXJzJyBpbiAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZX0uJHtmdW5jTmFtZX0nYDtcbiAgICB9LFxuICAgIFwiaW52YWxpZC1zdHJpbmdcIjogKHsgbW9kdWxlTmFtZSwgZnVuY05hbWUsIHBhcmFtTmFtZSB9KT0+e1xuICAgICAgICBpZiAoIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW52YWxpZC1zdHJpbmcnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgV2hlbiB1c2luZyBzdHJpbmdzLCB0aGUgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIG11c3Qgc3RhcnQgd2l0aCAnaHR0cCcgKGZvciBjcm9zcy1vcmlnaW4gbWF0Y2hlcykgb3IgJy8nIChmb3Igc2FtZS1vcmlnaW4gbWF0Y2hlcykuIFBsZWFzZSBzZWUgdGhlIGRvY3MgZm9yICR7bW9kdWxlTmFtZX0uJHtmdW5jTmFtZX0oKSBmb3IgbW9yZSBpbmZvLmA7XG4gICAgfSxcbiAgICBcImNoYW5uZWwtbmFtZS1yZXF1aXJlZFwiOiAoKT0+e1xuICAgICAgICByZXR1cm4gXCJZb3UgbXVzdCBwcm92aWRlIGEgY2hhbm5lbE5hbWUgdG8gY29uc3RydWN0IGEgXCIgKyBcIkJyb2FkY2FzdENhY2hlVXBkYXRlIGluc3RhbmNlLlwiO1xuICAgIH0sXG4gICAgXCJpbnZhbGlkLXJlc3BvbnNlcy1hcmUtc2FtZS1hcmdzXCI6ICgpPT57XG4gICAgICAgIHJldHVybiBcIlRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gcmVzcG9uc2VzQXJlU2FtZSgpIGFwcGVhciB0byBiZSBcIiArIFwiaW52YWxpZC4gUGxlYXNlIGVuc3VyZSB2YWxpZCBSZXNwb25zZXMgYXJlIHVzZWQuXCI7XG4gICAgfSxcbiAgICBcImV4cGlyZS1jdXN0b20tY2FjaGVzLW9ubHlcIjogKCk9PntcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBwcm92aWRlIGEgJ2NhY2hlTmFtZScgcHJvcGVydHkgd2hlbiB1c2luZyB0aGUgYCArIFwiZXhwaXJhdGlvbiBwbHVnaW4gd2l0aCBhIHJ1bnRpbWUgY2FjaGluZyBzdHJhdGVneS5cIjtcbiAgICB9LFxuICAgIFwidW5pdC1tdXN0LWJlLWJ5dGVzXCI6ICh7IG5vcm1hbGl6ZWRSYW5nZUhlYWRlciB9KT0+e1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICd1bml0LW11c3QtYmUtYnl0ZXMnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlICd1bml0JyBwb3J0aW9uIG9mIHRoZSBSYW5nZSBoZWFkZXIgbXVzdCBiZSBzZXQgdG8gJ2J5dGVzJy4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICBcInNpbmdsZS1yYW5nZS1vbmx5XCI6ICh7IG5vcm1hbGl6ZWRSYW5nZUhlYWRlciB9KT0+e1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdzaW5nbGUtcmFuZ2Utb25seScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBNdWx0aXBsZSByYW5nZXMgYXJlIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgYSAgc2luZ2xlIHN0YXJ0IHZhbHVlLCBhbmQgb3B0aW9uYWwgZW5kIHZhbHVlLiBUaGUgUmFuZ2UgaGVhZGVyIHByb3ZpZGVkIHdhcyBcIiR7bm9ybWFsaXplZFJhbmdlSGVhZGVyfVwiYDtcbiAgICB9LFxuICAgIFwiaW52YWxpZC1yYW5nZS12YWx1ZXNcIjogKHsgbm9ybWFsaXplZFJhbmdlSGVhZGVyIH0pPT57XG4gICAgICAgIGlmICghbm9ybWFsaXplZFJhbmdlSGVhZGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtcmFuZ2UtdmFsdWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBSYW5nZSBoZWFkZXIgaXMgbWlzc2luZyBib3RoIHN0YXJ0IGFuZCBlbmQgdmFsdWVzLiBBdCBsZWFzdCBvbmUgb2YgdGhvc2UgdmFsdWVzIGlzIG5lZWRlZC4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICBcIm5vLXJhbmdlLWhlYWRlclwiOiAoKT0+e1xuICAgICAgICByZXR1cm4gXCJObyBSYW5nZSBoZWFkZXIgd2FzIGZvdW5kIGluIHRoZSBSZXF1ZXN0IHByb3ZpZGVkLlwiO1xuICAgIH0sXG4gICAgXCJyYW5nZS1ub3Qtc2F0aXNmaWFibGVcIjogKHsgc2l6ZSwgc3RhcnQsIGVuZCB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZSBzdGFydCAoJHtzdGFydH0pIGFuZCBlbmQgKCR7ZW5kfSkgdmFsdWVzIGluIHRoZSBSYW5nZSBhcmUgYCArIGBub3Qgc2F0aXNmaWFibGUgYnkgdGhlIGNhY2hlZCByZXNwb25zZSwgd2hpY2ggaXMgJHtzaXplfSBieXRlcy5gO1xuICAgIH0sXG4gICAgXCJhdHRlbXB0LXRvLWNhY2hlLW5vbi1nZXQtcmVxdWVzdFwiOiAoeyB1cmwsIG1ldGhvZCB9KT0+e1xuICAgICAgICByZXR1cm4gYFVuYWJsZSB0byBjYWNoZSAnJHt1cmx9JyBiZWNhdXNlIGl0IGlzIGEgJyR7bWV0aG9kfScgcmVxdWVzdCBhbmQgb25seSAnR0VUJyByZXF1ZXN0cyBjYW4gYmUgY2FjaGVkLmA7XG4gICAgfSxcbiAgICBcImNhY2hlLXB1dC13aXRoLW5vLXJlc3BvbnNlXCI6ICh7IHVybCB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZXJlIHdhcyBhbiBhdHRlbXB0IHRvIGNhY2hlICcke3VybH0nIGJ1dCB0aGUgcmVzcG9uc2Ugd2FzIG5vdCBkZWZpbmVkLmA7XG4gICAgfSxcbiAgICBcIm5vLXJlc3BvbnNlXCI6ICh7IHVybCwgZXJyb3IgfSk9PntcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgVGhlIHN0cmF0ZWd5IGNvdWxkIG5vdCBnZW5lcmF0ZSBhIHJlc3BvbnNlIGZvciAnJHt1cmx9Jy5gO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBUaGUgdW5kZXJseWluZyBlcnJvciBpcyAke2Vycm9yfS5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0sXG4gICAgXCJiYWQtcHJlY2FjaGluZy1yZXNwb25zZVwiOiAoeyB1cmwsIHN0YXR1cyB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZSBwcmVjYWNoaW5nIHJlcXVlc3QgZm9yICcke3VybH0nIGZhaWxlZCR7c3RhdHVzID8gYCB3aXRoIGFuIEhUVFAgc3RhdHVzIG9mICR7c3RhdHVzfS5gIDogXCIuXCJ9YDtcbiAgICB9LFxuICAgIFwibm9uLXByZWNhY2hlZC11cmxcIjogKHsgdXJsIH0pPT57XG4gICAgICAgIHJldHVybiBgJ2NyZWF0ZUhhbmRsZXJCb3VuZFRvVVJMKFwiJHt1cmx9XCIpJyB3YXMgY2FsbGVkLCBidXQgdGhhdCBVUkwgaXMgbm90IHByZWNhY2hlZC4gUGxlYXNlIHBhc3MgaW4gYSBVUkwgdGhhdCBpcyBwcmVjYWNoZWQgaW5zdGVhZC5gO1xuICAgIH0sXG4gICAgXCJhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1pbnRlZ3JpdGllc1wiOiAoeyB1cmwgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUd28gb2YgdGhlIGVudHJpZXMgcGFzc2VkIHRvICdAc2Vyd2lzdC9wcmVjYWNoaW5nLlByZWNhY2hlQ29udHJvbGxlci5hZGRUb0NhY2hlTGlzdCgpJyBoYWQgdGhlIFVSTCAke3VybH0gd2l0aCBkaWZmZXJlbnQgaW50ZWdyaXR5IHZhbHVlcy4gUGxlYXNlIHJlbW92ZSBvbmUgb2YgdGhlbS5gO1xuICAgIH0sXG4gICAgXCJtaXNzaW5nLXByZWNhY2hlLWVudHJ5XCI6ICh7IGNhY2hlTmFtZSwgdXJsIH0pPT57XG4gICAgICAgIHJldHVybiBgVW5hYmxlIHRvIGZpbmQgYSBwcmVjYWNoZWQgcmVzcG9uc2UgaW4gJHtjYWNoZU5hbWV9IGZvciAke3VybH0uYDtcbiAgICB9LFxuICAgIFwiY3Jvc3Mtb3JpZ2luLWNvcHktcmVzcG9uc2VcIjogKHsgb3JpZ2luIH0pPT57XG4gICAgICAgIHJldHVybiBgJ0BzZXJ3aXN0L2NvcmUuY29weVJlc3BvbnNlKCknIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBzYW1lLW9yaWdpbiByZXNwb25zZXMuIEl0IHdhcyBwYXNzZWQgYSByZXNwb25zZSB3aXRoIG9yaWdpbiAke29yaWdpbn0uYDtcbiAgICB9LFxuICAgIFwib3BhcXVlLXN0cmVhbXMtc291cmNlXCI6ICh7IHR5cGUgfSk9PntcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBPbmUgb2YgdGhlICdAc2Vyd2lzdC9zdHJlYW1zJyBzb3VyY2VzIHJlc3VsdGVkIGluIGFuICcke3R5cGV9JyByZXNwb25zZS5gO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJvcGFxdWVyZWRpcmVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7bWVzc2FnZX0gUGxlYXNlIGRvIG5vdCB1c2UgYSBuYXZpZ2F0aW9uIHJlcXVlc3QgdGhhdCByZXN1bHRzIGluIGEgcmVkaXJlY3QgYXMgYSBzb3VyY2UuYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bWVzc2FnZX0gUGxlYXNlIGVuc3VyZSB5b3VyIHNvdXJjZXMgYXJlIENPUlMtZW5hYmxlZC5gO1xuICAgIH1cbn07XG5cbmNvbnN0IGZhbGxiYWNrID0gKGNvZGUsIC4uLmFyZ3MpPT57XG4gICAgbGV0IG1zZyA9IGNvZGU7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cgKz0gYCA6OiAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWA7XG4gICAgfVxuICAgIHJldHVybiBtc2c7XG59O1xuY29uc3QgZ2VuZXJhdG9yRnVuY3Rpb24gPSAoY29kZSwgZGV0YWlscyA9IHt9KT0+e1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlc1tjb2RlXTtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBtZXNzYWdlIGZvciBjb2RlICcke2NvZGV9Jy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2UoZGV0YWlscyk7XG59O1xuY29uc3QgbWVzc2FnZUdlbmVyYXRvciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IGZhbGxiYWNrIDogZ2VuZXJhdG9yRnVuY3Rpb247XG5cbmNsYXNzIFNlcndpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBkZXRhaWxzO1xuICAgIGNvbnN0cnVjdG9yKGVycm9yQ29kZSwgZGV0YWlscyl7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBtZXNzYWdlR2VuZXJhdG9yKGVycm9yQ29kZSwgZGV0YWlscyk7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBlcnJvckNvZGU7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgfVxufVxuXG5sZXQgc3VwcG9ydFN0YXR1cztcbmZ1bmN0aW9uIGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0oKSB7XG4gICAgaWYgKHN1cHBvcnRTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB0ZXN0UmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoXCJcIik7XG4gICAgICAgIGlmIChcImJvZHlcIiBpbiB0ZXN0UmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbmV3IFJlc3BvbnNlKHRlc3RSZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgICAgICBzdXBwb3J0U3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cHBvcnRTdGF0dXMgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cHBvcnRTdGF0dXM7XG59XG5cbmNvbnN0IGlzQXJyYXkgPSAodmFsdWUsIGRldGFpbHMpPT57XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm90LWFuLWFycmF5XCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBoYXNNZXRob2QgPSAob2JqZWN0LCBleHBlY3RlZE1ldGhvZCwgZGV0YWlscyk9PntcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdFtleHBlY3RlZE1ldGhvZF07XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkZXRhaWxzLmV4cGVjdGVkTWV0aG9kID0gZXhwZWN0ZWRNZXRob2Q7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJtaXNzaW5nLWEtbWV0aG9kXCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc1R5cGUgPSAob2JqZWN0LCBleHBlY3RlZFR5cGUsIGRldGFpbHMpPT57XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBkZXRhaWxzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImluY29ycmVjdC10eXBlXCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc0luc3RhbmNlID0gKG9iamVjdCwgZXhwZWN0ZWRDbGFzcywgZGV0YWlscyk9PntcbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICBkZXRhaWxzLmV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lO1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW5jb3JyZWN0LWNsYXNzXCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc09uZU9mID0gKHZhbHVlLCB2YWxpZFZhbHVlcywgZGV0YWlscyk9PntcbiAgICBpZiAoIXZhbGlkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBkZXRhaWxzLnZhbGlkVmFsdWVEZXNjcmlwdGlvbiA9IGBWYWxpZCB2YWx1ZXMgYXJlICR7SlNPTi5zdHJpbmdpZnkodmFsaWRWYWx1ZXMpfS5gO1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC12YWx1ZVwiLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNBcnJheU9mQ2xhc3MgPSAodmFsdWUsIGV4cGVjdGVkQ2xhc3MsIGRldGFpbHMpPT57XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU2Vyd2lzdEVycm9yKFwibm90LWFycmF5LW9mLWNsYXNzXCIsIGRldGFpbHMpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSl7XG4gICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZmluYWxBc3NlcnRFeHBvcnRzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbnVsbCA6IHtcbiAgICBoYXNNZXRob2QsXG4gICAgaXNBcnJheSxcbiAgICBpc0luc3RhbmNlLFxuICAgIGlzT25lT2YsXG4gICAgaXNUeXBlLFxuICAgIGlzQXJyYXlPZkNsYXNzXG59O1xuXG5jb25zdCBsb2dnZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBudWxsIDogKCgpPT57XG4gICAgaWYgKCEoXCJfX1dCX0RJU0FCTEVfREVWX0xPR1NcIiBpbiBnbG9iYWxUaGlzKSkge1xuICAgICAgICBzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUyA9IGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5Hcm91cCA9IGZhbHNlO1xuICAgIGNvbnN0IG1ldGhvZFRvQ29sb3JNYXAgPSB7XG4gICAgICAgIGRlYnVnOiBcIiM3ZjhjOGRcIixcbiAgICAgICAgbG9nOiBcIiMyZWNjNzFcIixcbiAgICAgICAgd2FybjogXCIjZjM5YzEyXCIsXG4gICAgICAgIGVycm9yOiBcIiNjMDM5MmJcIixcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IFwiIzM0OThkYlwiLFxuICAgICAgICBncm91cEVuZDogbnVsbFxuICAgIH07XG4gICAgY29uc3QgcHJpbnQgPSAobWV0aG9kLCBhcmdzKT0+e1xuICAgICAgICBpZiAoc2VsZi5fX1dCX0RJU0FCTEVfREVWX0xPR1MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImdyb3VwQ29sbGFwc2VkXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IFtcbiAgICAgICAgICAgIGBiYWNrZ3JvdW5kOiAke21ldGhvZFRvQ29sb3JNYXBbbWV0aG9kXX1gLFxuICAgICAgICAgICAgXCJib3JkZXItcmFkaXVzOiAwLjVlbVwiLFxuICAgICAgICAgICAgXCJjb2xvcjogd2hpdGVcIixcbiAgICAgICAgICAgIFwiZm9udC13ZWlnaHQ6IGJvbGRcIixcbiAgICAgICAgICAgIFwicGFkZGluZzogMnB4IDAuNWVtXCJcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbG9nUHJlZml4ID0gaW5Hcm91cCA/IFtdIDogW1xuICAgICAgICAgICAgXCIlY3Nlcndpc3RcIixcbiAgICAgICAgICAgIHN0eWxlcy5qb2luKFwiO1wiKVxuICAgICAgICBdO1xuICAgICAgICBjb25zb2xlW21ldGhvZF0oLi4ubG9nUHJlZml4LCAuLi5hcmdzKTtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJncm91cENvbGxhcHNlZFwiKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImdyb3VwRW5kXCIpIHtcbiAgICAgICAgICAgIGluR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbG9nZ2VyTWV0aG9kcyA9IE9iamVjdC5rZXlzKG1ldGhvZFRvQ29sb3JNYXApO1xuICAgIHJldHVybiBsb2dnZXJNZXRob2RzLnJlZHVjZSgoYXBpLCBtZXRob2QpPT57XG4gICAgICAgIGFwaVttZXRob2RdID0gKC4uLmFyZ3MpPT57XG4gICAgICAgICAgICBwcmludChtZXRob2QsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYXBpO1xuICAgIH0sIHt9KTtcbn0pKCk7XG5cbmNvbnN0IHF1b3RhRXJyb3JDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmV4cG9ydCB7IFNlcndpc3RFcnJvciBhcyBTLCBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIGFzIGEsIGNhY2hlTmFtZXMgYXMgYywgZmluYWxBc3NlcnRFeHBvcnRzIGFzIGYsIGxvZ2dlciBhcyBsLCBxdW90YUVycm9yQ2FsbGJhY2tzIGFzIHEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/chunks/quotaErrorCallbacks.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js ***!
  \******************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: function() { return /* binding */ Deferred; },\n/* harmony export */   SerwistError: function() { return /* reexport safe */ _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.S; },\n/* harmony export */   assert: function() { return /* reexport safe */ _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.f; },\n/* harmony export */   cacheMatchIgnoreParams: function() { return /* binding */ cacheMatchIgnoreParams; },\n/* harmony export */   canConstructReadableStream: function() { return /* binding */ canConstructReadableStream; },\n/* harmony export */   canConstructResponseFromBodyStream: function() { return /* reexport safe */ _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.a; },\n/* harmony export */   dontWaitFor: function() { return /* binding */ dontWaitFor; },\n/* harmony export */   executeQuotaErrorCallbacks: function() { return /* binding */ executeQuotaErrorCallbacks; },\n/* harmony export */   getFriendlyURL: function() { return /* binding */ getFriendlyURL; },\n/* harmony export */   logger: function() { return /* reexport safe */ _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.l; },\n/* harmony export */   privateCacheNames: function() { return /* reexport safe */ _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c; },\n/* harmony export */   resultingClientExists: function() { return /* binding */ resultingClientExists; },\n/* harmony export */   timeout: function() { return /* binding */ timeout; },\n/* harmony export */   waitUntil: function() { return /* binding */ waitUntil; }\n/* harmony export */ });\n/* harmony import */ var _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/quotaErrorCallbacks.js */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/chunks/quotaErrorCallbacks.js\");\n\n\n\nclass Deferred {\n    promise;\n    resolve;\n    reject;\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nfunction stripParams(fullURL, ignoreParams) {\n    const strippedURL = new URL(fullURL);\n    for (const param of ignoreParams){\n        strippedURL.searchParams.delete(param);\n    }\n    return strippedURL.href;\n}\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n    const strippedRequestURL = stripParams(request.url, ignoreParams);\n    if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n    }\n    const keysOptions = {\n        ...matchOptions,\n        ignoreSearch: true\n    };\n    const cacheKeys = await cache.keys(request, keysOptions);\n    for (const cacheKey of cacheKeys){\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n            return cache.match(cacheKey, matchOptions);\n        }\n    }\n    return;\n}\n\nlet supportStatus;\nfunction canConstructReadableStream() {\n    if (supportStatus === undefined) {\n        try {\n            new ReadableStream({\n                start () {}\n            });\n            supportStatus = true;\n        } catch (error) {\n            supportStatus = false;\n        }\n    }\n    return supportStatus;\n}\n\nfunction dontWaitFor(promise) {\n    void promise.then(()=>{});\n}\n\nconst executeQuotaErrorCallbacks = async ()=>{\n    if (true) {\n        _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`About to run ${_chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.q.size} callbacks to clean up caches.`);\n    }\n    for (const callback of _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.q){\n        await callback();\n        if (true) {\n            _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.l.log(callback, \"is complete.\");\n        }\n    }\n    if (true) {\n        _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Finished running callbacks.\");\n    }\n};\n\nconst getFriendlyURL = (url)=>{\n    const urlObj = new URL(String(url), location.href);\n    return urlObj.href.replace(new RegExp(`^${location.origin}`), \"\");\n};\n\nfunction timeout(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n\nconst MAX_RETRY_TIME = 2000;\nasync function resultingClientExists(resultingClientId) {\n    if (!resultingClientId) {\n        return;\n    }\n    let existingWindows = await self.clients.matchAll({\n        type: \"window\"\n    });\n    const existingWindowIds = new Set(existingWindows.map((w)=>w.id));\n    let resultingWindow = undefined;\n    const startTime = performance.now();\n    while(performance.now() - startTime < MAX_RETRY_TIME){\n        existingWindows = await self.clients.matchAll({\n            type: \"window\"\n        });\n        resultingWindow = existingWindows.find((w)=>{\n            if (resultingClientId) {\n                return w.id === resultingClientId;\n            }\n            return !existingWindowIds.has(w.id);\n        });\n        if (resultingWindow) {\n            break;\n        }\n        await timeout(100);\n    }\n    return resultingWindow;\n}\n\nconst waitUntil = (event, asyncFn)=>{\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrY29yZUA5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L2NvcmUvZGlzdC9pbmRleC5pbnRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Y7QUFDMEQ7O0FBRWxKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qjs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0MsUUFBUSw2REFBTSxxQkFBcUIsNkRBQW1CLE9BQU87QUFDN0Q7QUFDQSwyQkFBMkIsNkRBQW1CO0FBQzlDO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDZEQUFNO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDLFFBQVEsNkRBQU07QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVvTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrY29yZUA5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L2NvcmUvZGlzdC9pbmRleC5pbnRlcm5hbC5qcz9jNGI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGwgYXMgbG9nZ2VyLCBxIGFzIHF1b3RhRXJyb3JDYWxsYmFja3MgfSBmcm9tICcuL2NodW5rcy9xdW90YUVycm9yQ2FsbGJhY2tzLmpzJztcbmV4cG9ydCB7IFMgYXMgU2Vyd2lzdEVycm9yLCBmIGFzIGFzc2VydCwgYSBhcyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtLCBjIGFzIHByaXZhdGVDYWNoZU5hbWVzIH0gZnJvbSAnLi9jaHVua3MvcXVvdGFFcnJvckNhbGxiYWNrcy5qcyc7XG5cbmNsYXNzIERlZmVycmVkIHtcbiAgICBwcm9taXNlO1xuICAgIHJlc29sdmU7XG4gICAgcmVqZWN0O1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBQYXJhbXMoZnVsbFVSTCwgaWdub3JlUGFyYW1zKSB7XG4gICAgY29uc3Qgc3RyaXBwZWRVUkwgPSBuZXcgVVJMKGZ1bGxVUkwpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgaWdub3JlUGFyYW1zKXtcbiAgICAgICAgc3RyaXBwZWRVUkwuc2VhcmNoUGFyYW1zLmRlbGV0ZShwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpcHBlZFVSTC5ocmVmO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FjaGVNYXRjaElnbm9yZVBhcmFtcyhjYWNoZSwgcmVxdWVzdCwgaWdub3JlUGFyYW1zLCBtYXRjaE9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHJpcHBlZFJlcXVlc3RVUkwgPSBzdHJpcFBhcmFtcyhyZXF1ZXN0LnVybCwgaWdub3JlUGFyYW1zKTtcbiAgICBpZiAocmVxdWVzdC51cmwgPT09IHN0cmlwcGVkUmVxdWVzdFVSTCkge1xuICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2gocmVxdWVzdCwgbWF0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qga2V5c09wdGlvbnMgPSB7XG4gICAgICAgIC4uLm1hdGNoT3B0aW9ucyxcbiAgICAgICAgaWdub3JlU2VhcmNoOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBhd2FpdCBjYWNoZS5rZXlzKHJlcXVlc3QsIGtleXNPcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlS2V5IG9mIGNhY2hlS2V5cyl7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkQ2FjaGVLZXlVUkwgPSBzdHJpcFBhcmFtcyhjYWNoZUtleS51cmwsIGlnbm9yZVBhcmFtcyk7XG4gICAgICAgIGlmIChzdHJpcHBlZFJlcXVlc3RVUkwgPT09IHN0cmlwcGVkQ2FjaGVLZXlVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChjYWNoZUtleSwgbWF0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5cbmxldCBzdXBwb3J0U3RhdHVzO1xuZnVuY3Rpb24gY2FuQ29uc3RydWN0UmVhZGFibGVTdHJlYW0oKSB7XG4gICAgaWYgKHN1cHBvcnRTdGF0dXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgICAgICBzdGFydCAoKSB7fVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdXBwb3J0U3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHN1cHBvcnRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydFN0YXR1cztcbn1cblxuZnVuY3Rpb24gZG9udFdhaXRGb3IocHJvbWlzZSkge1xuICAgIHZvaWQgcHJvbWlzZS50aGVuKCgpPT57fSk7XG59XG5cbmNvbnN0IGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzID0gYXN5bmMgKCk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYEFib3V0IHRvIHJ1biAke3F1b3RhRXJyb3JDYWxsYmFja3Muc2l6ZX0gY2FsbGJhY2tzIHRvIGNsZWFuIHVwIGNhY2hlcy5gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBxdW90YUVycm9yQ2FsbGJhY2tzKXtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhjYWxsYmFjaywgXCJpcyBjb21wbGV0ZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBsb2dnZXIubG9nKFwiRmluaXNoZWQgcnVubmluZyBjYWxsYmFja3MuXCIpO1xuICAgIH1cbn07XG5cbmNvbnN0IGdldEZyaWVuZGx5VVJMID0gKHVybCk9PntcbiAgICBjb25zdCB1cmxPYmogPSBuZXcgVVJMKFN0cmluZyh1cmwpLCBsb2NhdGlvbi5ocmVmKTtcbiAgICByZXR1cm4gdXJsT2JqLmhyZWYucmVwbGFjZShuZXcgUmVnRXhwKGBeJHtsb2NhdGlvbi5vcmlnaW59YCksIFwiXCIpO1xufTtcblxuZnVuY3Rpb24gdGltZW91dChtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PnNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcbn1cblxuY29uc3QgTUFYX1JFVFJZX1RJTUUgPSAyMDAwO1xuYXN5bmMgZnVuY3Rpb24gcmVzdWx0aW5nQ2xpZW50RXhpc3RzKHJlc3VsdGluZ0NsaWVudElkKSB7XG4gICAgaWYgKCFyZXN1bHRpbmdDbGllbnRJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBleGlzdGluZ1dpbmRvd3MgPSBhd2FpdCBzZWxmLmNsaWVudHMubWF0Y2hBbGwoe1xuICAgICAgICB0eXBlOiBcIndpbmRvd1wiXG4gICAgfSk7XG4gICAgY29uc3QgZXhpc3RpbmdXaW5kb3dJZHMgPSBuZXcgU2V0KGV4aXN0aW5nV2luZG93cy5tYXAoKHcpPT53LmlkKSk7XG4gICAgbGV0IHJlc3VsdGluZ1dpbmRvdyA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB3aGlsZShwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZSA8IE1BWF9SRVRSWV9USU1FKXtcbiAgICAgICAgZXhpc3RpbmdXaW5kb3dzID0gYXdhaXQgc2VsZi5jbGllbnRzLm1hdGNoQWxsKHtcbiAgICAgICAgICAgIHR5cGU6IFwid2luZG93XCJcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdGluZ1dpbmRvdyA9IGV4aXN0aW5nV2luZG93cy5maW5kKCh3KT0+e1xuICAgICAgICAgICAgaWYgKHJlc3VsdGluZ0NsaWVudElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHcuaWQgPT09IHJlc3VsdGluZ0NsaWVudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFleGlzdGluZ1dpbmRvd0lkcy5oYXMody5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0aW5nV2luZG93KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aW1lb3V0KDEwMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRpbmdXaW5kb3c7XG59XG5cbmNvbnN0IHdhaXRVbnRpbCA9IChldmVudCwgYXN5bmNGbik9PntcbiAgICBjb25zdCByZXR1cm5Qcm9taXNlID0gYXN5bmNGbigpO1xuICAgIGV2ZW50LndhaXRVbnRpbChyZXR1cm5Qcm9taXNlKTtcbiAgICByZXR1cm4gcmV0dXJuUHJvbWlzZTtcbn07XG5cbmV4cG9ydCB7IERlZmVycmVkLCBjYWNoZU1hdGNoSWdub3JlUGFyYW1zLCBjYW5Db25zdHJ1Y3RSZWFkYWJsZVN0cmVhbSwgZG9udFdhaXRGb3IsIGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzLCBnZXRGcmllbmRseVVSTCwgbG9nZ2VyLCByZXN1bHRpbmdDbGllbnRFeGlzdHMsIHRpbWVvdXQsIHdhaXRVbnRpbCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.js ***!
  \*********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheNames: function() { return /* binding */ cacheNames; },\n/* harmony export */   clientsClaim: function() { return /* binding */ clientsClaim; },\n/* harmony export */   copyResponse: function() { return /* binding */ copyResponse; },\n/* harmony export */   registerQuotaErrorCallback: function() { return /* binding */ registerQuotaErrorCallback; },\n/* harmony export */   setCacheNameDetails: function() { return /* binding */ setCacheNameDetails; }\n/* harmony export */ });\n/* harmony import */ var _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/quotaErrorCallbacks.js */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/chunks/quotaErrorCallbacks.js\");\n\n\nconst cacheNames = {\n    get googleAnalytics () {\n        return _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c.getGoogleAnalyticsName();\n    },\n    get precache () {\n        return _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrecacheName();\n    },\n    get prefix () {\n        return _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrefix();\n    },\n    get runtime () {\n        return _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c.getRuntimeName();\n    },\n    get suffix () {\n        return _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c.getSuffix();\n    }\n};\n\nconst clientsClaim = ()=>{\n    self.addEventListener(\"activate\", ()=>self.clients.claim());\n};\n\nconst copyResponse = async (response, modifier)=>{\n    let origin = null;\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.S(\"cross-origin-copy-response\", {\n            origin\n        });\n    }\n    const clonedResponse = response.clone();\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n    };\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    const body = (0,_chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.a)() ? clonedResponse.body : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n};\n\nconst registerQuotaErrorCallback = (callback)=>{\n    if (true) {\n        _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(callback, \"function\", {\n            moduleName: \"@serwist/core\",\n            funcName: \"register\",\n            paramName: \"callback\"\n        });\n    }\n    _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.q.add(callback);\n    if (true) {\n        _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Registered a callback to respond to quota errors.\", callback);\n    }\n};\n\nconst setCacheNameDetails = (details)=>{\n    if (true) {\n        for (const key of Object.keys(details)){\n            _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(details[key], \"string\", {\n                moduleName: \"@serwist/core\",\n                funcName: \"setCacheNameDetails\",\n                paramName: `details.${key}`\n            });\n        }\n        if (details.precache?.length === 0) {\n            throw new _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"precache\",\n                value: details.precache\n            });\n        }\n        if (details.runtime?.length === 0) {\n            throw new _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"runtime\",\n                value: details.runtime\n            });\n        }\n        if (details.googleAnalytics?.length === 0) {\n            throw new _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"googleAnalytics\",\n                value: details.googleAnalytics\n            });\n        }\n    }\n    _chunks_quotaErrorCallbacks_js__WEBPACK_IMPORTED_MODULE_0__.c.updateDetails(details);\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrY29yZUA5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L2NvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ007O0FBRWhNO0FBQ0E7QUFDQSxlQUFlLDZEQUFZO0FBQzNCLEtBQUs7QUFDTDtBQUNBLGVBQWUsNkRBQVk7QUFDM0IsS0FBSztBQUNMO0FBQ0EsZUFBZSw2REFBWTtBQUMzQixLQUFLO0FBQ0w7QUFDQSxlQUFlLDZEQUFZO0FBQzNCLEtBQUs7QUFDTDtBQUNBLGVBQWUsNkRBQVk7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQVk7QUFDOUI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpRUFBa0M7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0MsUUFBUSw2REFBa0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsSUFBSSw2REFBbUI7QUFDdkIsUUFBUSxJQUFxQztBQUM3QyxRQUFRLDZEQUFNO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxZQUFZLDZEQUFrQjtBQUM5QjtBQUNBO0FBQ0Esc0NBQXNDLElBQUk7QUFDMUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQVk7QUFDbEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLDZEQUFZO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQiw2REFBWTtBQUNsQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxJQUFJLDZEQUFZO0FBQ2hCOztBQUVtRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrY29yZUA5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L2NvcmUvZGlzdC9pbmRleC5qcz8zYzVlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY2FjaGVOYW1lcyQxLCBTIGFzIFNlcndpc3RFcnJvciwgYSBhcyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtLCBmIGFzIGZpbmFsQXNzZXJ0RXhwb3J0cywgcSBhcyBxdW90YUVycm9yQ2FsbGJhY2tzLCBsIGFzIGxvZ2dlciB9IGZyb20gJy4vY2h1bmtzL3F1b3RhRXJyb3JDYWxsYmFja3MuanMnO1xuXG5jb25zdCBjYWNoZU5hbWVzID0ge1xuICAgIGdldCBnb29nbGVBbmFseXRpY3MgKCkge1xuICAgICAgICByZXR1cm4gY2FjaGVOYW1lcyQxLmdldEdvb2dsZUFuYWx5dGljc05hbWUoKTtcbiAgICB9LFxuICAgIGdldCBwcmVjYWNoZSAoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZU5hbWVzJDEuZ2V0UHJlY2FjaGVOYW1lKCk7XG4gICAgfSxcbiAgICBnZXQgcHJlZml4ICgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZXMkMS5nZXRQcmVmaXgoKTtcbiAgICB9LFxuICAgIGdldCBydW50aW1lICgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZXMkMS5nZXRSdW50aW1lTmFtZSgpO1xuICAgIH0sXG4gICAgZ2V0IHN1ZmZpeCAoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZU5hbWVzJDEuZ2V0U3VmZml4KCk7XG4gICAgfVxufTtcblxuY29uc3QgY2xpZW50c0NsYWltID0gKCk9PntcbiAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCAoKT0+c2VsZi5jbGllbnRzLmNsYWltKCkpO1xufTtcblxuY29uc3QgY29weVJlc3BvbnNlID0gYXN5bmMgKHJlc3BvbnNlLCBtb2RpZmllcik9PntcbiAgICBsZXQgb3JpZ2luID0gbnVsbDtcbiAgICBpZiAocmVzcG9uc2UudXJsKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVVJMID0gbmV3IFVSTChyZXNwb25zZS51cmwpO1xuICAgICAgICBvcmlnaW4gPSByZXNwb25zZVVSTC5vcmlnaW47XG4gICAgfVxuICAgIGlmIChvcmlnaW4gIT09IHNlbGYubG9jYXRpb24ub3JpZ2luKSB7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJjcm9zcy1vcmlnaW4tY29weS1yZXNwb25zZVwiLCB7XG4gICAgICAgICAgICBvcmlnaW5cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICBjb25zdCByZXNwb25zZUluaXQgPSB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGNsb25lZFJlc3BvbnNlLmhlYWRlcnMpLFxuICAgICAgICBzdGF0dXM6IGNsb25lZFJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogY2xvbmVkUmVzcG9uc2Uuc3RhdHVzVGV4dFxuICAgIH07XG4gICAgY29uc3QgbW9kaWZpZWRSZXNwb25zZUluaXQgPSBtb2RpZmllciA/IG1vZGlmaWVyKHJlc3BvbnNlSW5pdCkgOiByZXNwb25zZUluaXQ7XG4gICAgY29uc3QgYm9keSA9IGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0oKSA/IGNsb25lZFJlc3BvbnNlLmJvZHkgOiBhd2FpdCBjbG9uZWRSZXNwb25zZS5ibG9iKCk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCBtb2RpZmllZFJlc3BvbnNlSW5pdCk7XG59O1xuXG5jb25zdCByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayA9IChjYWxsYmFjayk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoY2FsbGJhY2ssIFwiZnVuY3Rpb25cIiwge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9jb3JlXCIsXG4gICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclwiLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNhbGxiYWNrXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHF1b3RhRXJyb3JDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGxvZ2dlci5sb2coXCJSZWdpc3RlcmVkIGEgY2FsbGJhY2sgdG8gcmVzcG9uZCB0byBxdW90YSBlcnJvcnMuXCIsIGNhbGxiYWNrKTtcbiAgICB9XG59O1xuXG5jb25zdCBzZXRDYWNoZU5hbWVEZXRhaWxzID0gKGRldGFpbHMpPT57XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkZXRhaWxzKSl7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGRldGFpbHNba2V5XSwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvY29yZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInNldENhY2hlTmFtZURldGFpbHNcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IGBkZXRhaWxzLiR7a2V5fWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWxzLnByZWNhY2hlPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJpbnZhbGlkLWNhY2hlLW5hbWVcIiwge1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZUlkOiBcInByZWNhY2hlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRldGFpbHMucHJlY2FjaGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWxzLnJ1bnRpbWU/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImludmFsaWQtY2FjaGUtbmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGVOYW1lSWQ6IFwicnVudGltZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZXRhaWxzLnJ1bnRpbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZXRhaWxzLmdvb2dsZUFuYWx5dGljcz8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC1jYWNoZS1uYW1lXCIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWVJZDogXCJnb29nbGVBbmFseXRpY3NcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGV0YWlscy5nb29nbGVBbmFseXRpY3NcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlTmFtZXMkMS51cGRhdGVEZXRhaWxzKGRldGFpbHMpO1xufTtcblxuZXhwb3J0IHsgY2FjaGVOYW1lcywgY2xpZW50c0NsYWltLCBjb3B5UmVzcG9uc2UsIHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLCBzZXRDYWNoZU5hbWVEZXRhaWxzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+next@9.0.0-preview.21_next@14.2.1_typescript@5.4.5_webpack@5.91.0/node_modules/@serwist/next/dist/index.worker.js":
/*!*******************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+next@9.0.0-preview.21_next@14.2.1_typescript@5.4.5_webpack@5.91.0/node_modules/@serwist/next/dist/index.worker.js ***!
  \*******************************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PAGES_CACHE_NAME: function() { return /* binding */ PAGES_CACHE_NAME; },\n/* harmony export */   defaultCache: function() { return /* binding */ defaultCache; }\n/* harmony export */ });\n/* harmony import */ var _serwist_sw_plugins__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/sw/plugins */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.plugins.js\");\n/* harmony import */ var _serwist_sw_strategies__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @serwist/sw/strategies */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.strategies.js\");\n\n\n\nconst PAGES_CACHE_NAME = {\n    rscPrefetch: \"pages-rsc-prefetch\",\n    rsc: \"pages-rsc\",\n    html: \"pages\"\n};\n\nconst defaultCache =  true ? [] : 0;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3QrbmV4dEA5LjAuMC1wcmV2aWV3LjIxX25leHRAMTQuMi4xX3R5cGVzY3JpcHRANS40LjVfd2VicGFja0A1LjkxLjAvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L25leHQvZGlzdC9pbmRleC53b3JrZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0RTtBQUNZOztBQUV4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixLQUFxQyxRQUFRLENBbVBqRTs7QUFFeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZXJ3aXN0K25leHRAOS4wLjAtcHJldmlldy4yMV9uZXh0QDE0LjIuMV90eXBlc2NyaXB0QDUuNC41X3dlYnBhY2tANS45MS4wL25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9uZXh0L2Rpc3QvaW5kZXgud29ya2VyLmpzPzFiODUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXhwaXJhdGlvblBsdWdpbiwgUmFuZ2VSZXF1ZXN0c1BsdWdpbiB9IGZyb20gJ0BzZXJ3aXN0L3N3L3BsdWdpbnMnO1xuaW1wb3J0IHsgQ2FjaGVGaXJzdCwgU3RhbGVXaGlsZVJldmFsaWRhdGUsIE5ldHdvcmtGaXJzdCB9IGZyb20gJ0BzZXJ3aXN0L3N3L3N0cmF0ZWdpZXMnO1xuXG5jb25zdCBQQUdFU19DQUNIRV9OQU1FID0ge1xuICAgIHJzY1ByZWZldGNoOiBcInBhZ2VzLXJzYy1wcmVmZXRjaFwiLFxuICAgIHJzYzogXCJwYWdlcy1yc2NcIixcbiAgICBodG1sOiBcInBhZ2VzXCJcbn07XG5cbmNvbnN0IGRlZmF1bHRDYWNoZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFtdIDogW1xuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogL15odHRwczpcXC9cXC9mb250c1xcLig/OmdzdGF0aWMpXFwuY29tXFwvLiovaSxcbiAgICAgICAgaGFuZGxlcjogbmV3IENhY2hlRmlyc3Qoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcImdvb2dsZS1mb250cy13ZWJmb250c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogNCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogMzY1ICogMjQgKiA2MCAqIDYwLFxuICAgICAgICAgICAgICAgICAgICBtYXhBZ2VGcm9tOiBcImxhc3QtdXNlZFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogL15odHRwczpcXC9cXC9mb250c1xcLig/Omdvb2dsZWFwaXMpXFwuY29tXFwvLiovaSxcbiAgICAgICAgaGFuZGxlcjogbmV3IFN0YWxlV2hpbGVSZXZhbGlkYXRlKHtcbiAgICAgICAgICAgIGNhY2hlTmFtZTogXCJnb29nbGUtZm9udHMtc3R5bGVzaGVldHNcIixcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBuZXcgRXhwaXJhdGlvblBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgIG1heEVudHJpZXM6IDQsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDcgKiAyNCAqIDYwICogNjAsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZUZyb206IFwibGFzdC11c2VkXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIH0sXG4gICAge1xuICAgICAgICBtYXRjaGVyOiAvXFwuKD86ZW90fG90Znx0dGN8dHRmfHdvZmZ8d29mZjJ8Zm9udC5jc3MpJC9pLFxuICAgICAgICBoYW5kbGVyOiBuZXcgU3RhbGVXaGlsZVJldmFsaWRhdGUoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcInN0YXRpYy1mb250LWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogNCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogNyAqIDI0ICogNjAgKiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlRnJvbTogXCJsYXN0LXVzZWRcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6IC9cXC4oPzpqcGd8anBlZ3xnaWZ8cG5nfHN2Z3xpY298d2VicCkkL2ksXG4gICAgICAgIGhhbmRsZXI6IG5ldyBTdGFsZVdoaWxlUmV2YWxpZGF0ZSh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFwic3RhdGljLWltYWdlLWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogNjQsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDMwICogMjQgKiA2MCAqIDYwLFxuICAgICAgICAgICAgICAgICAgICBtYXhBZ2VGcm9tOiBcImxhc3QtdXNlZFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogL1xcL19uZXh0XFwvc3RhdGljLitcXC5qcyQvaSxcbiAgICAgICAgaGFuZGxlcjogbmV3IENhY2hlRmlyc3Qoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcIm5leHQtc3RhdGljLWpzLWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogNjQsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlRnJvbTogXCJsYXN0LXVzZWRcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6IC9cXC9fbmV4dFxcL2ltYWdlXFw/dXJsPS4rJC9pLFxuICAgICAgICBoYW5kbGVyOiBuZXcgU3RhbGVXaGlsZVJldmFsaWRhdGUoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcIm5leHQtaW1hZ2VcIixcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBuZXcgRXhwaXJhdGlvblBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgIG1heEVudHJpZXM6IDY0LFxuICAgICAgICAgICAgICAgICAgICBtYXhBZ2VTZWNvbmRzOiAyNCAqIDYwICogNjAsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZUZyb206IFwibGFzdC11c2VkXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgIH0sXG4gICAge1xuICAgICAgICBtYXRjaGVyOiAvXFwuKD86bXAzfHdhdnxvZ2cpJC9pLFxuICAgICAgICBoYW5kbGVyOiBuZXcgQ2FjaGVGaXJzdCh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFwic3RhdGljLWF1ZGlvLWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogMzIsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlRnJvbTogXCJsYXN0LXVzZWRcIlxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBSYW5nZVJlcXVlc3RzUGx1Z2luKClcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogL1xcLig/Om1wNHx3ZWJtKSQvaSxcbiAgICAgICAgaGFuZGxlcjogbmV3IENhY2hlRmlyc3Qoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcInN0YXRpYy12aWRlby1hc3NldHNcIixcbiAgICAgICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgICAgICBuZXcgRXhwaXJhdGlvblBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgIG1heEVudHJpZXM6IDMyLFxuICAgICAgICAgICAgICAgICAgICBtYXhBZ2VTZWNvbmRzOiAyNCAqIDYwICogNjAsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZUZyb206IFwibGFzdC11c2VkXCJcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBuZXcgUmFuZ2VSZXF1ZXN0c1BsdWdpbigpXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6IC9cXC4oPzpqcykkL2ksXG4gICAgICAgIGhhbmRsZXI6IG5ldyBTdGFsZVdoaWxlUmV2YWxpZGF0ZSh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFwic3RhdGljLWpzLWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogNDgsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlRnJvbTogXCJsYXN0LXVzZWRcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6IC9cXC4oPzpjc3N8bGVzcykkL2ksXG4gICAgICAgIGhhbmRsZXI6IG5ldyBTdGFsZVdoaWxlUmV2YWxpZGF0ZSh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFwic3RhdGljLXN0eWxlLWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogMzIsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlRnJvbTogXCJsYXN0LXVzZWRcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6IC9cXC9fbmV4dFxcL2RhdGFcXC8uK1xcLy4rXFwuanNvbiQvaSxcbiAgICAgICAgaGFuZGxlcjogbmV3IE5ldHdvcmtGaXJzdCh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFwibmV4dC1kYXRhXCIsXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBtYXhFbnRyaWVzOiAzMixcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgICAgICAgICAgICAgICBtYXhBZ2VGcm9tOiBcImxhc3QtdXNlZFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogL1xcLig/Ompzb258eG1sfGNzdikkL2ksXG4gICAgICAgIGhhbmRsZXI6IG5ldyBOZXR3b3JrRmlyc3Qoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcInN0YXRpYy1kYXRhLWFzc2V0c1wiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogMzIsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MCxcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlRnJvbTogXCJsYXN0LXVzZWRcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6ICh7IHNhbWVPcmlnaW4sIHVybDogeyBwYXRobmFtZSB9IH0pPT57XG4gICAgICAgICAgICBpZiAoIXNhbWVPcmlnaW4gfHwgcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9hcGkvYXV0aC9jYWxsYmFja1wiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXRobmFtZS5zdGFydHNXaXRoKFwiL2FwaS9cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoYW5kbGVyOiBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgICAgIGNhY2hlTmFtZTogXCJhcGlzXCIsXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBtYXhFbnRyaWVzOiAxNixcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogMjQgKiA2MCAqIDYwLFxuICAgICAgICAgICAgICAgICAgICBtYXhBZ2VGcm9tOiBcImxhc3QtdXNlZFwiXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBuZXR3b3JrVGltZW91dFNlY29uZHM6IDEwXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6ICh7IHJlcXVlc3QsIHVybDogeyBwYXRobmFtZSB9LCBzYW1lT3JpZ2luIH0pPT5yZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiUlNDXCIpID09PSBcIjFcIiAmJiByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiTmV4dC1Sb3V0ZXItUHJlZmV0Y2hcIikgPT09IFwiMVwiICYmIHNhbWVPcmlnaW4gJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvYXBpL1wiKSxcbiAgICAgICAgaGFuZGxlcjogbmV3IE5ldHdvcmtGaXJzdCh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFBBR0VTX0NBQ0hFX05BTUUucnNjUHJlZmV0Y2gsXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBtYXhFbnRyaWVzOiAzMixcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogMjQgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogKHsgcmVxdWVzdCwgdXJsOiB7IHBhdGhuYW1lIH0sIHNhbWVPcmlnaW4gfSk9PnJlcXVlc3QuaGVhZGVycy5nZXQoXCJSU0NcIikgPT09IFwiMVwiICYmIHNhbWVPcmlnaW4gJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvYXBpL1wiKSxcbiAgICAgICAgaGFuZGxlcjogbmV3IE5ldHdvcmtGaXJzdCh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFBBR0VTX0NBQ0hFX05BTUUucnNjLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogMzIsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDI0ICogNjAgKiA2MFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdXG4gICAgICAgIH0pXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG1hdGNoZXI6ICh7IHJlcXVlc3QsIHVybDogeyBwYXRobmFtZSB9LCBzYW1lT3JpZ2luIH0pPT5yZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiQ29udGVudC1UeXBlXCIpPy5pbmNsdWRlcyhcInRleHQvaHRtbFwiKSAmJiBzYW1lT3JpZ2luICYmICFwYXRobmFtZS5zdGFydHNXaXRoKFwiL2FwaS9cIiksXG4gICAgICAgIGhhbmRsZXI6IG5ldyBOZXR3b3JrRmlyc3Qoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBQQUdFU19DQUNIRV9OQU1FLmh0bWwsXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBtYXhFbnRyaWVzOiAzMixcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogMjQgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogKHsgdXJsOiB7IHBhdGhuYW1lIH0sIHNhbWVPcmlnaW4gfSk9PnNhbWVPcmlnaW4gJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIvYXBpL1wiKSxcbiAgICAgICAgaGFuZGxlcjogbmV3IE5ldHdvcmtGaXJzdCh7XG4gICAgICAgICAgICBjYWNoZU5hbWU6IFwib3RoZXJzXCIsXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgbmV3IEV4cGlyYXRpb25QbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBtYXhFbnRyaWVzOiAzMixcbiAgICAgICAgICAgICAgICAgICAgbWF4QWdlU2Vjb25kczogMjQgKiA2MCAqIDYwXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbWF0Y2hlcjogKHsgc2FtZU9yaWdpbiB9KT0+IXNhbWVPcmlnaW4sXG4gICAgICAgIGhhbmRsZXI6IG5ldyBOZXR3b3JrRmlyc3Qoe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBcImNyb3NzLW9yaWdpblwiLFxuICAgICAgICAgICAgcGx1Z2luczogW1xuICAgICAgICAgICAgICAgIG5ldyBFeHBpcmF0aW9uUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgbWF4RW50cmllczogMzIsXG4gICAgICAgICAgICAgICAgICAgIG1heEFnZVNlY29uZHM6IDYwICogNjBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG5ldHdvcmtUaW1lb3V0U2Vjb25kczogMTBcbiAgICAgICAgfSlcbiAgICB9XG5dO1xuXG5leHBvcnQgeyBQQUdFU19DQUNIRV9OQU1FLCBkZWZhdWx0Q2FjaGUgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+next@9.0.0-preview.21_next@14.2.1_typescript@5.4.5_webpack@5.91.0/node_modules/@serwist/next/dist/index.worker.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/NetworkOnly.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/NetworkOnly.js ***!
  \******************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: function() { return /* binding */ NetworkOnly; },\n/* harmony export */   a: function() { return /* binding */ NetworkFirst; },\n/* harmony export */   c: function() { return /* binding */ cacheOkAndOpaquePlugin; },\n/* harmony export */   m: function() { return /* binding */ messages; }\n/* harmony export */ });\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js\");\n\n\n\nconst cacheOkAndOpaquePlugin = {\n    cacheWillUpdate: async ({ response })=>{\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    }\n};\n\nconst messages = {\n    strategyStart: (strategyName, request)=>`Using ${strategyName} to respond to '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}'`,\n    printFinalResponse: (response)=>{\n        if (response) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(\"View the final response here.\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(response || \"[No response returned]\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n    }\n};\n\nclass NetworkFirst extends _Strategy_js__WEBPACK_IMPORTED_MODULE_1__.S {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (true) {\n            if (this._networkTimeoutSeconds) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(this._networkTimeoutSeconds, \"number\", {\n                    moduleName: \"@serwist/strategies\",\n                    className: this.constructor.name,\n                    funcName: \"constructor\",\n                    paramName: \"networkTimeoutSeconds\"\n                });\n            }\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"makeRequest\"\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({\n                request,\n                logs,\n                handler\n            });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async ()=>{\n            return await handler.waitUntil(Promise.race(promises)) || await networkPromise;\n        })());\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(log);\n            }\n            messages.printFinalResponse(response);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        if (!response) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n    _getTimeoutPromise({ request, logs, handler }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve)=>{\n            const onNetworkTimeout = async ()=>{\n                if (true) {\n                    logs.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId\n        };\n    }\n    async _getNetworkPromise({ timeoutId, request, logs, handler }) {\n        let error = undefined;\n        let response = undefined;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        } catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (true) {\n            if (response) {\n                logs.push(\"Got response from network.\");\n            } else {\n                logs.push(\"Unable to get a response from the network. Will respond \" + \"with a cached response.\");\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (true) {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n                } else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\n\nclass NetworkOnly extends _Strategy_js__WEBPACK_IMPORTED_MODULE_1__.S {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    async _handle(request, handler) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"_handle\",\n                paramName: \"request\"\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request)\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.timeout)(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`);\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(\"Got response from network.\");\n            } else {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(\"Unable to get a response from the network.\");\n            }\n            messages.printFinalResponse(response);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        if (!response) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9OZXR3b3JrT25seS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0Y7QUFDakQ7O0FBRTlDO0FBQ0EsOEJBQThCLFVBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELGNBQWMsaUJBQWlCLHNFQUFjLGNBQWM7QUFDaEg7QUFDQTtBQUNBLFlBQVksMERBQU07QUFDbEIsWUFBWSwwREFBTTtBQUNsQixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMkNBQVE7QUFDbkM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQSxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxZQUFZLElBQXFDO0FBQ2pELFlBQVksMERBQU07QUFDbEI7QUFDQSxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQTtBQUNBLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFxQztBQUN6RCxvRUFBb0UsNkJBQTZCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQSxpRUFBaUUsZUFBZTtBQUNoRixrQkFBa0I7QUFDbEIsMkRBQTJELGVBQWU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQiwyQ0FBUTtBQUNsQztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLCtEQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLDZCQUE2QjtBQUNyRztBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBLGdCQUFnQiwwREFBTTtBQUN0QixjQUFjO0FBQ2QsZ0JBQWdCLDBEQUFNO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQSxzQkFBc0IsZ0VBQVk7QUFDbEM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFMkYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BzZXJ3aXN0K3N3QDkuMC4wLXByZXZpZXcuMjFfdHlwZXNjcmlwdEA1LjQuNS9ub2RlX21vZHVsZXMvQHNlcndpc3Qvc3cvZGlzdC9jaHVua3MvTmV0d29ya09ubHkuanM/ZTZkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRGcmllbmRseVVSTCwgbG9nZ2VyLCBhc3NlcnQsIFNlcndpc3RFcnJvciwgdGltZW91dCB9IGZyb20gJ0BzZXJ3aXN0L2NvcmUvaW50ZXJuYWwnO1xuaW1wb3J0IHsgUyBhcyBTdHJhdGVneSB9IGZyb20gJy4vU3RyYXRlZ3kuanMnO1xuXG5jb25zdCBjYWNoZU9rQW5kT3BhcXVlUGx1Z2luID0ge1xuICAgIGNhY2hlV2lsbFVwZGF0ZTogYXN5bmMgKHsgcmVzcG9uc2UgfSk9PntcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmNvbnN0IG1lc3NhZ2VzID0ge1xuICAgIHN0cmF0ZWd5U3RhcnQ6IChzdHJhdGVneU5hbWUsIHJlcXVlc3QpPT5gVXNpbmcgJHtzdHJhdGVneU5hbWV9IHRvIHJlc3BvbmQgdG8gJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSdgLFxuICAgIHByaW50RmluYWxSZXNwb25zZTogKHJlc3BvbnNlKT0+e1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgdGhlIGZpbmFsIHJlc3BvbnNlIGhlcmUuXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXNwb25zZSB8fCBcIltObyByZXNwb25zZSByZXR1cm5lZF1cIik7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIE5ldHdvcmtGaXJzdCBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBfbmV0d29ya1RpbWVvdXRTZWNvbmRzO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMucGx1Z2lucy5zb21lKChwKT0+XCJjYWNoZVdpbGxVcGRhdGVcIiBpbiBwKSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnVuc2hpZnQoY2FjaGVPa0FuZE9wYXF1ZVBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy5uZXR3b3JrVGltZW91dFNlY29uZHMgfHwgMDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUodGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzLCBcIm51bWJlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3RyYXRlZ2llc1wiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm5ldHdvcmtUaW1lb3V0U2Vjb25kc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBbXTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3RyYXRlZ2llc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImhhbmRsZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJtYWtlUmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBsZXQgdGltZW91dElkO1xuICAgICAgICBpZiAodGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBwcm9taXNlIH0gPSB0aGlzLl9nZXRUaW1lb3V0UHJvbWlzZSh7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBsb2dzLFxuICAgICAgICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGltZW91dElkID0gaWQ7XG4gICAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlID0gdGhpcy5fZ2V0TmV0d29ya1Byb21pc2Uoe1xuICAgICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGxvZ3MsXG4gICAgICAgICAgICBoYW5kbGVyXG4gICAgICAgIH0pO1xuICAgICAgICBwcm9taXNlcy5wdXNoKG5ldHdvcmtQcm9taXNlKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLndhaXRVbnRpbCgoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBoYW5kbGVyLndhaXRVbnRpbChQcm9taXNlLnJhY2UocHJvbWlzZXMpKSB8fCBhd2FpdCBuZXR3b3JrUHJvbWlzZTtcbiAgICAgICAgfSkoKSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChtZXNzYWdlcy5zdHJhdGVneVN0YXJ0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgcmVxdWVzdCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsb2cgb2YgbG9ncyl7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhsb2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZXMucHJpbnRGaW5hbFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJuby1yZXNwb25zZVwiLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBfZ2V0VGltZW91dFByb21pc2UoeyByZXF1ZXN0LCBsb2dzLCBoYW5kbGVyIH0pIHtcbiAgICAgICAgbGV0IHRpbWVvdXRJZDtcbiAgICAgICAgY29uc3QgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSk9PntcbiAgICAgICAgICAgIGNvbnN0IG9uTmV0d29ya1RpbWVvdXQgPSBhc3luYyAoKT0+e1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBUaW1pbmcgb3V0IHRoZSBuZXR3b3JrIHJlc3BvbnNlIGF0ICR7dGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzfSBzZWNvbmRzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKGF3YWl0IGhhbmRsZXIuY2FjaGVNYXRjaChyZXF1ZXN0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChvbk5ldHdvcmtUaW1lb3V0LCB0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9taXNlOiB0aW1lb3V0UHJvbWlzZSxcbiAgICAgICAgICAgIGlkOiB0aW1lb3V0SWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgX2dldE5ldHdvcmtQcm9taXNlKHsgdGltZW91dElkLCByZXF1ZXN0LCBsb2dzLCBoYW5kbGVyIH0pIHtcbiAgICAgICAgbGV0IGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2hBbmRDYWNoZVB1dChyZXF1ZXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZmV0Y2hFcnJvcikge1xuICAgICAgICAgICAgaWYgKGZldGNoRXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9yID0gZmV0Y2hFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goXCJHb3QgcmVzcG9uc2UgZnJvbSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKFwiVW5hYmxlIHRvIGdldCBhIHJlc3BvbnNlIGZyb20gdGhlIG5ldHdvcmsuIFdpbGwgcmVzcG9uZCBcIiArIFwid2l0aCBhIGNhY2hlZCByZXNwb25zZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIHx8ICFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgRm91bmQgYSBjYWNoZWQgcmVzcG9uc2UgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBObyByZXNwb25zZSBmb3VuZCBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbn1cblxuY2xhc3MgTmV0d29ya09ubHkgZXh0ZW5kcyBTdHJhdGVneSB7XG4gICAgX25ldHdvcmtUaW1lb3V0U2Vjb25kcztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy5uZXR3b3JrVGltZW91dFNlY29uZHMgfHwgMDtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3N0cmF0ZWdpZXNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJfaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZldGNoKHJlcXVlc3QpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gdGltZW91dCh0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRpbWVvdXRQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpbWVkIG91dCB0aGUgbmV0d29yayByZXNwb25zZSBhZnRlciAke3RoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kc30gc2Vjb25kcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJHb3QgcmVzcG9uc2UgZnJvbSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IE5ldHdvcmtPbmx5IGFzIE4sIE5ldHdvcmtGaXJzdCBhcyBhLCBjYWNoZU9rQW5kT3BhcXVlUGx1Z2luIGFzIGMsIG1lc3NhZ2VzIGFzIG0gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/NetworkOnly.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/PrecacheFallbackPlugin.js":
/*!*****************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/PrecacheFallbackPlugin.js ***!
  \*****************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B: function() { return /* binding */ BackgroundSyncPlugin; },\n/* harmony export */   P: function() { return /* binding */ PrecacheFallbackPlugin; },\n/* harmony export */   Q: function() { return /* binding */ Queue; },\n/* harmony export */   S: function() { return /* binding */ StorableRequest; },\n/* harmony export */   a: function() { return /* binding */ QueueStore; },\n/* harmony export */   i: function() { return /* binding */ initialize; }\n/* harmony export */ });\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n/* harmony import */ var _singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./singletonRouter.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonRouter.js\");\n/* harmony import */ var _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NetworkOnly.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/NetworkOnly.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js\");\n/* harmony import */ var _singletonPrecacheController_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./singletonPrecacheController.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonPrecacheController.js\");\n\n\n\n\n\n\nconst DB_VERSION = 3;\nconst DB_NAME = \"serwist-background-sync\";\nconst REQUEST_OBJECT_STORE_NAME = \"requests\";\nconst QUEUE_NAME_INDEX = \"queueName\";\nclass QueueDb {\n    _db = null;\n    async addEntry(entry) {\n        const db = await this.getDb();\n        const tx = db.transaction(REQUEST_OBJECT_STORE_NAME, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.add(entry);\n        await tx.done;\n    }\n    async getFirstEntryId() {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.openCursor();\n        return cursor?.value.id;\n    }\n    async getAllEntriesByQueueName(queueName) {\n        const db = await this.getDb();\n        const results = await db.getAllFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n        return results ? results : new Array();\n    }\n    async getEntryCountByQueueName(queueName) {\n        const db = await this.getDb();\n        return db.countFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n    }\n    async deleteEntry(id) {\n        const db = await this.getDb();\n        await db.delete(REQUEST_OBJECT_STORE_NAME, id);\n    }\n    async getFirstEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"next\");\n    }\n    async getLastEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"prev\");\n    }\n    async getEndEntryFromIndex(query, direction) {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.index(QUEUE_NAME_INDEX).openCursor(query, direction);\n        return cursor?.value;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DB_NAME, DB_VERSION, {\n                upgrade: this._upgradeDb\n            });\n        }\n        return this._db;\n    }\n    _upgradeDb(db, oldVersion) {\n        if (oldVersion > 0 && oldVersion < DB_VERSION) {\n            if (db.objectStoreNames.contains(REQUEST_OBJECT_STORE_NAME)) {\n                db.deleteObjectStore(REQUEST_OBJECT_STORE_NAME);\n            }\n        }\n        const objStore = db.createObjectStore(REQUEST_OBJECT_STORE_NAME, {\n            autoIncrement: true,\n            keyPath: \"id\"\n        });\n        objStore.createIndex(QUEUE_NAME_INDEX, QUEUE_NAME_INDEX, {\n            unique: false\n        });\n    }\n}\n\nclass QueueStore {\n    _queueName;\n    _queueDb;\n    constructor(queueName){\n        this._queueName = queueName;\n        this._queueDb = new QueueDb();\n    }\n    async pushEntry(entry) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(entry, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(entry.requestData, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        delete entry.id;\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async unshiftEntry(entry) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(entry, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(entry.requestData, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        const firstId = await this._queueDb.getFirstEntryId();\n        if (firstId) {\n            entry.id = firstId - 1;\n        } else {\n            delete entry.id;\n        }\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async popEntry() {\n        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));\n    }\n    async shiftEntry() {\n        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));\n    }\n    async getAll() {\n        return await this._queueDb.getAllEntriesByQueueName(this._queueName);\n    }\n    async size() {\n        return await this._queueDb.getEntryCountByQueueName(this._queueName);\n    }\n    async deleteEntry(id) {\n        await this._queueDb.deleteEntry(id);\n    }\n    async _removeEntry(entry) {\n        if (entry) {\n            await this.deleteEntry(entry.id);\n        }\n        return entry;\n    }\n}\n\nconst serializableProperties = [\n    \"method\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"mode\",\n    \"credentials\",\n    \"cache\",\n    \"redirect\",\n    \"integrity\",\n    \"keepalive\"\n];\nclass StorableRequest {\n    _requestData;\n    static async fromRequest(request) {\n        const requestData = {\n            url: request.url,\n            headers: {}\n        };\n        if (request.method !== \"GET\") {\n            requestData.body = await request.clone().arrayBuffer();\n        }\n        request.headers.forEach((value, key)=>{\n            requestData.headers[key] = value;\n        });\n        for (const prop of serializableProperties){\n            if (request[prop] !== undefined) {\n                requestData[prop] = request[prop];\n            }\n        }\n        return new StorableRequest(requestData);\n    }\n    constructor(requestData){\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(requestData, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(requestData.url, \"string\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData.url\"\n            });\n        }\n        if (requestData.mode === \"navigate\") {\n            requestData.mode = \"same-origin\";\n        }\n        this._requestData = requestData;\n    }\n    toObject() {\n        const requestData = Object.assign({}, this._requestData);\n        requestData.headers = Object.assign({}, this._requestData.headers);\n        if (requestData.body) {\n            requestData.body = requestData.body.slice(0);\n        }\n        return requestData;\n    }\n    toRequest() {\n        return new Request(this._requestData.url, this._requestData);\n    }\n    clone() {\n        return new StorableRequest(this.toObject());\n    }\n}\n\nconst TAG_PREFIX = \"serwist-background-sync\";\nconst MAX_RETENTION_TIME$1 = 60 * 24 * 7;\nconst queueNames = new Set();\nconst convertEntry = (queueStoreEntry)=>{\n    const queueEntry = {\n        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n        timestamp: queueStoreEntry.timestamp\n    };\n    if (queueStoreEntry.metadata) {\n        queueEntry.metadata = queueStoreEntry.metadata;\n    }\n    return queueEntry;\n};\nclass Queue {\n    _name;\n    _onSync;\n    _maxRetentionTime;\n    _queueStore;\n    _forceSyncFallback;\n    _syncInProgress = false;\n    _requestsAddedDuringSync = false;\n    constructor(name, { forceSyncFallback, onSync, maxRetentionTime } = {}){\n        if (queueNames.has(name)) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"duplicate-queue-name\", {\n                name\n            });\n        }\n        queueNames.add(name);\n        this._name = name;\n        this._onSync = onSync || this.replayRequests;\n        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME$1;\n        this._forceSyncFallback = Boolean(forceSyncFallback);\n        this._queueStore = new QueueStore(this._name);\n        this._addSyncListener();\n    }\n    get name() {\n        return this._name;\n    }\n    async pushRequest(entry) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(entry, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(entry.request, Request, {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"push\");\n    }\n    async unshiftRequest(entry) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(entry, \"object\", {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(entry.request, Request, {\n                moduleName: \"@serwist/sw/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"unshift\");\n    }\n    async popRequest() {\n        return this._removeRequest(\"pop\");\n    }\n    async shiftRequest() {\n        return this._removeRequest(\"shift\");\n    }\n    async getAll() {\n        const allEntries = await this._queueStore.getAll();\n        const now = Date.now();\n        const unexpiredEntries = [];\n        for (const entry of allEntries){\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                await this._queueStore.deleteEntry(entry.id);\n            } else {\n                unexpiredEntries.push(convertEntry(entry));\n            }\n        }\n        return unexpiredEntries;\n    }\n    async size() {\n        return await this._queueStore.size();\n    }\n    async _addRequest({ request, metadata, timestamp = Date.now() }, operation) {\n        const storableRequest = await StorableRequest.fromRequest(request.clone());\n        const entry = {\n            requestData: storableRequest.toObject(),\n            timestamp\n        };\n        if (metadata) {\n            entry.metadata = metadata;\n        }\n        switch(operation){\n            case \"push\":\n                await this._queueStore.pushEntry(entry);\n                break;\n            case \"unshift\":\n                await this._queueStore.unshiftEntry(entry);\n                break;\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n        }\n        if (this._syncInProgress) {\n            this._requestsAddedDuringSync = true;\n        } else {\n            await this.registerSync();\n        }\n    }\n    async _removeRequest(operation) {\n        const now = Date.now();\n        let entry;\n        switch(operation){\n            case \"pop\":\n                entry = await this._queueStore.popEntry();\n                break;\n            case \"shift\":\n                entry = await this._queueStore.shiftEntry();\n                break;\n        }\n        if (entry) {\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                return this._removeRequest(operation);\n            }\n            return convertEntry(entry);\n        }\n        return undefined;\n    }\n    async replayRequests() {\n        let entry = undefined;\n        while(entry = await this.shiftRequest()){\n            try {\n                await fetch(entry.request.clone());\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(entry.request.url)}' ` + `has been replayed in queue '${this._name}'`);\n                }\n            } catch (error) {\n                await this.unshiftRequest(entry);\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(entry.request.url)}' ` + `failed to replay, putting it back in queue '${this._name}'`);\n                }\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"queue-replay-failed\", {\n                    name: this._name\n                });\n            }\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`);\n        }\n    }\n    async registerSync() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            try {\n                await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n            } catch (err) {\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`Unable to register sync event for '${this._name}'.`, err);\n                }\n            }\n        }\n    }\n    _addSyncListener() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            self.addEventListener(\"sync\", (event)=>{\n                if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n                    if (true) {\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Background sync for tag '${event.tag}' has been received`);\n                    }\n                    const syncComplete = async ()=>{\n                        this._syncInProgress = true;\n                        let syncError = undefined;\n                        try {\n                            await this._onSync({\n                                queue: this\n                            });\n                        } catch (error) {\n                            if (error instanceof Error) {\n                                syncError = error;\n                                throw syncError;\n                            }\n                        } finally{\n                            if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                                await this.registerSync();\n                            }\n                            this._syncInProgress = false;\n                            this._requestsAddedDuringSync = false;\n                        }\n                    };\n                    event.waitUntil(syncComplete());\n                }\n            });\n        } else {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(\"Background sync replaying without background sync event\");\n            }\n            void this._onSync({\n                queue: this\n            });\n        }\n    }\n    static get _queueNames() {\n        return queueNames;\n    }\n}\n\nclass BackgroundSyncPlugin {\n    _queue;\n    constructor(name, options){\n        this._queue = new Queue(name, options);\n    }\n    async fetchDidFail({ request }) {\n        await this._queue.pushRequest({\n            request\n        });\n    }\n}\n\nconst QUEUE_NAME = \"serwist-google-analytics\";\nconst MAX_RETENTION_TIME = 60 * 48;\nconst GOOGLE_ANALYTICS_HOST = \"www.google-analytics.com\";\nconst GTM_HOST = \"www.googletagmanager.com\";\nconst ANALYTICS_JS_PATH = \"/analytics.js\";\nconst GTAG_JS_PATH = \"/gtag/js\";\nconst GTM_JS_PATH = \"/gtm.js\";\nconst COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\nconst createOnSyncCallback = (config)=>{\n    return async ({ queue })=>{\n        let entry = undefined;\n        while(entry = await queue.shiftRequest()){\n            const { request, timestamp } = entry;\n            const url = new URL(request.url);\n            try {\n                const params = request.method === \"POST\" ? new URLSearchParams(await request.clone().text()) : url.searchParams;\n                const originalHitTime = timestamp - (Number(params.get(\"qt\")) || 0);\n                const queueTime = Date.now() - originalHitTime;\n                params.set(\"qt\", String(queueTime));\n                if (config.parameterOverrides) {\n                    for (const param of Object.keys(config.parameterOverrides)){\n                        const value = config.parameterOverrides[param];\n                        params.set(param, value);\n                    }\n                }\n                if (typeof config.hitFilter === \"function\") {\n                    config.hitFilter.call(null, params);\n                }\n                await fetch(new Request(url.origin + url.pathname, {\n                    body: params.toString(),\n                    method: \"POST\",\n                    mode: \"cors\",\n                    credentials: \"omit\",\n                    headers: {\n                        \"Content-Type\": \"text/plain\"\n                    }\n                }));\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url.href)}' has been replayed`);\n                }\n            } catch (err) {\n                await queue.unshiftRequest(entry);\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url.href)}' failed to replay, putting it back in the queue.`);\n                }\n                throw err;\n            }\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(\"All Google Analytics request successfully replayed; \" + \"the queue is now empty!\");\n        }\n    };\n};\nconst createCollectRoutes = (bgSyncPlugin)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.N({\n        plugins: [\n            bgSyncPlugin\n        ]\n    });\n    return [\n        new _singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__.R(match, handler, \"GET\"),\n        new _singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__.R(match, handler, \"POST\")\n    ];\n};\nconst createAnalyticsJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.a({\n        cacheName\n    });\n    return new _singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__.R(match, handler, \"GET\");\n};\nconst createGtagJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.a({\n        cacheName\n    });\n    return new _singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__.R(match, handler, \"GET\");\n};\nconst createGtmJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.a({\n        cacheName\n    });\n    return new _singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__.R(match, handler, \"GET\");\n};\nconst initialize = ({ cacheName, router = (0,_singletonRouter_js__WEBPACK_IMPORTED_MODULE_1__.g)(), ...options } = {})=>{\n    const resolvedCacheName = _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.privateCacheNames.getGoogleAnalyticsName(cacheName);\n    const bgSyncPlugin = new BackgroundSyncPlugin(QUEUE_NAME, {\n        maxRetentionTime: MAX_RETENTION_TIME,\n        onSync: createOnSyncCallback(options)\n    });\n    const routes = [\n        createGtmJsRoute(resolvedCacheName),\n        createAnalyticsJsRoute(resolvedCacheName),\n        createGtagJsRoute(resolvedCacheName),\n        ...createCollectRoutes(bgSyncPlugin)\n    ];\n    for (const route of routes){\n        router.registerRoute(route);\n    }\n};\n\nclass PrecacheFallbackPlugin {\n    _fallbackUrls;\n    _precacheController;\n    constructor({ fallbackUrls, precacheController }){\n        this._fallbackUrls = fallbackUrls;\n        this._precacheController = precacheController || (0,_singletonPrecacheController_js__WEBPACK_IMPORTED_MODULE_4__.g)();\n    }\n    async handlerDidError(param) {\n        for (const fallback of this._fallbackUrls){\n            if (typeof fallback === \"string\") {\n                const fallbackResponse = await this._precacheController.matchPrecache(fallback);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            } else if (fallback.matcher(param)) {\n                const fallbackResponse = await this._precacheController.matchPrecache(fallback.url);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9QcmVjYWNoZUZhbGxiYWNrUGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXlHO0FBQzlCO0FBQ0o7QUFDMUM7QUFDMEQ7O0FBRXZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJDQUFNO0FBQ25DO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNW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RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHdCQUF3Qiw4Q0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLGtEQUFLO0FBQ2pCLFlBQVksa0RBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUIsd0JBQXdCLDhDQUFZO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLGVBQWUsa0RBQUs7QUFDcEI7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLHdCQUF3Qiw4Q0FBWTtBQUNwQztBQUNBLEtBQUs7QUFDTCxlQUFlLGtEQUFLO0FBQ3BCO0FBQ0E7QUFDQSxxQkFBcUIsS0FBSztBQUMxQix3QkFBd0IsOENBQVk7QUFDcEM7QUFDQSxLQUFLO0FBQ0wsZUFBZSxrREFBSztBQUNwQjtBQUNBLHNCQUFzQixvQkFBb0Isc0RBQWtCLGlCQUFpQixJQUFJO0FBQ2pGLDhCQUE4QixxRUFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQ7QUFDQSx5REFBeUQsa0VBQThCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9QcmVjYWNoZUZhbGxiYWNrUGx1Z2luLmpzPzUzNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBTZXJ3aXN0RXJyb3IsIGxvZ2dlciwgZ2V0RnJpZW5kbHlVUkwsIHByaXZhdGVDYWNoZU5hbWVzIH0gZnJvbSAnQHNlcndpc3QvY29yZS9pbnRlcm5hbCc7XG5pbXBvcnQgeyBnIGFzIGdldFNpbmdsZXRvblJvdXRlciwgUiBhcyBSb3V0ZSB9IGZyb20gJy4vc2luZ2xldG9uUm91dGVyLmpzJztcbmltcG9ydCB7IE4gYXMgTmV0d29ya09ubHksIGEgYXMgTmV0d29ya0ZpcnN0IH0gZnJvbSAnLi9OZXR3b3JrT25seS5qcyc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuaW1wb3J0IHsgZyBhcyBnZXRTaW5nbGV0b25QcmVjYWNoZUNvbnRyb2xsZXIgfSBmcm9tICcuL3NpbmdsZXRvblByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5cbmNvbnN0IERCX1ZFUlNJT04gPSAzO1xuY29uc3QgREJfTkFNRSA9IFwic2Vyd2lzdC1iYWNrZ3JvdW5kLXN5bmNcIjtcbmNvbnN0IFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUgPSBcInJlcXVlc3RzXCI7XG5jb25zdCBRVUVVRV9OQU1FX0lOREVYID0gXCJxdWV1ZU5hbWVcIjtcbmNsYXNzIFF1ZXVlRGIge1xuICAgIF9kYiA9IG51bGw7XG4gICAgYXN5bmMgYWRkRW50cnkoZW50cnkpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSwgXCJyZWFkd3JpdGVcIiwge1xuICAgICAgICAgICAgZHVyYWJpbGl0eTogXCJyZWxheGVkXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHR4LnN0b3JlLmFkZChlbnRyeSk7XG4gICAgICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgfVxuICAgIGFzeW5jIGdldEZpcnN0RW50cnlJZCgpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IGF3YWl0IGRiLnRyYW5zYWN0aW9uKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUpLnN0b3JlLm9wZW5DdXJzb3IoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcj8udmFsdWUuaWQ7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbEVudHJpZXNCeVF1ZXVlTmFtZShxdWV1ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBkYi5nZXRBbGxGcm9tSW5kZXgoUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSwgUVVFVUVfTkFNRV9JTkRFWCwgSURCS2V5UmFuZ2Uub25seShxdWV1ZU5hbWUpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHMgPyByZXN1bHRzIDogbmV3IEFycmF5KCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEVudHJ5Q291bnRCeVF1ZXVlTmFtZShxdWV1ZU5hbWUpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIHJldHVybiBkYi5jb3VudEZyb21JbmRleChSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FLCBRVUVVRV9OQU1FX0lOREVYLCBJREJLZXlSYW5nZS5vbmx5KHF1ZXVlTmFtZSkpO1xuICAgIH1cbiAgICBhc3luYyBkZWxldGVFbnRyeShpZCkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0RGIoKTtcbiAgICAgICAgYXdhaXQgZGIuZGVsZXRlKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUsIGlkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0Rmlyc3RFbnRyeUJ5UXVldWVOYW1lKHF1ZXVlTmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRFbmRFbnRyeUZyb21JbmRleChJREJLZXlSYW5nZS5vbmx5KHF1ZXVlTmFtZSksIFwibmV4dFwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0TGFzdEVudHJ5QnlRdWV1ZU5hbWUocXVldWVOYW1lKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdldEVuZEVudHJ5RnJvbUluZGV4KElEQktleVJhbmdlLm9ubHkocXVldWVOYW1lKSwgXCJwcmV2XCIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRFbmRFbnRyeUZyb21JbmRleChxdWVyeSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICBjb25zdCBjdXJzb3IgPSBhd2FpdCBkYi50cmFuc2FjdGlvbihSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FKS5zdG9yZS5pbmRleChRVUVVRV9OQU1FX0lOREVYKS5vcGVuQ3Vyc29yKHF1ZXJ5LCBkaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gY3Vyc29yPy52YWx1ZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RiID0gYXdhaXQgb3BlbkRCKERCX05BTUUsIERCX1ZFUlNJT04sIHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlOiB0aGlzLl91cGdyYWRlRGJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYjtcbiAgICB9XG4gICAgX3VwZ3JhZGVEYihkYiwgb2xkVmVyc2lvbikge1xuICAgICAgICBpZiAob2xkVmVyc2lvbiA+IDAgJiYgb2xkVmVyc2lvbiA8IERCX1ZFUlNJT04pIHtcbiAgICAgICAgICAgIGlmIChkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUpKSB7XG4gICAgICAgICAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FLCB7XG4gICAgICAgICAgICBhdXRvSW5jcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAga2V5UGF0aDogXCJpZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBvYmpTdG9yZS5jcmVhdGVJbmRleChRVUVVRV9OQU1FX0lOREVYLCBRVUVVRV9OQU1FX0lOREVYLCB7XG4gICAgICAgICAgICB1bmlxdWU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUXVldWVTdG9yZSB7XG4gICAgX3F1ZXVlTmFtZTtcbiAgICBfcXVldWVEYjtcbiAgICBjb25zdHJ1Y3RvcihxdWV1ZU5hbWUpe1xuICAgICAgICB0aGlzLl9xdWV1ZU5hbWUgPSBxdWV1ZU5hbWU7XG4gICAgICAgIHRoaXMuX3F1ZXVlRGIgPSBuZXcgUXVldWVEYigpO1xuICAgIH1cbiAgICBhc3luYyBwdXNoRW50cnkoZW50cnkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShlbnRyeSwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3cvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJwdXNoRW50cnlcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGVudHJ5LnJlcXVlc3REYXRhLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9zdy9wbHVnaW5zXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVTdG9yZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInB1c2hFbnRyeVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeS5yZXF1ZXN0RGF0YVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZW50cnkuaWQ7XG4gICAgICAgIGVudHJ5LnF1ZXVlTmFtZSA9IHRoaXMuX3F1ZXVlTmFtZTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcXVldWVEYi5hZGRFbnRyeShlbnRyeSk7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hpZnRFbnRyeShlbnRyeSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGVudHJ5LCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9zdy9wbHVnaW5zXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVTdG9yZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInVuc2hpZnRFbnRyeVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoZW50cnkucmVxdWVzdERhdGEsIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3N3L3BsdWdpbnNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVN0b3JlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwidW5zaGlmdEVudHJ5XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5LnJlcXVlc3REYXRhXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0SWQgPSBhd2FpdCB0aGlzLl9xdWV1ZURiLmdldEZpcnN0RW50cnlJZCgpO1xuICAgICAgICBpZiAoZmlyc3RJZCkge1xuICAgICAgICAgICAgZW50cnkuaWQgPSBmaXJzdElkIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5xdWV1ZU5hbWUgPSB0aGlzLl9xdWV1ZU5hbWU7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlRGIuYWRkRW50cnkoZW50cnkpO1xuICAgIH1cbiAgICBhc3luYyBwb3BFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUVudHJ5KGF3YWl0IHRoaXMuX3F1ZXVlRGIuZ2V0TGFzdEVudHJ5QnlRdWV1ZU5hbWUodGhpcy5fcXVldWVOYW1lKSk7XG4gICAgfVxuICAgIGFzeW5jIHNoaWZ0RW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVFbnRyeShhd2FpdCB0aGlzLl9xdWV1ZURiLmdldEZpcnN0RW50cnlCeVF1ZXVlTmFtZSh0aGlzLl9xdWV1ZU5hbWUpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWxsKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcXVldWVEYi5nZXRBbGxFbnRyaWVzQnlRdWV1ZU5hbWUodGhpcy5fcXVldWVOYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3F1ZXVlRGIuZ2V0RW50cnlDb3VudEJ5UXVldWVOYW1lKHRoaXMuX3F1ZXVlTmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUVudHJ5KGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlRGIuZGVsZXRlRW50cnkoaWQpO1xuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlRW50cnkoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZUVudHJ5KGVudHJ5LmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxufVxuXG5jb25zdCBzZXJpYWxpemFibGVQcm9wZXJ0aWVzID0gW1xuICAgIFwibWV0aG9kXCIsXG4gICAgXCJyZWZlcnJlclwiLFxuICAgIFwicmVmZXJyZXJQb2xpY3lcIixcbiAgICBcIm1vZGVcIixcbiAgICBcImNyZWRlbnRpYWxzXCIsXG4gICAgXCJjYWNoZVwiLFxuICAgIFwicmVkaXJlY3RcIixcbiAgICBcImludGVncml0eVwiLFxuICAgIFwia2VlcGFsaXZlXCJcbl07XG5jbGFzcyBTdG9yYWJsZVJlcXVlc3Qge1xuICAgIF9yZXF1ZXN0RGF0YTtcbiAgICBzdGF0aWMgYXN5bmMgZnJvbVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmJvZHkgPSBhd2FpdCByZXF1ZXN0LmNsb25lKCkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNlcmlhbGl6YWJsZVByb3BlcnRpZXMpe1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhW3Byb3BdID0gcmVxdWVzdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0b3JhYmxlUmVxdWVzdChyZXF1ZXN0RGF0YSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3REYXRhKXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShyZXF1ZXN0RGF0YSwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3cvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTdG9yYWJsZVJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0RGF0YVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocmVxdWVzdERhdGEudXJsLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9zdy9wbHVnaW5zXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlN0b3JhYmxlUmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3REYXRhLnVybFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdERhdGEubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiKSB7XG4gICAgICAgICAgICByZXF1ZXN0RGF0YS5tb2RlID0gXCJzYW1lLW9yaWdpblwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlcXVlc3REYXRhID0gcmVxdWVzdERhdGE7XG4gICAgfVxuICAgIHRvT2JqZWN0KCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JlcXVlc3REYXRhKTtcbiAgICAgICAgcmVxdWVzdERhdGEuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3JlcXVlc3REYXRhLmhlYWRlcnMpO1xuICAgICAgICBpZiAocmVxdWVzdERhdGEuYm9keSkge1xuICAgICAgICAgICAgcmVxdWVzdERhdGEuYm9keSA9IHJlcXVlc3REYXRhLmJvZHkuc2xpY2UoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3REYXRhO1xuICAgIH1cbiAgICB0b1JlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLl9yZXF1ZXN0RGF0YS51cmwsIHRoaXMuX3JlcXVlc3REYXRhKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RvcmFibGVSZXF1ZXN0KHRoaXMudG9PYmplY3QoKSk7XG4gICAgfVxufVxuXG5jb25zdCBUQUdfUFJFRklYID0gXCJzZXJ3aXN0LWJhY2tncm91bmQtc3luY1wiO1xuY29uc3QgTUFYX1JFVEVOVElPTl9USU1FJDEgPSA2MCAqIDI0ICogNztcbmNvbnN0IHF1ZXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5jb25zdCBjb252ZXJ0RW50cnkgPSAocXVldWVTdG9yZUVudHJ5KT0+e1xuICAgIGNvbnN0IHF1ZXVlRW50cnkgPSB7XG4gICAgICAgIHJlcXVlc3Q6IG5ldyBTdG9yYWJsZVJlcXVlc3QocXVldWVTdG9yZUVudHJ5LnJlcXVlc3REYXRhKS50b1JlcXVlc3QoKSxcbiAgICAgICAgdGltZXN0YW1wOiBxdWV1ZVN0b3JlRW50cnkudGltZXN0YW1wXG4gICAgfTtcbiAgICBpZiAocXVldWVTdG9yZUVudHJ5Lm1ldGFkYXRhKSB7XG4gICAgICAgIHF1ZXVlRW50cnkubWV0YWRhdGEgPSBxdWV1ZVN0b3JlRW50cnkubWV0YWRhdGE7XG4gICAgfVxuICAgIHJldHVybiBxdWV1ZUVudHJ5O1xufTtcbmNsYXNzIFF1ZXVlIHtcbiAgICBfbmFtZTtcbiAgICBfb25TeW5jO1xuICAgIF9tYXhSZXRlbnRpb25UaW1lO1xuICAgIF9xdWV1ZVN0b3JlO1xuICAgIF9mb3JjZVN5bmNGYWxsYmFjaztcbiAgICBfc3luY0luUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICBfcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgPSBmYWxzZTtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB7IGZvcmNlU3luY0ZhbGxiYWNrLCBvblN5bmMsIG1heFJldGVudGlvblRpbWUgfSA9IHt9KXtcbiAgICAgICAgaWYgKHF1ZXVlTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiZHVwbGljYXRlLXF1ZXVlLW5hbWVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlTmFtZXMuYWRkKG5hbWUpO1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fb25TeW5jID0gb25TeW5jIHx8IHRoaXMucmVwbGF5UmVxdWVzdHM7XG4gICAgICAgIHRoaXMuX21heFJldGVudGlvblRpbWUgPSBtYXhSZXRlbnRpb25UaW1lIHx8IE1BWF9SRVRFTlRJT05fVElNRSQxO1xuICAgICAgICB0aGlzLl9mb3JjZVN5bmNGYWxsYmFjayA9IEJvb2xlYW4oZm9yY2VTeW5jRmFsbGJhY2spO1xuICAgICAgICB0aGlzLl9xdWV1ZVN0b3JlID0gbmV3IFF1ZXVlU3RvcmUodGhpcy5fbmFtZSk7XG4gICAgICAgIHRoaXMuX2FkZFN5bmNMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIGFzeW5jIHB1c2hSZXF1ZXN0KGVudHJ5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoZW50cnksIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3N3L3BsdWdpbnNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInB1c2hSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UoZW50cnkucmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3cvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwicHVzaFJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnkucmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9hZGRSZXF1ZXN0KGVudHJ5LCBcInB1c2hcIik7XG4gICAgfVxuICAgIGFzeW5jIHVuc2hpZnRSZXF1ZXN0KGVudHJ5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoZW50cnksIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3N3L3BsdWdpbnNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInVuc2hpZnRSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UoZW50cnkucmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3cvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwidW5zaGlmdFJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnkucmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9hZGRSZXF1ZXN0KGVudHJ5LCBcInVuc2hpZnRcIik7XG4gICAgfVxuICAgIGFzeW5jIHBvcFJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVSZXF1ZXN0KFwicG9wXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaGlmdFJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVSZXF1ZXN0KFwic2hpZnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbCgpIHtcbiAgICAgICAgY29uc3QgYWxsRW50cmllcyA9IGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUuZ2V0QWxsKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHVuZXhwaXJlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBhbGxFbnRyaWVzKXtcbiAgICAgICAgICAgIGNvbnN0IG1heFJldGVudGlvblRpbWVJbk1zID0gdGhpcy5fbWF4UmV0ZW50aW9uVGltZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgIGlmIChub3cgLSBlbnRyeS50aW1lc3RhbXAgPiBtYXhSZXRlbnRpb25UaW1lSW5Ncykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUuZGVsZXRlRW50cnkoZW50cnkuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmV4cGlyZWRFbnRyaWVzLnB1c2goY29udmVydEVudHJ5KGVudHJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZXhwaXJlZEVudHJpZXM7XG4gICAgfVxuICAgIGFzeW5jIHNpemUoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLnNpemUoKTtcbiAgICB9XG4gICAgYXN5bmMgX2FkZFJlcXVlc3QoeyByZXF1ZXN0LCBtZXRhZGF0YSwgdGltZXN0YW1wID0gRGF0ZS5ub3coKSB9LCBvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc3RvcmFibGVSZXF1ZXN0ID0gYXdhaXQgU3RvcmFibGVSZXF1ZXN0LmZyb21SZXF1ZXN0KHJlcXVlc3QuY2xvbmUoKSk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgcmVxdWVzdERhdGE6IHN0b3JhYmxlUmVxdWVzdC50b09iamVjdCgpLFxuICAgICAgICAgICAgdGltZXN0YW1wXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZW50cnkubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gob3BlcmF0aW9uKXtcbiAgICAgICAgICAgIGNhc2UgXCJwdXNoXCI6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcXVldWVTdG9yZS5wdXNoRW50cnkoZW50cnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVuc2hpZnRcIjpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLnVuc2hpZnRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScgaGFzIGAgKyBgYmVlbiBhZGRlZCB0byBiYWNrZ3JvdW5kIHN5bmMgcXVldWUgJyR7dGhpcy5fbmFtZX0nLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlclN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlUmVxdWVzdChvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICBzd2l0Y2gob3BlcmF0aW9uKXtcbiAgICAgICAgICAgIGNhc2UgXCJwb3BcIjpcbiAgICAgICAgICAgICAgICBlbnRyeSA9IGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUucG9wRW50cnkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzaGlmdFwiOlxuICAgICAgICAgICAgICAgIGVudHJ5ID0gYXdhaXQgdGhpcy5fcXVldWVTdG9yZS5zaGlmdEVudHJ5KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBtYXhSZXRlbnRpb25UaW1lSW5NcyA9IHRoaXMuX21heFJldGVudGlvblRpbWUgKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICBpZiAobm93IC0gZW50cnkudGltZXN0YW1wID4gbWF4UmV0ZW50aW9uVGltZUluTXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlUmVxdWVzdChvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGF5UmVxdWVzdHMoKSB7XG4gICAgICAgIGxldCBlbnRyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBhd2FpdCB0aGlzLnNoaWZ0UmVxdWVzdCgpKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2goZW50cnkucmVxdWVzdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKGVudHJ5LnJlcXVlc3QudXJsKX0nIGAgKyBgaGFzIGJlZW4gcmVwbGF5ZWQgaW4gcXVldWUgJyR7dGhpcy5fbmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVuc2hpZnRSZXF1ZXN0KGVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKGVudHJ5LnJlcXVlc3QudXJsKX0nIGAgKyBgZmFpbGVkIHRvIHJlcGxheSwgcHV0dGluZyBpdCBiYWNrIGluIHF1ZXVlICcke3RoaXMuX25hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwicXVldWUtcmVwbGF5LWZhaWxlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX25hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBBbGwgcmVxdWVzdHMgaW4gcXVldWUgJyR7dGhpcy5uYW1lfScgaGF2ZSBzdWNjZXNzZnVsbHkgcmVwbGF5ZWQ7IHRoZSBxdWV1ZSBpcyBub3cgZW1wdHkhYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVnaXN0ZXJTeW5jKCkge1xuICAgICAgICBpZiAoXCJzeW5jXCIgaW4gc2VsZi5yZWdpc3RyYXRpb24gJiYgIXRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGYucmVnaXN0cmF0aW9uLnN5bmMucmVnaXN0ZXIoYCR7VEFHX1BSRUZJWH06JHt0aGlzLl9uYW1lfWApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIHJlZ2lzdGVyIHN5bmMgZXZlbnQgZm9yICcke3RoaXMuX25hbWV9Jy5gLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkU3luY0xpc3RlbmVyKCkge1xuICAgICAgICBpZiAoXCJzeW5jXCIgaW4gc2VsZi5yZWdpc3RyYXRpb24gJiYgIXRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJzeW5jXCIsIChldmVudCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnID09PSBgJHtUQUdfUFJFRklYfToke3RoaXMuX25hbWV9YCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBCYWNrZ3JvdW5kIHN5bmMgZm9yIHRhZyAnJHtldmVudC50YWd9JyBoYXMgYmVlbiByZWNlaXZlZGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNDb21wbGV0ZSA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zeW5jSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3luY0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vblN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3luY0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgJiYgIShzeW5jRXJyb3IgJiYgIWV2ZW50Lmxhc3RDaGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNDb21wbGV0ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiQmFja2dyb3VuZCBzeW5jIHJlcGxheWluZyB3aXRob3V0IGJhY2tncm91bmQgc3luYyBldmVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgdGhpcy5fb25TeW5jKHtcbiAgICAgICAgICAgICAgICBxdWV1ZTogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBfcXVldWVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlTmFtZXM7XG4gICAgfVxufVxuXG5jbGFzcyBCYWNrZ3JvdW5kU3luY1BsdWdpbiB7XG4gICAgX3F1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBRdWV1ZShuYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hEaWRGYWlsKHsgcmVxdWVzdCB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlLnB1c2hSZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBRVUVVRV9OQU1FID0gXCJzZXJ3aXN0LWdvb2dsZS1hbmFseXRpY3NcIjtcbmNvbnN0IE1BWF9SRVRFTlRJT05fVElNRSA9IDYwICogNDg7XG5jb25zdCBHT09HTEVfQU5BTFlUSUNTX0hPU1QgPSBcInd3dy5nb29nbGUtYW5hbHl0aWNzLmNvbVwiO1xuY29uc3QgR1RNX0hPU1QgPSBcInd3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbVwiO1xuY29uc3QgQU5BTFlUSUNTX0pTX1BBVEggPSBcIi9hbmFseXRpY3MuanNcIjtcbmNvbnN0IEdUQUdfSlNfUEFUSCA9IFwiL2d0YWcvanNcIjtcbmNvbnN0IEdUTV9KU19QQVRIID0gXCIvZ3RtLmpzXCI7XG5jb25zdCBDT0xMRUNUX1BBVEhTX1JFR0VYID0gL15cXC8oXFx3K1xcLyk/Y29sbGVjdC87XG5cbmNvbnN0IGNyZWF0ZU9uU3luY0NhbGxiYWNrID0gKGNvbmZpZyk9PntcbiAgICByZXR1cm4gYXN5bmMgKHsgcXVldWUgfSk9PntcbiAgICAgICAgbGV0IGVudHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZShlbnRyeSA9IGF3YWl0IHF1ZXVlLnNoaWZ0UmVxdWVzdCgpKXtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdCwgdGltZXN0YW1wIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJQT1NUXCIgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IHJlcXVlc3QuY2xvbmUoKS50ZXh0KCkpIDogdXJsLnNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhpdFRpbWUgPSB0aW1lc3RhbXAgLSAoTnVtYmVyKHBhcmFtcy5nZXQoXCJxdFwiKSkgfHwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVUaW1lID0gRGF0ZS5ub3coKSAtIG9yaWdpbmFsSGl0VGltZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KFwicXRcIiwgU3RyaW5nKHF1ZXVlVGltZSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcucGFyYW1ldGVyT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgT2JqZWN0LmtleXMoY29uZmlnLnBhcmFtZXRlck92ZXJyaWRlcykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWcucGFyYW1ldGVyT3ZlcnJpZGVzW3BhcmFtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zZXQocGFyYW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5oaXRGaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuaGl0RmlsdGVyLmNhbGwobnVsbCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2gobmV3IFJlcXVlc3QodXJsLm9yaWdpbiArIHVybC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcIm9taXRcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKHVybC5ocmVmKX0nIGhhcyBiZWVuIHJlcGxheWVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcXVldWUudW5zaGlmdFJlcXVlc3QoZW50cnkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwodXJsLmhyZWYpfScgZmFpbGVkIHRvIHJlcGxheSwgcHV0dGluZyBpdCBiYWNrIGluIHRoZSBxdWV1ZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJBbGwgR29vZ2xlIEFuYWx5dGljcyByZXF1ZXN0IHN1Y2Nlc3NmdWxseSByZXBsYXllZDsgXCIgKyBcInRoZSBxdWV1ZSBpcyBub3cgZW1wdHkhXCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5jb25zdCBjcmVhdGVDb2xsZWN0Um91dGVzID0gKGJnU3luY1BsdWdpbik9PntcbiAgICBjb25zdCBtYXRjaCA9ICh7IHVybCB9KT0+dXJsLmhvc3RuYW1lID09PSBHT09HTEVfQU5BTFlUSUNTX0hPU1QgJiYgQ09MTEVDVF9QQVRIU19SRUdFWC50ZXN0KHVybC5wYXRobmFtZSk7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBOZXR3b3JrT25seSh7XG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGJnU3luY1BsdWdpblxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFJvdXRlKG1hdGNoLCBoYW5kbGVyLCBcIkdFVFwiKSxcbiAgICAgICAgbmV3IFJvdXRlKG1hdGNoLCBoYW5kbGVyLCBcIlBPU1RcIilcbiAgICBdO1xufTtcbmNvbnN0IGNyZWF0ZUFuYWx5dGljc0pzUm91dGUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIGNvbnN0IG1hdGNoID0gKHsgdXJsIH0pPT51cmwuaG9zdG5hbWUgPT09IEdPT0dMRV9BTkFMWVRJQ1NfSE9TVCAmJiB1cmwucGF0aG5hbWUgPT09IEFOQUxZVElDU19KU19QQVRIO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgY2FjaGVOYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaCwgaGFuZGxlciwgXCJHRVRcIik7XG59O1xuY29uc3QgY3JlYXRlR3RhZ0pzUm91dGUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIGNvbnN0IG1hdGNoID0gKHsgdXJsIH0pPT51cmwuaG9zdG5hbWUgPT09IEdUTV9IT1NUICYmIHVybC5wYXRobmFtZSA9PT0gR1RBR19KU19QQVRIO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgY2FjaGVOYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaCwgaGFuZGxlciwgXCJHRVRcIik7XG59O1xuY29uc3QgY3JlYXRlR3RtSnNSb3V0ZSA9IChjYWNoZU5hbWUpPT57XG4gICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSk9PnVybC5ob3N0bmFtZSA9PT0gR1RNX0hPU1QgJiYgdXJsLnBhdGhuYW1lID09PSBHVE1fSlNfUEFUSDtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IE5ldHdvcmtGaXJzdCh7XG4gICAgICAgIGNhY2hlTmFtZVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUm91dGUobWF0Y2gsIGhhbmRsZXIsIFwiR0VUXCIpO1xufTtcbmNvbnN0IGluaXRpYWxpemUgPSAoeyBjYWNoZU5hbWUsIHJvdXRlciA9IGdldFNpbmdsZXRvblJvdXRlcigpLCAuLi5vcHRpb25zIH0gPSB7fSk9PntcbiAgICBjb25zdCByZXNvbHZlZENhY2hlTmFtZSA9IHByaXZhdGVDYWNoZU5hbWVzLmdldEdvb2dsZUFuYWx5dGljc05hbWUoY2FjaGVOYW1lKTtcbiAgICBjb25zdCBiZ1N5bmNQbHVnaW4gPSBuZXcgQmFja2dyb3VuZFN5bmNQbHVnaW4oUVVFVUVfTkFNRSwge1xuICAgICAgICBtYXhSZXRlbnRpb25UaW1lOiBNQVhfUkVURU5USU9OX1RJTUUsXG4gICAgICAgIG9uU3luYzogY3JlYXRlT25TeW5jQ2FsbGJhY2sob3B0aW9ucylcbiAgICB9KTtcbiAgICBjb25zdCByb3V0ZXMgPSBbXG4gICAgICAgIGNyZWF0ZUd0bUpzUm91dGUocmVzb2x2ZWRDYWNoZU5hbWUpLFxuICAgICAgICBjcmVhdGVBbmFseXRpY3NKc1JvdXRlKHJlc29sdmVkQ2FjaGVOYW1lKSxcbiAgICAgICAgY3JlYXRlR3RhZ0pzUm91dGUocmVzb2x2ZWRDYWNoZU5hbWUpLFxuICAgICAgICAuLi5jcmVhdGVDb2xsZWN0Um91dGVzKGJnU3luY1BsdWdpbilcbiAgICBdO1xuICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKXtcbiAgICAgICAgcm91dGVyLnJlZ2lzdGVyUm91dGUocm91dGUpO1xuICAgIH1cbn07XG5cbmNsYXNzIFByZWNhY2hlRmFsbGJhY2tQbHVnaW4ge1xuICAgIF9mYWxsYmFja1VybHM7XG4gICAgX3ByZWNhY2hlQ29udHJvbGxlcjtcbiAgICBjb25zdHJ1Y3Rvcih7IGZhbGxiYWNrVXJscywgcHJlY2FjaGVDb250cm9sbGVyIH0pe1xuICAgICAgICB0aGlzLl9mYWxsYmFja1VybHMgPSBmYWxsYmFja1VybHM7XG4gICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlciA9IHByZWNhY2hlQ29udHJvbGxlciB8fCBnZXRTaW5nbGV0b25QcmVjYWNoZUNvbnRyb2xsZXIoKTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlckRpZEVycm9yKHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFsbGJhY2sgb2YgdGhpcy5fZmFsbGJhY2tVcmxzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5fcHJlY2FjaGVDb250cm9sbGVyLm1hdGNoUHJlY2FjaGUoZmFsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1Jlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChmYWxsYmFjay5tYXRjaGVyKHBhcmFtKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrUmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9wcmVjYWNoZUNvbnRyb2xsZXIubWF0Y2hQcmVjYWNoZShmYWxsYmFjay51cmwpO1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1Jlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kU3luY1BsdWdpbiBhcyBCLCBQcmVjYWNoZUZhbGxiYWNrUGx1Z2luIGFzIFAsIFF1ZXVlIGFzIFEsIFN0b3JhYmxlUmVxdWVzdCBhcyBTLCBRdWV1ZVN0b3JlIGFzIGEsIGluaXRpYWxpemUgYXMgaSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/PrecacheFallbackPlugin.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js ***!
  \***************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   S: function() { return /* binding */ Strategy; },\n/* harmony export */   a: function() { return /* binding */ StrategyHandler; }\n/* harmony export */ });\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n\n\nfunction toRequest(input) {\n    return typeof input === \"string\" ? new Request(input) : input;\n}\nclass StrategyHandler {\n    event;\n    request;\n    url;\n    params;\n    _cacheKeys = {};\n    _strategy;\n    _handlerDeferred;\n    _extendLifetimePromises;\n    _plugins;\n    _pluginStateMap;\n    constructor(strategy, options){\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: \"@serwist/strategies\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.event\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(options.request, Request, {\n                moduleName: \"@serwist/strategies\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.request\"\n            });\n        }\n        this.event = options.event;\n        this.request = options.request;\n        if (options.url) {\n            this.url = options.url;\n            this.params = options.params;\n        }\n        this._strategy = strategy;\n        this._handlerDeferred = new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.Deferred();\n        this._extendLifetimePromises = [];\n        this._plugins = [\n            ...strategy.plugins\n        ];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins){\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === \"navigate\" && event instanceof FetchEvent && event.preloadResponse) {\n            const possiblePreloadResponse = await event.preloadResponse;\n            if (possiblePreloadResponse) {\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Using a preloaded navigation response for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        const originalRequest = this.hasCallback(\"fetchDidFail\") ? request.clone() : null;\n        try {\n            for (const cb of this.iterateCallbacks(\"requestWillFetch\")){\n                request = await cb({\n                    request: request.clone(),\n                    event\n                });\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"plugin-error-request-will-fetch\", {\n                    thrownErrorMessage: err.message\n                });\n            }\n        }\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            fetchResponse = await fetch(request, request.mode === \"navigate\" ? undefined : this._strategy.fetchOptions);\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`Network request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}' returned a response with status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks(\"fetchDidSucceed\")){\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse\n                });\n            }\n            return fetchResponse;\n        } catch (error) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Network request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}' threw an error.`, error);\n            }\n            if (originalRequest) {\n                await this.runCallbacks(\"fetchDidFail\", {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone()\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, \"read\");\n        const multiMatchOptions = {\n            ...matchOptions,\n            ...{\n                cacheName\n            }\n        };\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (true) {\n            if (cachedResponse) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`Found a cached response in '${cacheName}'.`);\n            } else {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cachedResponseWillBeUsed\")){\n            cachedResponse = await callback({\n                cacheName,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n                event: this.event\n            }) || undefined;\n        }\n        return cachedResponse;\n    }\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        await (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.timeout)(0);\n        const effectiveRequest = await this.getCacheKey(request, \"write\");\n        if (true) {\n            if (effectiveRequest.method && effectiveRequest.method !== \"GET\") {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"attempt-to-cache-non-get-request\", {\n                    url: (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(effectiveRequest.url),\n                    method: effectiveRequest.method\n                });\n            }\n        }\n        if (!response) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.error(`Cannot cache non-existent response for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(effectiveRequest.url)}'.`);\n            }\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"cache-put-with-no-response\", {\n                url: (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(effectiveRequest.url)\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`Response '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(effectiveRequest.url)}' will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        if (true) {\n            const vary = response.headers.get(\"Vary\");\n            if (vary && matchOptions?.ignoreVary !== true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`The response for ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(effectiveRequest.url)} has a 'Vary: ${vary}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        const hasCacheUpdateCallback = this.hasCallback(\"cacheDidUpdate\");\n        const oldResponse = hasCacheUpdateCallback ? await (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.cacheMatchIgnoreParams)(cache, effectiveRequest.clone(), [\n            \"__WB_REVISION__\"\n        ], matchOptions) : null;\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`Updating the '${cacheName}' cache with a new Response for ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n            if (error instanceof Error) {\n                if (error.name === \"QuotaExceededError\") {\n                    await (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.executeQuotaErrorCallbacks)();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cacheDidUpdate\")){\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event\n            });\n        }\n        return true;\n    }\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks(\"cacheKeyWillBeUsed\")){\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    params: this.params\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins){\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)){\n            await callback(param);\n        }\n    }\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins){\n            if (typeof plugin[name] === \"function\") {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param)=>{\n                    const statefulParam = {\n                        ...param,\n                        state\n                    };\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    async doneWaiting() {\n        let promise = undefined;\n        while(promise = this._extendLifetimePromises.shift()){\n            await promise;\n        }\n    }\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks(\"cacheWillUpdate\")){\n            responseToCache = await callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event\n            }) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (true) {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`);\n                        } else {\n                            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`The response for '${this.request.url}' returned a status code of '${response.status}' and won't be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\n\nclass Strategy {\n    cacheName;\n    plugins;\n    fetchOptions;\n    matchOptions;\n    constructor(options = {}){\n        this.cacheName = _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.privateCacheNames.getRuntimeName(options.cacheName);\n        this.plugins = options.plugins || [];\n        this.fetchOptions = options.fetchOptions;\n        this.matchOptions = options.matchOptions;\n    }\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    handleAll(options) {\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === \"string\" ? new Request(options.request) : options.request;\n        const handler = new StrategyHandler(this, options.url ? {\n            event,\n            request,\n            url: options.url,\n            params: options.params\n        } : {\n            event,\n            request\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        return [\n            responseDone,\n            handlerDone\n        ];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks(\"handlerWillStart\", {\n            event,\n            request\n        });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            if (response === undefined || response.type === \"error\") {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"no-response\", {\n                    url: request.url\n                });\n            }\n        } catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks(\"handlerDidError\")){\n                    response = await callback({\n                        error,\n                        event,\n                        request\n                    });\n                    if (response !== undefined) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            if (true) {\n                throw _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`While responding to '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}', an ${error instanceof Error ? error.toString() : \"\"} error occurred. Using a fallback response provided by a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks(\"handlerWillRespond\")){\n            response = await callback({\n                event,\n                request,\n                response\n            });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response = undefined;\n        let error = undefined;\n        try {\n            response = await responseDone;\n        } catch (error) {}\n        try {\n            await handler.runCallbacks(\"handlerDidRespond\", {\n                event,\n                request,\n                response\n            });\n            await handler.doneWaiting();\n        } catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks(\"handlerDidComplete\", {\n            event,\n            request,\n            response,\n            error\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9TdHJhdGVneS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBZ0w7O0FBRWhMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNERBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBcUM7QUFDekQsb0JBQW9CLDBEQUFNLG1EQUFtRCxzRUFBYyxjQUFjO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMEJBQTBCLGdFQUFZO0FBQ3RDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRCxnQkFBZ0IsMERBQU0sK0JBQStCLHNFQUFjLGNBQWMscUNBQXFDLHFCQUFxQjtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVixnQkFBZ0IsSUFBcUM7QUFDckQsZ0JBQWdCLDBEQUFNLDZCQUE2QixzRUFBYyxjQUFjO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBCQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBLGdCQUFnQiwwREFBTSxzQ0FBc0MsVUFBVTtBQUN0RSxjQUFjO0FBQ2QsZ0JBQWdCLDBEQUFNLHVDQUF1QyxVQUFVO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrREFBTztBQUNyQjtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQSwwQkFBMEIsZ0VBQVk7QUFDdEMseUJBQXlCLHNFQUFjO0FBQ3ZDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRCxnQkFBZ0IsMERBQU0sa0RBQWtELHNFQUFjLHVCQUF1QjtBQUM3RztBQUNBLHNCQUFzQixnRUFBWTtBQUNsQyxxQkFBcUIsc0VBQWM7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRCxnQkFBZ0IsMERBQU0sb0JBQW9CLHNFQUFjLHVCQUF1QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMEJBQTBCO0FBQzFDO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsZ0JBQWdCLDBEQUFNLDJCQUEyQixzRUFBYyx3QkFBd0IsZUFBZSxLQUFLLGdDQUFnQyxrQkFBa0I7QUFDN0o7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELDhFQUFzQjtBQUNqRjtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBEQUFNLHdCQUF3QixVQUFVLGtDQUFrQyxzRUFBYyx1QkFBdUI7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSwwQkFBMEIsa0ZBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsYUFBYSxJQUFJLEtBQUs7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQXFDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwREFBTSwyQkFBMkIsaUJBQWlCO0FBQzlFLDBCQUEwQjtBQUMxQiw0QkFBNEIsMERBQU0sNEJBQTRCLGlCQUFpQiwrQkFBK0IsZ0JBQWdCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qix5QkFBeUIscUVBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixnRUFBWTtBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRCxzQkFBc0IsMERBQU0sNkJBQTZCLHNFQUFjLGNBQWMsUUFBUSxnREFBZ0Q7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2Vyd2lzdCtzd0A5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L3N3L2Rpc3QvY2h1bmtzL1N0cmF0ZWd5LmpzPzk2YzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXNzZXJ0LCBEZWZlcnJlZCwgbG9nZ2VyLCBnZXRGcmllbmRseVVSTCwgU2Vyd2lzdEVycm9yLCB0aW1lb3V0LCBjYWNoZU1hdGNoSWdub3JlUGFyYW1zLCBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcywgcHJpdmF0ZUNhY2hlTmFtZXMgfSBmcm9tICdAc2Vyd2lzdC9jb3JlL2ludGVybmFsJztcblxuZnVuY3Rpb24gdG9SZXF1ZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIiA/IG5ldyBSZXF1ZXN0KGlucHV0KSA6IGlucHV0O1xufVxuY2xhc3MgU3RyYXRlZ3lIYW5kbGVyIHtcbiAgICBldmVudDtcbiAgICByZXF1ZXN0O1xuICAgIHVybDtcbiAgICBwYXJhbXM7XG4gICAgX2NhY2hlS2V5cyA9IHt9O1xuICAgIF9zdHJhdGVneTtcbiAgICBfaGFuZGxlckRlZmVycmVkO1xuICAgIF9leHRlbmRMaWZldGltZVByb21pc2VzO1xuICAgIF9wbHVnaW5zO1xuICAgIF9wbHVnaW5TdGF0ZU1hcDtcbiAgICBjb25zdHJ1Y3RvcihzdHJhdGVneSwgb3B0aW9ucyl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKG9wdGlvbnMuZXZlbnQsIEV4dGVuZGFibGVFdmVudCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3RyYXRlZ2llc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTdHJhdGVneUhhbmRsZXJcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJvcHRpb25zLmV2ZW50XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2Uob3B0aW9ucy5yZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9zdHJhdGVnaWVzXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlN0cmF0ZWd5SGFuZGxlclwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9wdGlvbnMucmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLl9leHRlbmRMaWZldGltZVByb21pc2VzID0gW107XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBbXG4gICAgICAgICAgICAuLi5zdHJhdGVneS5wbHVnaW5zXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX3BsdWdpblN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9wbHVnaW5zKXtcbiAgICAgICAgICAgIHRoaXMuX3BsdWdpblN0YXRlTWFwLnNldChwbHVnaW4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50LndhaXRVbnRpbCh0aGlzLl9oYW5kbGVyRGVmZXJyZWQucHJvbWlzZSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdG9SZXF1ZXN0KGlucHV0KTtcbiAgICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiICYmIGV2ZW50IGluc3RhbmNlb2YgRmV0Y2hFdmVudCAmJiBldmVudC5wcmVsb2FkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlID0gYXdhaXQgZXZlbnQucHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBVc2luZyBhIHByZWxvYWRlZCBuYXZpZ2F0aW9uIHJlc3BvbnNlIGZvciAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0gdGhpcy5oYXNDYWxsYmFjayhcImZldGNoRGlkRmFpbFwiKSA/IHJlcXVlc3QuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNiIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcInJlcXVlc3RXaWxsRmV0Y2hcIikpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBhd2FpdCBjYih7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwicGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93bkVycm9yTWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QgPSByZXF1ZXN0LmNsb25lKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgICAgIGZldGNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCByZXF1ZXN0Lm1vZGUgPT09IFwibmF2aWdhdGVcIiA/IHVuZGVmaW5lZCA6IHRoaXMuX3N0cmF0ZWd5LmZldGNoT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBOZXR3b3JrIHJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHJldHVybmVkIGEgcmVzcG9uc2Ugd2l0aCBzdGF0dXMgJyR7ZmV0Y2hSZXNwb25zZS5zdGF0dXN9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiZmV0Y2hEaWRTdWNjZWVkXCIpKXtcbiAgICAgICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcGx1Z2luRmlsdGVyZWRSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZmV0Y2hSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTmV0d29yayByZXF1ZXN0IGZvciAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9JyB0aHJldyBhbiBlcnJvci5gLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5DYWxsYmFja3MoXCJmZXRjaERpZEZhaWxcIiwge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3Q6IG9yaWdpbmFsUmVxdWVzdC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QuY2xvbmUoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hBbmRDYWNoZVB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goaW5wdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZUNsb25lID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgdm9pZCB0aGlzLndhaXRVbnRpbCh0aGlzLmNhY2hlUHV0KGlucHV0LCByZXNwb25zZUNsb25lKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgY2FjaGVNYXRjaChrZXkpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHsgY2FjaGVOYW1lLCBtYXRjaE9wdGlvbnMgfSA9IHRoaXMuX3N0cmF0ZWd5O1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCBcInJlYWRcIik7XG4gICAgICAgIGNvbnN0IG11bHRpTWF0Y2hPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ubWF0Y2hPcHRpb25zLFxuICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlcy5tYXRjaChlZmZlY3RpdmVSZXF1ZXN0LCBtdWx0aU1hdGNoT3B0aW9ucyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgRm91bmQgYSBjYWNoZWQgcmVzcG9uc2UgaW4gJyR7Y2FjaGVOYW1lfScuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gY2FjaGVkIHJlc3BvbnNlIGZvdW5kIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiY2FjaGVkUmVzcG9uc2VXaWxsQmVVc2VkXCIpKXtcbiAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZSxcbiAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZWZmZWN0aXZlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudFxuICAgICAgICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgY2FjaGVQdXQoa2V5LCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdG9SZXF1ZXN0KGtleSk7XG4gICAgICAgIGF3YWl0IHRpbWVvdXQoMCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmdldENhY2hlS2V5KHJlcXVlc3QsIFwid3JpdGVcIik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAmJiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJhdHRlbXB0LXRvLWNhY2hlLW5vbi1nZXQtcmVxdWVzdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGVmZmVjdGl2ZVJlcXVlc3QubWV0aG9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgQ2Fubm90IGNhY2hlIG5vbi1leGlzdGVudCByZXNwb25zZSBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiY2FjaGUtcHV0LXdpdGgtbm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogZ2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVRvQ2FjaGUgPSBhd2FpdCB0aGlzLl9lbnN1cmVSZXNwb25zZVNhZmVUb0NhY2hlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFJlc3BvbnNlICcke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0nIHdpbGwgbm90IGJlIGNhY2hlZC5gLCByZXNwb25zZVRvQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FjaGVOYW1lLCBtYXRjaE9wdGlvbnMgfSA9IHRoaXMuX3N0cmF0ZWd5O1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4oY2FjaGVOYW1lKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdmFyeSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiVmFyeVwiKTtcbiAgICAgICAgICAgIGlmICh2YXJ5ICYmIG1hdGNoT3B0aW9ucz8uaWdub3JlVmFyeSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlc3BvbnNlIGZvciAke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0gaGFzIGEgJ1Zhcnk6ICR7dmFyeX0nIGhlYWRlci4gQ29uc2lkZXIgc2V0dGluZyB0aGUge2lnbm9yZVZhcnk6IHRydWV9IG9wdGlvbiBvbiB5b3VyIHN0cmF0ZWd5IHRvIGVuc3VyZSBjYWNoZSBtYXRjaGluZyBhbmQgZGVsZXRpb24gd29ya3MgYXMgZXhwZWN0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzQ2FjaGVVcGRhdGVDYWxsYmFjayA9IHRoaXMuaGFzQ2FsbGJhY2soXCJjYWNoZURpZFVwZGF0ZVwiKTtcbiAgICAgICAgY29uc3Qgb2xkUmVzcG9uc2UgPSBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID8gYXdhaXQgY2FjaGVNYXRjaElnbm9yZVBhcmFtcyhjYWNoZSwgZWZmZWN0aXZlUmVxdWVzdC5jbG9uZSgpLCBbXG4gICAgICAgICAgICBcIl9fV0JfUkVWSVNJT05fX1wiXG4gICAgICAgIF0sIG1hdGNoT3B0aW9ucykgOiBudWxsO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYFVwZGF0aW5nIHRoZSAnJHtjYWNoZU5hbWV9JyBjYWNoZSB3aXRoIGEgbmV3IFJlc3BvbnNlIGZvciAke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLnB1dChlZmZlY3RpdmVSZXF1ZXN0LCBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID8gcmVzcG9uc2VUb0NhY2hlLmNsb25lKCkgOiByZXNwb25zZVRvQ2FjaGUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcImNhY2hlRGlkVXBkYXRlXCIpKXtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgb2xkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgbmV3UmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBnZXRDYWNoZUtleShyZXF1ZXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke3JlcXVlc3QudXJsfSB8ICR7bW9kZX1gO1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlS2V5c1trZXldKSB7XG4gICAgICAgICAgICBsZXQgZWZmZWN0aXZlUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcImNhY2hlS2V5V2lsbEJlVXNlZFwiKSl7XG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlUmVxdWVzdCA9IHRvUmVxdWVzdChhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXlzW2tleV0gPSBlZmZlY3RpdmVSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUtleXNba2V5XTtcbiAgICB9XG4gICAgaGFzQ2FsbGJhY2sobmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9zdHJhdGVneS5wbHVnaW5zKXtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcnVuQ2FsbGJhY2tzKG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKG5hbWUpKXtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqaXRlcmF0ZUNhbGxiYWNrcyhuYW1lKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuX3N0cmF0ZWd5LnBsdWdpbnMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5bbmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGx1Z2luU3RhdGVNYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxDYWxsYmFjayA9IChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxQYXJhbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbltuYW1lXShzdGF0ZWZ1bFBhcmFtKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlZnVsQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FpdFVudGlsKHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgZG9uZVdhaXRpbmcoKSB7XG4gICAgICAgIGxldCBwcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZShwcm9taXNlID0gdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5zaGlmdCgpKXtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIF9lbnN1cmVSZXNwb25zZVNhZmVUb0NhY2hlKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZVRvQ2FjaGUgPSByZXNwb25zZTtcbiAgICAgICAgbGV0IHBsdWdpbnNVc2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiY2FjaGVXaWxsVXBkYXRlXCIpKXtcbiAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZSxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudFxuICAgICAgICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGx1Z2luc1VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbnNVc2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlICYmIHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvQ2FjaGUuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvQ2FjaGUuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSByZXNwb25zZSBmb3IgJyR7dGhpcy5yZXF1ZXN0LnVybH0nIGlzIGFuIG9wYXF1ZSByZXNwb25zZS4gVGhlIGNhY2hpbmcgc3RyYXRlZ3kgdGhhdCB5b3UncmUgdXNpbmcgd2lsbCBub3QgY2FjaGUgb3BhcXVlIHJlc3BvbnNlcyBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZXNwb25zZSBmb3IgJyR7dGhpcy5yZXF1ZXN0LnVybH0nIHJldHVybmVkIGEgc3RhdHVzIGNvZGUgb2YgJyR7cmVzcG9uc2Uuc3RhdHVzfScgYW5kIHdvbid0IGJlIGNhY2hlZCBhcyBhIHJlc3VsdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VUb0NhY2hlO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyYXRlZ3kge1xuICAgIGNhY2hlTmFtZTtcbiAgICBwbHVnaW5zO1xuICAgIGZldGNoT3B0aW9ucztcbiAgICBtYXRjaE9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgdGhpcy5jYWNoZU5hbWUgPSBwcml2YXRlQ2FjaGVOYW1lcy5nZXRSdW50aW1lTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucyB8fCBbXTtcbiAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBvcHRpb25zLmZldGNoT3B0aW9ucztcbiAgICAgICAgdGhpcy5tYXRjaE9wdGlvbnMgPSBvcHRpb25zLm1hdGNoT3B0aW9ucztcbiAgICB9XG4gICAgaGFuZGxlKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgW3Jlc3BvbnNlRG9uZV0gPSB0aGlzLmhhbmRsZUFsbChvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRG9uZTtcbiAgICB9XG4gICAgaGFuZGxlQWxsKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBGZXRjaEV2ZW50KSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGV2ZW50OiBvcHRpb25zLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IG9wdGlvbnMucmVxdWVzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudCA9IG9wdGlvbnMuZXZlbnQ7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0eXBlb2Ygb3B0aW9ucy5yZXF1ZXN0ID09PSBcInN0cmluZ1wiID8gbmV3IFJlcXVlc3Qob3B0aW9ucy5yZXF1ZXN0KSA6IG9wdGlvbnMucmVxdWVzdDtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IG5ldyBTdHJhdGVneUhhbmRsZXIodGhpcywgb3B0aW9ucy51cmwgPyB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgICAgcGFyYW1zOiBvcHRpb25zLnBhcmFtc1xuICAgICAgICB9IDoge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZURvbmUgPSB0aGlzLl9nZXRSZXNwb25zZShoYW5kbGVyLCByZXF1ZXN0LCBldmVudCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJEb25lID0gdGhpcy5fYXdhaXRDb21wbGV0ZShyZXNwb25zZURvbmUsIGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHJlc3BvbnNlRG9uZSxcbiAgICAgICAgICAgIGhhbmRsZXJEb25lXG4gICAgICAgIF07XG4gICAgfVxuICAgIGFzeW5jIF9nZXRSZXNwb25zZShoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcyhcImhhbmRsZXJXaWxsU3RhcnRcIiwge1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3BvbnNlLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJuby1yZXNwb25zZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBoYW5kbGVyLml0ZXJhdGVDYWxsYmFja3MoXCJoYW5kbGVyRGlkRXJyb3JcIikpe1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbG9nZ2VyLmxvZyhgV2hpbGUgcmVzcG9uZGluZyB0byAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9JywgYW4gJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IudG9TdHJpbmcoKSA6IFwiXCJ9IGVycm9yIG9jY3VycmVkLiBVc2luZyBhIGZhbGxiYWNrIHJlc3BvbnNlIHByb3ZpZGVkIGJ5IGEgaGFuZGxlckRpZEVycm9yIHBsdWdpbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGhhbmRsZXIuaXRlcmF0ZUNhbGxiYWNrcyhcImhhbmRsZXJXaWxsUmVzcG9uZFwiKSl7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlc3BvbnNlRG9uZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcyhcImhhbmRsZXJEaWRSZXNwb25kXCIsIHtcbiAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIuZG9uZVdhaXRpbmcoKTtcbiAgICAgICAgfSBjYXRjaCAod2FpdFVudGlsRXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh3YWl0VW50aWxFcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB3YWl0VW50aWxFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBoYW5kbGVyLnJ1bkNhbGxiYWNrcyhcImhhbmRsZXJEaWRDb21wbGV0ZVwiLCB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgICBoYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgU3RyYXRlZ3kgYXMgUywgU3RyYXRlZ3lIYW5kbGVyIGFzIGEgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonPrecacheController.js":
/*!**********************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonPrecacheController.js ***!
  \**********************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P: function() { return /* binding */ PrecacheController; },\n/* harmony export */   a: function() { return /* binding */ PrecacheStrategy; },\n/* harmony export */   g: function() { return /* binding */ getSingletonPrecacheController; },\n/* harmony export */   s: function() { return /* binding */ setSingletonPrecacheController; }\n/* harmony export */ });\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n/* harmony import */ var _serwist_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @serwist/core */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.js\");\n/* harmony import */ var _Strategy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Strategy.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js\");\n\n\n\n\nconst parallel = async (limit, array, func)=>{\n    const work = array.map((item, index)=>({\n            index,\n            item\n        }));\n    const processor = async (res)=>{\n        const results = [];\n        while(true){\n            const next = work.pop();\n            if (!next) {\n                return res(results);\n            }\n            const result = await func(next.item);\n            results.push({\n                result: result,\n                index: next.index\n            });\n        }\n    };\n    const queues = Array.from({\n        length: limit\n    }, ()=>new Promise(processor));\n    const results = (await Promise.all(queues)).flat().sort((a, b)=>a.index < b.index ? -1 : 1).map((res)=>res.result);\n    return results;\n};\n\nclass PrecacheStrategy extends _Strategy_js__WEBPACK_IMPORTED_MODULE_2__.S {\n    _fallbackToNetwork;\n    static defaultPrecacheCacheabilityPlugin = {\n        async cacheWillUpdate ({ response }) {\n            if (!response || response.status >= 400) {\n                return null;\n            }\n            return response;\n        }\n    };\n    static copyRedirectedCacheableResponsesPlugin = {\n        async cacheWillUpdate ({ response }) {\n            return response.redirected ? await (0,_serwist_core__WEBPACK_IMPORTED_MODULE_1__.copyResponse)(response) : response;\n        }\n    };\n    constructor(options = {}){\n        options.cacheName = _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.privateCacheNames.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        if (handler.event && handler.event.type === \"install\") {\n            return await this._handleInstall(request, handler);\n        }\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response = undefined;\n        const params = handler.params || {};\n        if (this._fallbackToNetwork) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`The precached response for ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)} in ${this.cacheName} was not found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== \"no-cors\" ? integrityInRequest || integrityInManifest : undefined\n            }));\n            if (integrityInManifest && noIntegrityConflict && request.mode !== \"no-cors\") {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (true) {\n                    if (wasCached) {\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`A response for ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)} was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        } else {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"missing-precache-entry\", {\n                cacheName: this.cacheName,\n                url: request.url\n            });\n        }\n        if (true) {\n            const cacheKey = params.cacheKey || await handler.getCacheKey(request, \"read\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`Precaching is responding to: ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(request.url)}`);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Serving the precached url: ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(\"View request details here.\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(request);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(\"View response details here.\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(response);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"bad-precaching-response\", {\n                url: request.url,\n                status: response.status\n            });\n        }\n        return response;\n    }\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()){\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n    }\n}\n\nclass PrecacheCacheKeyPlugin {\n    _precacheController;\n    constructor({ precacheController }){\n        this._precacheController = precacheController;\n    }\n    cacheKeyWillBeUsed = async ({ request, params })=>{\n        const cacheKey = params?.cacheKey || this._precacheController.getCacheKeyForURL(request.url);\n        return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n        }) : request;\n    };\n}\n\nclass PrecacheInstallReportPlugin {\n    updatedURLs = [];\n    notUpdatedURLs = [];\n    handlerWillStart = async ({ request, state })=>{\n        if (state) {\n            state.originalRequest = request;\n        }\n    };\n    cachedResponseWillBeUsed = async ({ event, state, cachedResponse })=>{\n        if (event.type === \"install\") {\n            if (state?.originalRequest && state.originalRequest instanceof Request) {\n                const url = state.originalRequest.url;\n                if (cachedResponse) {\n                    this.notUpdatedURLs.push(url);\n                } else {\n                    this.updatedURLs.push(url);\n                }\n            }\n        }\n        return cachedResponse;\n    };\n}\n\nconst REVISION_SEARCH_PARAM = \"__WB_REVISION__\";\nfunction createCacheKey(entry) {\n    if (!entry) {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (typeof entry === \"string\") {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n    };\n}\n\nconst logGroup = (groupTitle, deletedURLs)=>{\n    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(groupTitle);\n    for (const url of deletedURLs){\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(url);\n    }\n    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n};\nfunction printCleanupDetails(deletedURLs) {\n    const deletionCount = deletedURLs.length;\n    if (deletionCount > 0) {\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`During precaching cleanup, ${deletionCount} cached request${deletionCount === 1 ? \" was\" : \"s were\"} deleted.`);\n        logGroup(\"Deleted Cache Requests\", deletedURLs);\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n    }\n}\n\nfunction _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n        return;\n    }\n    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(groupTitle);\n    for (const url of urls){\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(url);\n    }\n    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n}\nfunction printInstallDetails(urlsToPrecache, urlsAlreadyPrecached) {\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n    if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? \"\" : \"s\"}.`;\n        if (alreadyPrecachedCount > 0) {\n            message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? \" is\" : \"s are\"} already cached.`;\n        }\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(message);\n        _nestedGroup(\"View newly precached URLs.\", urlsToPrecache);\n        _nestedGroup(\"View previously precached URLs.\", urlsAlreadyPrecached);\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n    }\n}\n\nclass PrecacheController {\n    _installAndActiveListenersAdded;\n    _concurrentPrecaching;\n    _strategy;\n    _urlsToCacheKeys = new Map();\n    _urlsToCacheModes = new Map();\n    _cacheKeysToIntegrities = new Map();\n    constructor({ cacheName, plugins = [], fallbackToNetwork = true, concurrentPrecaching = 1 } = {}){\n        this._concurrentPrecaching = concurrentPrecaching;\n        this._strategy = new PrecacheStrategy({\n            cacheName: _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.privateCacheNames.getPrecacheName(cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({\n                    precacheController: this\n                })\n            ],\n            fallbackToNetwork\n        });\n        this.install = this.install.bind(this);\n        this.activate = this.activate.bind(this);\n    }\n    get strategy() {\n        return this._strategy;\n    }\n    precache(entries) {\n        this.addToCacheList(entries);\n        if (!this._installAndActiveListenersAdded) {\n            self.addEventListener(\"install\", this.install);\n            self.addEventListener(\"activate\", this.activate);\n            this._installAndActiveListenersAdded = true;\n        }\n    }\n    addToCacheList(entries) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isArray(entries, {\n                moduleName: \"@serwist/precaching\",\n                className: \"PrecacheController\",\n                funcName: \"addToCacheList\",\n                paramName: \"entries\"\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries){\n            if (typeof entry === \"string\") {\n                urlsToWarnAbout.push(entry);\n            } else if (entry && !entry.integrity && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== \"string\" && entry.revision ? \"reload\" : \"default\";\n            if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"add-to-cache-list-conflicting-entries\", {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey\n                });\n            }\n            if (typeof entry !== \"string\" && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"add-to-cache-list-conflicting-integrities\", {\n                        url\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Serwist is precaching URLs without revision info: ${urlsToWarnAbout.join(\", \")}\\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;\n                if (false) {} else {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.warn(warningMessage);\n                }\n            }\n        }\n    }\n    install(event) {\n        return (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.waitUntil)(event, async ()=>{\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.strategy.plugins.push(installReportPlugin);\n            await parallel(this._concurrentPrecaching, Array.from(this._urlsToCacheKeys.entries()), async ([url, cacheKey])=>{\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: \"same-origin\"\n                });\n                await Promise.all(this.strategy.handleAll({\n                    event,\n                    request,\n                    url: new URL(request.url),\n                    params: {\n                        cacheKey\n                    }\n                }));\n            });\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (true) {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return {\n                updatedURLs,\n                notUpdatedURLs\n            };\n        });\n    }\n    activate(event) {\n        return (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.waitUntil)(event, async ()=>{\n            const cache = await self.caches.open(this.strategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedCacheRequests = [];\n            for (const request of currentlyCachedRequests){\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedCacheRequests.push(request.url);\n                }\n            }\n            if (true) {\n                printCleanupDetails(deletedCacheRequests);\n            }\n            return {\n                deletedCacheRequests\n            };\n        });\n    }\n    getURLsToCacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    getCachedURLs() {\n        return [\n            ...this._urlsToCacheKeys.keys()\n        ];\n    }\n    getCacheKeyForURL(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    getIntegrityForCacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.strategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    createHandlerBoundToURL(url) {\n        const cacheKey = this.getCacheKeyForURL(url);\n        if (!cacheKey) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"non-precached-url\", {\n                url\n            });\n        }\n        return (options)=>{\n            options.request = new Request(url);\n            options.params = {\n                cacheKey,\n                ...options.params\n            };\n            return this.strategy.handle(options);\n        };\n    }\n}\n\nlet defaultPrecacheController = undefined;\nconst getSingletonPrecacheController = ()=>{\n    if (!defaultPrecacheController) {\n        defaultPrecacheController = new PrecacheController();\n    }\n    return defaultPrecacheController;\n};\nconst setSingletonPrecacheController = (precacheController)=>{\n    defaultPrecacheController = precacheController;\n    return defaultPrecacheController;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9zaW5nbGV0b25QcmVjYWNoZUNvbnRyb2xsZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFvSDtBQUN2RTtBQUNDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMkNBQVE7QUFDdkM7QUFDQTtBQUNBLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0MsK0NBQStDLDJEQUFZO0FBQzNEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsNEJBQTRCLHFFQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQsZ0JBQWdCLDBEQUFNLG9DQUFvQyxzRUFBYyxlQUFlLEtBQUssZ0JBQWdCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQSx3QkFBd0IsMERBQU0sdUJBQXVCLHNFQUFjLGVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBLFlBQVksMERBQU0sZ0RBQWdELHNFQUFjLGNBQWM7QUFDOUYsWUFBWSwwREFBTSxtQ0FBbUMsc0VBQWMsd0RBQXdEO0FBQzNILFlBQVksMERBQU07QUFDbEIsWUFBWSwwREFBTTtBQUNsQixZQUFZLDBEQUFNO0FBQ2xCLFlBQVksMERBQU07QUFDbEIsWUFBWSwwREFBTTtBQUNsQixZQUFZLDBEQUFNO0FBQ2xCLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQ0FBa0MsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFZO0FBQzlCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLGtCQUFrQixnRUFBWTtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksMERBQU07QUFDVjtBQUNBLFFBQVEsMERBQU07QUFDZDtBQUNBLElBQUksMERBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQU0sOENBQThDLGVBQWUsZ0JBQWdCLHlDQUF5QztBQUNwSTtBQUNBLFFBQVEsMERBQU07QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwREFBTTtBQUNWO0FBQ0EsUUFBUSwwREFBTTtBQUNkO0FBQ0EsSUFBSSwwREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsZ0JBQWdCLE1BQU0sZ0NBQWdDO0FBQzFGO0FBQ0EsMkJBQTJCLHVCQUF1QixXQUFXLCtDQUErQztBQUM1RztBQUNBLFFBQVEsMERBQU07QUFDZDtBQUNBO0FBQ0EsUUFBUSwwREFBTTtBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEVBQThFLElBQUk7QUFDcEc7QUFDQTtBQUNBLHVCQUF1QixxRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0EsMEJBQTBCLGdFQUFZO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGdFQUFZO0FBQzFDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RiwyQkFBMkI7QUFDdkgsb0JBQW9CLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNsQixvQkFBb0IsMERBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUVBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixvQkFBb0IsOEJBQThCO0FBQ2xELGdCQUFnQixJQUFxQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGVBQWUsaUVBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9JIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2Vyd2lzdCtzd0A5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L3N3L2Rpc3QvY2h1bmtzL3NpbmdsZXRvblByZWNhY2hlQ29udHJvbGxlci5qcz8wZTRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByaXZhdGVDYWNoZU5hbWVzLCBsb2dnZXIsIGdldEZyaWVuZGx5VVJMLCBTZXJ3aXN0RXJyb3IsIGFzc2VydCwgd2FpdFVudGlsIH0gZnJvbSAnQHNlcndpc3QvY29yZS9pbnRlcm5hbCc7XG5pbXBvcnQgeyBjb3B5UmVzcG9uc2UgfSBmcm9tICdAc2Vyd2lzdC9jb3JlJztcbmltcG9ydCB7IFMgYXMgU3RyYXRlZ3kgfSBmcm9tICcuL1N0cmF0ZWd5LmpzJztcblxuY29uc3QgcGFyYWxsZWwgPSBhc3luYyAobGltaXQsIGFycmF5LCBmdW5jKT0+e1xuICAgIGNvbnN0IHdvcmsgPSBhcnJheS5tYXAoKGl0ZW0sIGluZGV4KT0+KHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICB9KSk7XG4gICAgY29uc3QgcHJvY2Vzc29yID0gYXN5bmMgKHJlcyk9PntcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB3b3JrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyhyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZ1bmMobmV4dC5pdGVtKTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgaW5kZXg6IG5leHQuaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBxdWV1ZXMgPSBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBsaW1pdFxuICAgIH0sICgpPT5uZXcgUHJvbWlzZShwcm9jZXNzb3IpKTtcbiAgICBjb25zdCByZXN1bHRzID0gKGF3YWl0IFByb21pc2UuYWxsKHF1ZXVlcykpLmZsYXQoKS5zb3J0KChhLCBiKT0+YS5pbmRleCA8IGIuaW5kZXggPyAtMSA6IDEpLm1hcCgocmVzKT0+cmVzLnJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5jbGFzcyBQcmVjYWNoZVN0cmF0ZWd5IGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIF9mYWxsYmFja1RvTmV0d29yaztcbiAgICBzdGF0aWMgZGVmYXVsdFByZWNhY2hlQ2FjaGVhYmlsaXR5UGx1Z2luID0ge1xuICAgICAgICBhc3luYyBjYWNoZVdpbGxVcGRhdGUgKHsgcmVzcG9uc2UgfSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCByZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0YXRpYyBjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbiA9IHtcbiAgICAgICAgYXN5bmMgY2FjaGVXaWxsVXBkYXRlICh7IHJlc3BvbnNlIH0pIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZWRpcmVjdGVkID8gYXdhaXQgY29weVJlc3BvbnNlKHJlc3BvbnNlKSA6IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICBvcHRpb25zLmNhY2hlTmFtZSA9IHByaXZhdGVDYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9mYWxsYmFja1RvTmV0d29yayA9IG9wdGlvbnMuZmFsbGJhY2tUb05ldHdvcmsgPT09IGZhbHNlID8gZmFsc2UgOiB0cnVlO1xuICAgICAgICB0aGlzLnBsdWdpbnMucHVzaChQcmVjYWNoZVN0cmF0ZWd5LmNvcHlSZWRpcmVjdGVkQ2FjaGVhYmxlUmVzcG9uc2VzUGx1Z2luKTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5jYWNoZU1hdGNoKHJlcXVlc3QpO1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlci5ldmVudCAmJiBoYW5kbGVyLmV2ZW50LnR5cGUgPT09IFwiaW5zdGFsbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlSW5zdGFsbChyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlRmV0Y2gocmVxdWVzdCwgaGFuZGxlcik7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVGZXRjaChyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gaGFuZGxlci5wYXJhbXMgfHwge307XG4gICAgICAgIGlmICh0aGlzLl9mYWxsYmFja1RvTmV0d29yaykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaGUgcHJlY2FjaGVkIHJlc3BvbnNlIGZvciAke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0gaW4gJHt0aGlzLmNhY2hlTmFtZX0gd2FzIG5vdCBmb3VuZC4gRmFsbGluZyBiYWNrIHRvIHRoZSBuZXR3b3JrLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW50ZWdyaXR5SW5NYW5pZmVzdCA9IHBhcmFtcy5pbnRlZ3JpdHk7XG4gICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHlJblJlcXVlc3QgPSByZXF1ZXN0LmludGVncml0eTtcbiAgICAgICAgICAgIGNvbnN0IG5vSW50ZWdyaXR5Q29uZmxpY3QgPSAhaW50ZWdyaXR5SW5SZXF1ZXN0IHx8IGludGVncml0eUluUmVxdWVzdCA9PT0gaW50ZWdyaXR5SW5NYW5pZmVzdDtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaChuZXcgUmVxdWVzdChyZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgaW50ZWdyaXR5OiByZXF1ZXN0Lm1vZGUgIT09IFwibm8tY29yc1wiID8gaW50ZWdyaXR5SW5SZXF1ZXN0IHx8IGludGVncml0eUluTWFuaWZlc3QgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChpbnRlZ3JpdHlJbk1hbmlmZXN0ICYmIG5vSW50ZWdyaXR5Q29uZmxpY3QgJiYgcmVxdWVzdC5tb2RlICE9PSBcIm5vLWNvcnNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VzZURlZmF1bHRDYWNoZWFiaWxpdHlQbHVnaW5JZk5lZWRlZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhc0NhY2hlZCA9IGF3YWl0IGhhbmRsZXIuY2FjaGVQdXQocmVxdWVzdCwgcmVzcG9uc2UuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAod2FzQ2FjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBBIHJlc3BvbnNlIGZvciAke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0gd2FzIHVzZWQgdG8gXCJyZXBhaXJcIiB0aGUgcHJlY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibWlzc2luZy1wcmVjYWNoZS1lbnRyeVwiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGVOYW1lOiB0aGlzLmNhY2hlTmFtZSxcbiAgICAgICAgICAgICAgICB1cmw6IHJlcXVlc3QudXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IHBhcmFtcy5jYWNoZUtleSB8fCBhd2FpdCBoYW5kbGVyLmdldENhY2hlS2V5KHJlcXVlc3QsIFwicmVhZFwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUHJlY2FjaGluZyBpcyByZXNwb25kaW5nIHRvOiAke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX1gKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coYFNlcnZpbmcgdGhlIHByZWNhY2hlZCB1cmw6ICR7Z2V0RnJpZW5kbHlVUkwoY2FjaGVLZXkgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gY2FjaGVLZXkudXJsIDogY2FjaGVLZXkpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiVmlldyByZXF1ZXN0IGRldGFpbHMgaGVyZS5cIik7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlcXVlc3QpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoXCJWaWV3IHJlc3BvbnNlIGRldGFpbHMgaGVyZS5cIik7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlSW5zdGFsbChyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3VzZURlZmF1bHRDYWNoZWFiaWxpdHlQbHVnaW5JZk5lZWRlZCgpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2gocmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IHdhc0NhY2hlZCA9IGF3YWl0IGhhbmRsZXIuY2FjaGVQdXQocmVxdWVzdCwgcmVzcG9uc2UuY2xvbmUoKSk7XG4gICAgICAgIGlmICghd2FzQ2FjaGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiYmFkLXByZWNhY2hpbmctcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgX3VzZURlZmF1bHRDYWNoZWFiaWxpdHlQbHVnaW5JZk5lZWRlZCgpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRQbHVnaW5JbmRleCA9IG51bGw7XG4gICAgICAgIGxldCBjYWNoZVdpbGxVcGRhdGVQbHVnaW5Db3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgW2luZGV4LCBwbHVnaW5dIG9mIHRoaXMucGx1Z2lucy5lbnRyaWVzKCkpe1xuICAgICAgICAgICAgaWYgKHBsdWdpbiA9PT0gUHJlY2FjaGVTdHJhdGVneS5jb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbiA9PT0gUHJlY2FjaGVTdHJhdGVneS5kZWZhdWx0UHJlY2FjaGVDYWNoZWFiaWxpdHlQbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0UGx1Z2luSW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwbHVnaW4uY2FjaGVXaWxsVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVXaWxsVXBkYXRlUGx1Z2luQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGVXaWxsVXBkYXRlUGx1Z2luQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucy5wdXNoKFByZWNhY2hlU3RyYXRlZ3kuZGVmYXVsdFByZWNhY2hlQ2FjaGVhYmlsaXR5UGx1Z2luKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWNoZVdpbGxVcGRhdGVQbHVnaW5Db3VudCA+IDEgJiYgZGVmYXVsdFBsdWdpbkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbnMuc3BsaWNlKGRlZmF1bHRQbHVnaW5JbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4ge1xuICAgIF9wcmVjYWNoZUNvbnRyb2xsZXI7XG4gICAgY29uc3RydWN0b3IoeyBwcmVjYWNoZUNvbnRyb2xsZXIgfSl7XG4gICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlciA9IHByZWNhY2hlQ29udHJvbGxlcjtcbiAgICB9XG4gICAgY2FjaGVLZXlXaWxsQmVVc2VkID0gYXN5bmMgKHsgcmVxdWVzdCwgcGFyYW1zIH0pPT57XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGFyYW1zPy5jYWNoZUtleSB8fCB0aGlzLl9wcmVjYWNoZUNvbnRyb2xsZXIuZ2V0Q2FjaGVLZXlGb3JVUkwocmVxdWVzdC51cmwpO1xuICAgICAgICByZXR1cm4gY2FjaGVLZXkgPyBuZXcgUmVxdWVzdChjYWNoZUtleSwge1xuICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzXG4gICAgICAgIH0pIDogcmVxdWVzdDtcbiAgICB9O1xufVxuXG5jbGFzcyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4ge1xuICAgIHVwZGF0ZWRVUkxzID0gW107XG4gICAgbm90VXBkYXRlZFVSTHMgPSBbXTtcbiAgICBoYW5kbGVyV2lsbFN0YXJ0ID0gYXN5bmMgKHsgcmVxdWVzdCwgc3RhdGUgfSk9PntcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQgPSBhc3luYyAoeyBldmVudCwgc3RhdGUsIGNhY2hlZFJlc3BvbnNlIH0pPT57XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcImluc3RhbGxcIikge1xuICAgICAgICAgICAgaWYgKHN0YXRlPy5vcmlnaW5hbFJlcXVlc3QgJiYgc3RhdGUub3JpZ2luYWxSZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHN0YXRlLm9yaWdpbmFsUmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90VXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfTtcbn1cblxuY29uc3QgUkVWSVNJT05fU0VBUkNIX1BBUkFNID0gXCJfX1dCX1JFVklTSU9OX19cIjtcbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlS2V5KGVudHJ5KSB7XG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlXCIsIHtcbiAgICAgICAgICAgIGVudHJ5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwoZW50cnksIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3QuaHJlZlxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB7IHJldmlzaW9uLCB1cmwgfSA9IGVudHJ5O1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJhZGQtdG8tY2FjaGUtbGlzdC11bmV4cGVjdGVkLXR5cGVcIiwge1xuICAgICAgICAgICAgZW50cnlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcmV2aXNpb24pIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IHVybE9iamVjdC5ocmVmLFxuICAgICAgICAgICAgdXJsOiB1cmxPYmplY3QuaHJlZlxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleVVSTCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICBjb25zdCBvcmlnaW5hbFVSTCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICBjYWNoZUtleVVSTC5zZWFyY2hQYXJhbXMuc2V0KFJFVklTSU9OX1NFQVJDSF9QQVJBTSwgcmV2aXNpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleVVSTC5ocmVmLFxuICAgICAgICB1cmw6IG9yaWdpbmFsVVJMLmhyZWZcbiAgICB9O1xufVxuXG5jb25zdCBsb2dHcm91cCA9IChncm91cFRpdGxlLCBkZWxldGVkVVJMcyk9PntcbiAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoZ3JvdXBUaXRsZSk7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgZGVsZXRlZFVSTHMpe1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufTtcbmZ1bmN0aW9uIHByaW50Q2xlYW51cERldGFpbHMoZGVsZXRlZFVSTHMpIHtcbiAgICBjb25zdCBkZWxldGlvbkNvdW50ID0gZGVsZXRlZFVSTHMubGVuZ3RoO1xuICAgIGlmIChkZWxldGlvbkNvdW50ID4gMCkge1xuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYER1cmluZyBwcmVjYWNoaW5nIGNsZWFudXAsICR7ZGVsZXRpb25Db3VudH0gY2FjaGVkIHJlcXVlc3Qke2RlbGV0aW9uQ291bnQgPT09IDEgPyBcIiB3YXNcIiA6IFwicyB3ZXJlXCJ9IGRlbGV0ZWQuYCk7XG4gICAgICAgIGxvZ0dyb3VwKFwiRGVsZXRlZCBDYWNoZSBSZXF1ZXN0c1wiLCBkZWxldGVkVVJMcyk7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX25lc3RlZEdyb3VwKGdyb3VwVGl0bGUsIHVybHMpIHtcbiAgICBpZiAodXJscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoZ3JvdXBUaXRsZSk7XG4gICAgZm9yIChjb25zdCB1cmwgb2YgdXJscyl7XG4gICAgICAgIGxvZ2dlci5sb2codXJsKTtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG59XG5mdW5jdGlvbiBwcmludEluc3RhbGxEZXRhaWxzKHVybHNUb1ByZWNhY2hlLCB1cmxzQWxyZWFkeVByZWNhY2hlZCkge1xuICAgIGNvbnN0IHByZWNhY2hlZENvdW50ID0gdXJsc1RvUHJlY2FjaGUubGVuZ3RoO1xuICAgIGNvbnN0IGFscmVhZHlQcmVjYWNoZWRDb3VudCA9IHVybHNBbHJlYWR5UHJlY2FjaGVkLmxlbmd0aDtcbiAgICBpZiAocHJlY2FjaGVkQ291bnQgfHwgYWxyZWFkeVByZWNhY2hlZENvdW50KSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gYFByZWNhY2hpbmcgJHtwcmVjYWNoZWRDb3VudH0gZmlsZSR7cHJlY2FjaGVkQ291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9LmA7XG4gICAgICAgIGlmIChhbHJlYWR5UHJlY2FjaGVkQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgJHthbHJlYWR5UHJlY2FjaGVkQ291bnR9IGAgKyBgZmlsZSR7YWxyZWFkeVByZWNhY2hlZENvdW50ID09PSAxID8gXCIgaXNcIiA6IFwicyBhcmVcIn0gYWxyZWFkeSBjYWNoZWQuYDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZSk7XG4gICAgICAgIF9uZXN0ZWRHcm91cChcIlZpZXcgbmV3bHkgcHJlY2FjaGVkIFVSTHMuXCIsIHVybHNUb1ByZWNhY2hlKTtcbiAgICAgICAgX25lc3RlZEdyb3VwKFwiVmlldyBwcmV2aW91c2x5IHByZWNhY2hlZCBVUkxzLlwiLCB1cmxzQWxyZWFkeVByZWNhY2hlZCk7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn1cblxuY2xhc3MgUHJlY2FjaGVDb250cm9sbGVyIHtcbiAgICBfaW5zdGFsbEFuZEFjdGl2ZUxpc3RlbmVyc0FkZGVkO1xuICAgIF9jb25jdXJyZW50UHJlY2FjaGluZztcbiAgICBfc3RyYXRlZ3k7XG4gICAgX3VybHNUb0NhY2hlS2V5cyA9IG5ldyBNYXAoKTtcbiAgICBfdXJsc1RvQ2FjaGVNb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBfY2FjaGVLZXlzVG9JbnRlZ3JpdGllcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdHJ1Y3Rvcih7IGNhY2hlTmFtZSwgcGx1Z2lucyA9IFtdLCBmYWxsYmFja1RvTmV0d29yayA9IHRydWUsIGNvbmN1cnJlbnRQcmVjYWNoaW5nID0gMSB9ID0ge30pe1xuICAgICAgICB0aGlzLl9jb25jdXJyZW50UHJlY2FjaGluZyA9IGNvbmN1cnJlbnRQcmVjYWNoaW5nO1xuICAgICAgICB0aGlzLl9zdHJhdGVneSA9IG5ldyBQcmVjYWNoZVN0cmF0ZWd5KHtcbiAgICAgICAgICAgIGNhY2hlTmFtZTogcHJpdmF0ZUNhY2hlTmFtZXMuZ2V0UHJlY2FjaGVOYW1lKGNhY2hlTmFtZSksXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgLi4ucGx1Z2lucyxcbiAgICAgICAgICAgICAgICBuZXcgUHJlY2FjaGVDYWNoZUtleVBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgIHByZWNhY2hlQ29udHJvbGxlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZmFsbGJhY2tUb05ldHdvcmtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5zdGFsbCA9IHRoaXMuaW5zdGFsbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlID0gdGhpcy5hY3RpdmF0ZS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgc3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJhdGVneTtcbiAgICB9XG4gICAgcHJlY2FjaGUoZW50cmllcykge1xuICAgICAgICB0aGlzLmFkZFRvQ2FjaGVMaXN0KGVudHJpZXMpO1xuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbGxBbmRBY3RpdmVMaXN0ZW5lcnNBZGRlZCkge1xuICAgICAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiaW5zdGFsbFwiLCB0aGlzLmluc3RhbGwpO1xuICAgICAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiYWN0aXZhdGVcIiwgdGhpcy5hY3RpdmF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YWxsQW5kQWN0aXZlTGlzdGVuZXJzQWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZFRvQ2FjaGVMaXN0KGVudHJpZXMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzQXJyYXkoZW50cmllcywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvcHJlY2FjaGluZ1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJQcmVjYWNoZUNvbnRyb2xsZXJcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJhZGRUb0NhY2hlTGlzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyaWVzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybHNUb1dhcm5BYm91dCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHVybHNUb1dhcm5BYm91dC5wdXNoKGVudHJ5KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkgJiYgIWVudHJ5LmludGVncml0eSAmJiBlbnRyeS5yZXZpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXJsc1RvV2FybkFib3V0LnB1c2goZW50cnkudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY2FjaGVLZXksIHVybCB9ID0gY3JlYXRlQ2FjaGVLZXkoZW50cnkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gdHlwZW9mIGVudHJ5ICE9PSBcInN0cmluZ1wiICYmIGVudHJ5LnJldmlzaW9uID8gXCJyZWxvYWRcIiA6IFwiZGVmYXVsdFwiO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3VybHNUb0NhY2hlS2V5cy5oYXModXJsKSAmJiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCkgIT09IGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImFkZC10by1jYWNoZS1saXN0LWNvbmZsaWN0aW5nLWVudHJpZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdEVudHJ5OiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybCksXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEVudHJ5OiBjYWNoZUtleVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeS5pbnRlZ3JpdHkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FjaGVLZXlzVG9JbnRlZ3JpdGllcy5oYXMoY2FjaGVLZXkpICYmIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KSAhPT0gZW50cnkuaW50ZWdyaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1pbnRlZ3JpdGllc1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuc2V0KGNhY2hlS2V5LCBlbnRyeS5pbnRlZ3JpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLnNldCh1cmwsIGNhY2hlS2V5KTtcbiAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlTW9kZXMuc2V0KHVybCwgY2FjaGVNb2RlKTtcbiAgICAgICAgICAgIGlmICh1cmxzVG9XYXJuQWJvdXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdNZXNzYWdlID0gYFNlcndpc3QgaXMgcHJlY2FjaGluZyBVUkxzIHdpdGhvdXQgcmV2aXNpb24gaW5mbzogJHt1cmxzVG9XYXJuQWJvdXQuam9pbihcIiwgXCIpfVxcblRoaXMgaXMgZ2VuZXJhbGx5IE5PVCBzYWZlLiBMZWFybiBtb3JlIGF0IGh0dHBzOi8vYml0Lmx5L3diLXByZWNhY2hlYDtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybih3YXJuaW5nTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnN0YWxsKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpPT57XG4gICAgICAgICAgICBjb25zdCBpbnN0YWxsUmVwb3J0UGx1Z2luID0gbmV3IFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbigpO1xuICAgICAgICAgICAgdGhpcy5zdHJhdGVneS5wbHVnaW5zLnB1c2goaW5zdGFsbFJlcG9ydFBsdWdpbik7XG4gICAgICAgICAgICBhd2FpdCBwYXJhbGxlbCh0aGlzLl9jb25jdXJyZW50UHJlY2FjaGluZywgQXJyYXkuZnJvbSh0aGlzLl91cmxzVG9DYWNoZUtleXMuZW50cmllcygpKSwgYXN5bmMgKFt1cmwsIGNhY2hlS2V5XSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHkgPSB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gdGhpcy5fdXJsc1RvQ2FjaGVNb2Rlcy5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMuc3RyYXRlZ3kuaGFuZGxlQWxsKHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIHVybDogbmV3IFVSTChyZXF1ZXN0LnVybCksXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB1cGRhdGVkVVJMcywgbm90VXBkYXRlZFVSTHMgfSA9IGluc3RhbGxSZXBvcnRQbHVnaW47XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRJbnN0YWxsRGV0YWlscyh1cGRhdGVkVVJMcywgbm90VXBkYXRlZFVSTHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkVVJMcyxcbiAgICAgICAgICAgICAgICBub3RVcGRhdGVkVVJMc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFjdGl2YXRlKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB3YWl0VW50aWwoZXZlbnQsIGFzeW5jICgpPT57XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4odGhpcy5zdHJhdGVneS5jYWNoZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudGx5Q2FjaGVkUmVxdWVzdHMgPSBhd2FpdCBjYWNoZS5rZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZENhY2hlS2V5cyA9IG5ldyBTZXQodGhpcy5fdXJsc1RvQ2FjaGVLZXlzLnZhbHVlcygpKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWRDYWNoZVJlcXVlc3RzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgY3VycmVudGx5Q2FjaGVkUmVxdWVzdHMpe1xuICAgICAgICAgICAgICAgIGlmICghZXhwZWN0ZWRDYWNoZUtleXMuaGFzKHJlcXVlc3QudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjYWNoZS5kZWxldGUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRDYWNoZVJlcXVlc3RzLnB1c2gocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwcmludENsZWFudXBEZXRhaWxzKGRlbGV0ZWRDYWNoZVJlcXVlc3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZENhY2hlUmVxdWVzdHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRVUkxzVG9DYWNoZUtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmxzVG9DYWNoZUtleXM7XG4gICAgfVxuICAgIGdldENhY2hlZFVSTHMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi50aGlzLl91cmxzVG9DYWNoZUtleXMua2V5cygpXG4gICAgICAgIF07XG4gICAgfVxuICAgIGdldENhY2hlS2V5Rm9yVVJMKHVybCkge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmxzVG9DYWNoZUtleXMuZ2V0KHVybE9iamVjdC5ocmVmKTtcbiAgICB9XG4gICAgZ2V0SW50ZWdyaXR5Rm9yQ2FjaGVLZXkoY2FjaGVLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICB9XG4gICAgYXN5bmMgbWF0Y2hQcmVjYWNoZShyZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gcmVxdWVzdC51cmwgOiByZXF1ZXN0O1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXlGb3JVUkwodXJsKTtcbiAgICAgICAgaWYgKGNhY2hlS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4odGhpcy5zdHJhdGVneS5jYWNoZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLm1hdGNoKGNhY2hlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjcmVhdGVIYW5kbGVyQm91bmRUb1VSTCh1cmwpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5Rm9yVVJMKHVybCk7XG4gICAgICAgIGlmICghY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJub24tcHJlY2FjaGVkLXVybFwiLCB7XG4gICAgICAgICAgICAgICAgdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG9wdGlvbnMpPT57XG4gICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwpO1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJhdGVneS5oYW5kbGUob3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5sZXQgZGVmYXVsdFByZWNhY2hlQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcbmNvbnN0IGdldFNpbmdsZXRvblByZWNhY2hlQ29udHJvbGxlciA9ICgpPT57XG4gICAgaWYgKCFkZWZhdWx0UHJlY2FjaGVDb250cm9sbGVyKSB7XG4gICAgICAgIGRlZmF1bHRQcmVjYWNoZUNvbnRyb2xsZXIgPSBuZXcgUHJlY2FjaGVDb250cm9sbGVyKCk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UHJlY2FjaGVDb250cm9sbGVyO1xufTtcbmNvbnN0IHNldFNpbmdsZXRvblByZWNhY2hlQ29udHJvbGxlciA9IChwcmVjYWNoZUNvbnRyb2xsZXIpPT57XG4gICAgZGVmYXVsdFByZWNhY2hlQ29udHJvbGxlciA9IHByZWNhY2hlQ29udHJvbGxlcjtcbiAgICByZXR1cm4gZGVmYXVsdFByZWNhY2hlQ29udHJvbGxlcjtcbn07XG5cbmV4cG9ydCB7IFByZWNhY2hlQ29udHJvbGxlciBhcyBQLCBQcmVjYWNoZVN0cmF0ZWd5IGFzIGEsIGdldFNpbmdsZXRvblByZWNhY2hlQ29udHJvbGxlciBhcyBnLCBzZXRTaW5nbGV0b25QcmVjYWNoZUNvbnRyb2xsZXIgYXMgcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonPrecacheController.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonRouter.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonRouter.js ***!
  \**********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   R: function() { return /* binding */ Route; },\n/* harmony export */   a: function() { return /* binding */ RegExpRoute; },\n/* harmony export */   b: function() { return /* binding */ Router; },\n/* harmony export */   g: function() { return /* binding */ getSingletonRouter; },\n/* harmony export */   p: function() { return /* binding */ parseRoute; },\n/* harmony export */   s: function() { return /* binding */ setSingletonRouter; }\n/* harmony export */ });\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n\n\nconst defaultMethod = \"GET\";\nconst validMethods = [\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\"\n];\n\nconst normalizeHandler = (handler)=>{\n    if (handler && typeof handler === \"object\") {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.hasMethod(handler, \"handle\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"handler\"\n            });\n        }\n        return handler;\n    }\n    if (true) {\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(handler, \"function\", {\n            moduleName: \"@serwist/routing\",\n            className: \"Route\",\n            funcName: \"constructor\",\n            paramName: \"handler\"\n        });\n    }\n    return {\n        handle: handler\n    };\n};\n\nclass Route {\n    handler;\n    match;\n    method;\n    catchHandler;\n    constructor(match, handler, method = defaultMethod){\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(match, \"function\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"match\"\n            });\n            if (method) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isOneOf(method, validMethods, {\n                    paramName: \"method\"\n                });\n            }\n        }\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n    setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n    }\n}\n\nclass RegExpRoute extends Route {\n    constructor(regExp, handler, method){\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(regExp, RegExp, {\n                moduleName: \"@serwist/routing\",\n                className: \"RegExpRoute\",\n                funcName: \"constructor\",\n                paramName: \"pattern\"\n            });\n        }\n        const match = ({ url })=>{\n            const result = regExp.exec(url.href);\n            if (!result) {\n                return;\n            }\n            if (url.origin !== location.origin && result.index !== 0) {\n                if (true) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`The regular expression '${regExp.toString()}' only partially matched against the cross-origin URL '${url.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\n\nconst parseRoute = (capture, handler, method)=>{\n    let route;\n    if (typeof capture === \"string\") {\n        const captureUrl = new URL(capture, location.href);\n        if (true) {\n            if (!(capture.startsWith(\"/\") || capture.startsWith(\"http\"))) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"invalid-string\", {\n                    moduleName: \"@serwist/routing\",\n                    funcName: \"registerRoute\",\n                    paramName: \"capture\"\n                });\n            }\n            const valueToCheck = capture.startsWith(\"http\") ? captureUrl.pathname : capture;\n            const wildcards = \"[*:?+]\";\n            if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`The '$capture' parameter contains an Express-style wildcard character (${wildcards}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url })=>{\n            if (true) {\n                if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`${capture} only partially matches the cross-origin URL ${url.toString()}. This route will only handle cross-origin requests if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        route = new Route(matchCallback, handler, method);\n    } else if (capture instanceof RegExp) {\n        route = new RegExpRoute(capture, handler, method);\n    } else if (typeof capture === \"function\") {\n        route = new Route(capture, handler, method);\n    } else if (capture instanceof Route) {\n        route = capture;\n    } else {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"unsupported-route-type\", {\n            moduleName: \"@serwist/routing\",\n            funcName: \"registerRoute\",\n            paramName: \"capture\"\n        });\n    }\n    return route;\n};\n\nclass Router {\n    _routes;\n    _defaultHandlerMap;\n    _fetchListenerHandler = null;\n    _cacheListenerHandler = null;\n    _catchHandler;\n    constructor(){\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n    }\n    get routes() {\n        return this._routes;\n    }\n    addFetchListener() {\n        if (!this._fetchListenerHandler) {\n            this._fetchListenerHandler = (event)=>{\n                const { request } = event;\n                const responsePromise = this.handleRequest({\n                    request,\n                    event\n                });\n                if (responsePromise) {\n                    event.respondWith(responsePromise);\n                }\n            };\n            self.addEventListener(\"fetch\", this._fetchListenerHandler);\n        }\n    }\n    removeFetchListener() {\n        if (this._fetchListenerHandler) {\n            self.removeEventListener(\"fetch\", this._fetchListenerHandler);\n            this._fetchListenerHandler = null;\n        }\n    }\n    addCacheListener() {\n        if (!this._cacheListenerHandler) {\n            this._cacheListenerHandler = (event)=>{\n                if (event.data && event.data.type === \"CACHE_URLS\") {\n                    const { payload } = event.data;\n                    if (true) {\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(\"Caching URLs from the window\", payload.urlsToCache);\n                    }\n                    const requestPromises = Promise.all(payload.urlsToCache.map((entry)=>{\n                        if (typeof entry === \"string\") {\n                            entry = [\n                                entry\n                            ];\n                        }\n                        const request = new Request(...entry);\n                        return this.handleRequest({\n                            request,\n                            event\n                        });\n                    }));\n                    event.waitUntil(requestPromises);\n                    if (event.ports?.[0]) {\n                        void requestPromises.then(()=>event.ports[0].postMessage(true));\n                    }\n                }\n            };\n            self.addEventListener(\"message\", this._cacheListenerHandler);\n        }\n    }\n    removeCacheListener() {\n        if (this._cacheListenerHandler) {\n            self.removeEventListener(\"message\", this._cacheListenerHandler);\n        }\n    }\n    handleRequest({ request, event }) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/routing\",\n                className: \"Router\",\n                funcName: \"handleRequest\",\n                paramName: \"options.request\"\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith(\"http\")) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(\"Router only supports URLs that start with 'http'.\");\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url\n        });\n        let handler = route?.handler;\n        const debugMessages = [];\n        if (true) {\n            if (handler) {\n                debugMessages.push([\n                    \"Found a route to handle this request:\",\n                    route\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params\n                    ]);\n                }\n            }\n        }\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (true) {\n                debugMessages.push(`Failed to find a matching route. Falling back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.debug(`No route found for: ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url)}`);\n            }\n            return;\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`Router is responding to: ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url)}`);\n            for (const msg of debugMessages){\n                if (Array.isArray(msg)) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(...msg);\n                } else {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(msg);\n                }\n            }\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({\n                url,\n                request,\n                event,\n                params\n            });\n        } catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        const catchHandler = route?.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err)=>{\n                if (catchHandler) {\n                    if (true) {\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`Error thrown when responding to:  ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url)}. Falling back to route's Catch Handler.`);\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Error thrown by:\", route);\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.error(err);\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({\n                            url,\n                            request,\n                            event,\n                            params\n                        });\n                    } catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (true) {\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(`Error thrown when responding to:  ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url)}. Falling back to global Catch Handler.`);\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.error(\"Error thrown by:\", route);\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.error(err);\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n                    }\n                    return this._catchHandler.handle({\n                        url,\n                        request,\n                        event\n                    });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    findMatchingRoute({ url, sameOrigin, request, event }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes){\n            let params;\n            const matchResult = route.match({\n                url,\n                sameOrigin,\n                request,\n                event\n            });\n            if (matchResult) {\n                if (true) {\n                    if (matchResult instanceof Promise) {\n                        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.warn(`While routing ${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.getFriendlyURL)(url)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    params = undefined;\n                } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n                    params = undefined;\n                } else if (typeof matchResult === \"boolean\") {\n                    params = undefined;\n                }\n                return {\n                    route,\n                    params\n                };\n            }\n        }\n        return {};\n    }\n    setDefaultHandler(handler, method = defaultMethod) {\n        this._defaultHandlerMap.set(method, normalizeHandler(handler));\n    }\n    setCatchHandler(handler) {\n        this._catchHandler = normalizeHandler(handler);\n    }\n    registerCapture(capture, handler, method) {\n        const route = parseRoute(capture, handler, method);\n        this.registerRoute(route);\n        return route;\n    }\n    registerRoute(route) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(route, \"object\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Router\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.hasMethod(route, \"match\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Router\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(route.handler, \"object\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Router\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.hasMethod(route.handler, \"handle\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Router\",\n                funcName: \"registerRoute\",\n                paramName: \"route.handler\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isType(route.method, \"string\", {\n                moduleName: \"@serwist/routing\",\n                className: \"Router\",\n                funcName: \"registerRoute\",\n                paramName: \"route.method\"\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        this._routes.get(route.method).push(route);\n    }\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"unregister-route-but-not-found-with-method\", {\n                method: route.method\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"unregister-route-route-not-registered\");\n        }\n    }\n}\n\nlet defaultRouter = undefined;\nconst getSingletonRouter = ()=>{\n    if (!defaultRouter) {\n        defaultRouter = new Router();\n        defaultRouter.addFetchListener();\n        defaultRouter.addCacheListener();\n    }\n    return defaultRouter;\n};\nconst setSingletonRouter = (router)=>{\n    if (defaultRouter) {\n        defaultRouter.removeFetchListener();\n        defaultRouter.removeCacheListener();\n    }\n    defaultRouter = router;\n    defaultRouter.addFetchListener();\n    defaultRouter.addCacheListener();\n    return defaultRouter;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9zaW5nbGV0b25Sb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzRjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QyxRQUFRLDBEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBcUM7QUFDekQsb0JBQW9CLDBEQUFNLGtDQUFrQyxrQkFBa0IseURBQXlELGVBQWU7QUFDdEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQSwwQkFBMEIsZ0VBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlC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QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQixJQUFxQztBQUN6RDtBQUNBLHdCQUF3QiwwREFBTSx1QkFBdUIsc0VBQWMsTUFBTTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzQkFBc0IsZ0VBQVk7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2NodW5rcy9zaW5nbGV0b25Sb3V0ZXIuanM/Mzg2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIGxvZ2dlciwgU2Vyd2lzdEVycm9yLCBnZXRGcmllbmRseVVSTCB9IGZyb20gJ0BzZXJ3aXN0L2NvcmUvaW50ZXJuYWwnO1xuXG5jb25zdCBkZWZhdWx0TWV0aG9kID0gXCJHRVRcIjtcbmNvbnN0IHZhbGlkTWV0aG9kcyA9IFtcbiAgICBcIkRFTEVURVwiLFxuICAgIFwiR0VUXCIsXG4gICAgXCJIRUFEXCIsXG4gICAgXCJQQVRDSFwiLFxuICAgIFwiUE9TVFwiLFxuICAgIFwiUFVUXCJcbl07XG5cbmNvbnN0IG5vcm1hbGl6ZUhhbmRsZXIgPSAoaGFuZGxlcik9PntcbiAgICBpZiAoaGFuZGxlciAmJiB0eXBlb2YgaGFuZGxlciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuaGFzTWV0aG9kKGhhbmRsZXIsIFwiaGFuZGxlXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JvdXRpbmdcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUm91dGVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJoYW5kbGVyXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGFzc2VydC5pc1R5cGUoaGFuZGxlciwgXCJmdW5jdGlvblwiLCB7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JvdXRpbmdcIixcbiAgICAgICAgICAgIGNsYXNzTmFtZTogXCJSb3V0ZVwiLFxuICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgIHBhcmFtTmFtZTogXCJoYW5kbGVyXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhhbmRsZTogaGFuZGxlclxuICAgIH07XG59O1xuXG5jbGFzcyBSb3V0ZSB7XG4gICAgaGFuZGxlcjtcbiAgICBtYXRjaDtcbiAgICBtZXRob2Q7XG4gICAgY2F0Y2hIYW5kbGVyO1xuICAgIGNvbnN0cnVjdG9yKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QgPSBkZWZhdWx0TWV0aG9kKXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShtYXRjaCwgXCJmdW5jdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yb3V0aW5nXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJvdXRlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwibWF0Y2hcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzT25lT2YobWV0aG9kLCB2YWxpZE1ldGhvZHMsIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm1ldGhvZFwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVyID0gbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICB9XG4gICAgc2V0Q2F0Y2hIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5jYXRjaEhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbn1cblxuY2xhc3MgUmVnRXhwUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgY29uc3RydWN0b3IocmVnRXhwLCBoYW5kbGVyLCBtZXRob2Qpe1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZWdFeHAsIFJlZ0V4cCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvcm91dGluZ1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJSZWdFeHBSb3V0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInBhdHRlcm5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSk9PntcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZ0V4cC5leGVjKHVybC5ocmVmKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVybC5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbiAmJiByZXN1bHQuaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnJHtyZWdFeHAudG9TdHJpbmcoKX0nIG9ubHkgcGFydGlhbGx5IG1hdGNoZWQgYWdhaW5zdCB0aGUgY3Jvc3Mtb3JpZ2luIFVSTCAnJHt1cmwudG9TdHJpbmcoKX0nLiBSZWdFeHBSb3V0ZSdzIHdpbGwgb25seSBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGlmIHRoZXkgbWF0Y2ggdGhlIGVudGlyZSBVUkwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2xpY2UoMSk7XG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QpO1xuICAgIH1cbn1cblxuY29uc3QgcGFyc2VSb3V0ZSA9IChjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpPT57XG4gICAgbGV0IHJvdXRlO1xuICAgIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBjYXB0dXJlVXJsID0gbmV3IFVSTChjYXB0dXJlLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCEoY2FwdHVyZS5zdGFydHNXaXRoKFwiL1wiKSB8fCBjYXB0dXJlLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJpbnZhbGlkLXN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvcm91dGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjYXB0dXJlXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlVG9DaGVjayA9IGNhcHR1cmUuc3RhcnRzV2l0aChcImh0dHBcIikgPyBjYXB0dXJlVXJsLnBhdGhuYW1lIDogY2FwdHVyZTtcbiAgICAgICAgICAgIGNvbnN0IHdpbGRjYXJkcyA9IFwiWyo6PytdXCI7XG4gICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChgJHt3aWxkY2FyZHN9YCkuZXhlYyh2YWx1ZVRvQ2hlY2spKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgJyRjYXB0dXJlJyBwYXJhbWV0ZXIgY29udGFpbnMgYW4gRXhwcmVzcy1zdHlsZSB3aWxkY2FyZCBjaGFyYWN0ZXIgKCR7d2lsZGNhcmRzfSkuIFN0cmluZ3MgYXJlIG5vdyBhbHdheXMgaW50ZXJwcmV0ZWQgYXMgZXhhY3QgbWF0Y2hlczsgdXNlIGEgUmVnRXhwIGZvciBwYXJ0aWFsIG9yIHdpbGRjYXJkIG1hdGNoZXMuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF0Y2hDYWxsYmFjayA9ICh7IHVybCB9KT0+e1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICh1cmwucGF0aG5hbWUgPT09IGNhcHR1cmVVcmwucGF0aG5hbWUgJiYgdXJsLm9yaWdpbiAhPT0gY2FwdHVyZVVybC5vcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGAke2NhcHR1cmV9IG9ubHkgcGFydGlhbGx5IG1hdGNoZXMgdGhlIGNyb3NzLW9yaWdpbiBVUkwgJHt1cmwudG9TdHJpbmcoKX0uIFRoaXMgcm91dGUgd2lsbCBvbmx5IGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXJsLmhyZWYgPT09IGNhcHR1cmVVcmwuaHJlZjtcbiAgICAgICAgfTtcbiAgICAgICAgcm91dGUgPSBuZXcgUm91dGUobWF0Y2hDYWxsYmFjaywgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcm91dGUgPSBuZXcgUmVnRXhwUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjYXB0dXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcm91dGUgPSBuZXcgUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSb3V0ZSkge1xuICAgICAgICByb3V0ZSA9IGNhcHR1cmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInVuc3VwcG9ydGVkLXJvdXRlLXR5cGVcIiwge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yb3V0aW5nXCIsXG4gICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICBwYXJhbU5hbWU6IFwiY2FwdHVyZVwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGU7XG59O1xuXG5jbGFzcyBSb3V0ZXIge1xuICAgIF9yb3V0ZXM7XG4gICAgX2RlZmF1bHRIYW5kbGVyTWFwO1xuICAgIF9mZXRjaExpc3RlbmVySGFuZGxlciA9IG51bGw7XG4gICAgX2NhY2hlTGlzdGVuZXJIYW5kbGVyID0gbnVsbDtcbiAgICBfY2F0Y2hIYW5kbGVyO1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuX3JvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCByb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXM7XG4gICAgfVxuICAgIGFkZEZldGNoTGlzdGVuZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmV0Y2hMaXN0ZW5lckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZldGNoTGlzdGVuZXJIYW5kbGVyID0gKGV2ZW50KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdCB9ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5oYW5kbGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnJlc3BvbmRXaXRoKHJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImZldGNoXCIsIHRoaXMuX2ZldGNoTGlzdGVuZXJIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVGZXRjaExpc3RlbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fZmV0Y2hMaXN0ZW5lckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZldGNoXCIsIHRoaXMuX2ZldGNoTGlzdGVuZXJIYW5kbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX2ZldGNoTGlzdGVuZXJIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDYWNoZUxpc3RlbmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlTGlzdGVuZXJIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZUxpc3RlbmVySGFuZGxlciA9IChldmVudCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUgPT09IFwiQ0FDSEVfVVJMU1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2FjaGluZyBVUkxzIGZyb20gdGhlIHdpbmRvd1wiLCBwYXlsb2FkLnVybHNUb0NhY2hlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0UHJvbWlzZXMgPSBQcm9taXNlLmFsbChwYXlsb2FkLnVybHNUb0NhY2hlLm1hcCgoZW50cnkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW50cnkgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudHJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdCguLi5lbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC53YWl0VW50aWwocmVxdWVzdFByb21pc2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvcnRzPy5bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgcmVxdWVzdFByb21pc2VzLnRoZW4oKCk9PmV2ZW50LnBvcnRzWzBdLnBvc3RNZXNzYWdlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX2NhY2hlTGlzdGVuZXJIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYWNoZUxpc3RlbmVyKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVMaXN0ZW5lckhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fY2FjaGVMaXN0ZW5lckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVJlcXVlc3QoeyByZXF1ZXN0LCBldmVudCB9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JvdXRpbmdcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUm91dGVyXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiaGFuZGxlUmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJvcHRpb25zLnJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmICghdXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUm91dGVyIG9ubHkgc3VwcG9ydHMgVVJMcyB0aGF0IHN0YXJ0IHdpdGggJ2h0dHAnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1lT3JpZ2luID0gdXJsLm9yaWdpbiA9PT0gbG9jYXRpb24ub3JpZ2luO1xuICAgICAgICBjb25zdCB7IHBhcmFtcywgcm91dGUgfSA9IHRoaXMuZmluZE1hdGNoaW5nUm91dGUoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgc2FtZU9yaWdpbixcbiAgICAgICAgICAgIHVybFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSByb3V0ZT8uaGFuZGxlcjtcbiAgICAgICAgY29uc3QgZGVidWdNZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIFwiRm91bmQgYSByb3V0ZSB0byBoYW5kbGUgdGhpcyByZXF1ZXN0OlwiLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBQYXNzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1zIHRvIHRoZSByb3V0ZSdzIGhhbmRsZXI6YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIGlmICghaGFuZGxlciAmJiB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5oYXMobWV0aG9kKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChgRmFpbGVkIHRvIGZpbmQgYSBtYXRjaGluZyByb3V0ZS4gRmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IGhhbmRsZXIgZm9yICR7bWV0aG9kfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5nZXQobWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIHJvdXRlIGZvdW5kIGZvcjogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUm91dGVyIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXNnIG9mIGRlYnVnTWVzc2FnZXMpe1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyguLi5tc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gaGFuZGxlci5oYW5kbGUoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXRjaEhhbmRsZXIgPSByb3V0ZT8uY2F0Y2hIYW5kbGVyO1xuICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiAodGhpcy5fY2F0Y2hIYW5kbGVyIHx8IGNhdGNoSGFuZGxlcikpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZS5jYXRjaChhc3luYyAoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGlmIChjYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIHJvdXRlJ3MgQ2F0Y2ggSGFuZGxlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHRocm93biBieTpcIiwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhdGNoSGFuZGxlci5oYW5kbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGNhdGNoRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hFcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGNhdGNoRXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIGdsb2JhbCBDYXRjaCBIYW5kbGVyLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdGhyb3duIGJ5OlwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRjaEhhbmRsZXIuaGFuZGxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9XG4gICAgZmluZE1hdGNoaW5nUm91dGUoeyB1cmwsIHNhbWVPcmlnaW4sIHJlcXVlc3QsIGV2ZW50IH0pIHtcbiAgICAgICAgY29uc3Qgcm91dGVzID0gdGhpcy5fcm91dGVzLmdldChyZXF1ZXN0Lm1ldGhvZCkgfHwgW107XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKXtcbiAgICAgICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHJvdXRlLm1hdGNoKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgc2FtZU9yaWdpbixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFdoaWxlIHJvdXRpbmcgJHtnZXRGcmllbmRseVVSTCh1cmwpfSwgYW4gYXN5bmMgbWF0Y2hDYWxsYmFjayBmdW5jdGlvbiB3YXMgdXNlZC4gUGxlYXNlIGNvbnZlcnQgdGhlIGZvbGxvd2luZyByb3V0ZSB0byB1c2UgYSBzeW5jaHJvbm91cyBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uOmAsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBtYXRjaFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hSZXN1bHQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3Qua2V5cyhtYXRjaFJlc3VsdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaFJlc3VsdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHNldERlZmF1bHRIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuc2V0KG1ldGhvZCwgbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKSk7XG4gICAgfVxuICAgIHNldENhdGNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2NhdGNoSGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2FwdHVyZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBwYXJzZVJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG4gICAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHJvdXRlLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yb3V0aW5nXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJvdXRlclwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaGFzTWV0aG9kKHJvdXRlLCBcIm1hdGNoXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JvdXRpbmdcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUm91dGVyXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwicmVnaXN0ZXJSb3V0ZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyb3V0ZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocm91dGUuaGFuZGxlciwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvcm91dGluZ1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJSb3V0ZXJcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJvdXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0Lmhhc01ldGhvZChyb3V0ZS5oYW5kbGVyLCBcImhhbmRsZVwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yb3V0aW5nXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJvdXRlclwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGUuaGFuZGxlclwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc1R5cGUocm91dGUubWV0aG9kLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9yb3V0aW5nXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJvdXRlclwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyUm91dGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicm91dGUubWV0aG9kXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcm91dGVzLmhhcyhyb3V0ZS5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZXMuc2V0KHJvdXRlLm1ldGhvZCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5wdXNoKHJvdXRlKTtcbiAgICB9XG4gICAgdW5yZWdpc3RlclJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm91dGVzLmhhcyhyb3V0ZS5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwidW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kXCIsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJvdXRlLm1ldGhvZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVJbmRleCA9IHRoaXMuX3JvdXRlcy5nZXQocm91dGUubWV0aG9kKS5pbmRleE9mKHJvdXRlKTtcbiAgICAgICAgaWYgKHJvdXRlSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLmdldChyb3V0ZS5tZXRob2QpLnNwbGljZShyb3V0ZUluZGV4LCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJ1bnJlZ2lzdGVyLXJvdXRlLXJvdXRlLW5vdC1yZWdpc3RlcmVkXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5sZXQgZGVmYXVsdFJvdXRlciA9IHVuZGVmaW5lZDtcbmNvbnN0IGdldFNpbmdsZXRvblJvdXRlciA9ICgpPT57XG4gICAgaWYgKCFkZWZhdWx0Um91dGVyKSB7XG4gICAgICAgIGRlZmF1bHRSb3V0ZXIgPSBuZXcgUm91dGVyKCk7XG4gICAgICAgIGRlZmF1bHRSb3V0ZXIuYWRkRmV0Y2hMaXN0ZW5lcigpO1xuICAgICAgICBkZWZhdWx0Um91dGVyLmFkZENhY2hlTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRSb3V0ZXI7XG59O1xuY29uc3Qgc2V0U2luZ2xldG9uUm91dGVyID0gKHJvdXRlcik9PntcbiAgICBpZiAoZGVmYXVsdFJvdXRlcikge1xuICAgICAgICBkZWZhdWx0Um91dGVyLnJlbW92ZUZldGNoTGlzdGVuZXIoKTtcbiAgICAgICAgZGVmYXVsdFJvdXRlci5yZW1vdmVDYWNoZUxpc3RlbmVyKCk7XG4gICAgfVxuICAgIGRlZmF1bHRSb3V0ZXIgPSByb3V0ZXI7XG4gICAgZGVmYXVsdFJvdXRlci5hZGRGZXRjaExpc3RlbmVyKCk7XG4gICAgZGVmYXVsdFJvdXRlci5hZGRDYWNoZUxpc3RlbmVyKCk7XG4gICAgcmV0dXJuIGRlZmF1bHRSb3V0ZXI7XG59O1xuXG5leHBvcnQgeyBSb3V0ZSBhcyBSLCBSZWdFeHBSb3V0ZSBhcyBhLCBSb3V0ZXIgYXMgYiwgZ2V0U2luZ2xldG9uUm91dGVyIGFzIGcsIHBhcnNlUm91dGUgYXMgcCwgc2V0U2luZ2xldG9uUm91dGVyIGFzIHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonRouter.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.plugins.js":
/*!*************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.plugins.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BROADCAST_UPDATE_DEFAULT_HEADERS: function() { return /* binding */ defaultHeadersToCheck; },\n/* harmony export */   BROADCAST_UPDATE_MESSAGE_META: function() { return /* binding */ CACHE_UPDATED_MESSAGE_META; },\n/* harmony export */   BROADCAST_UPDATE_MESSAGE_TYPE: function() { return /* binding */ CACHE_UPDATED_MESSAGE_TYPE; },\n/* harmony export */   BackgroundSyncPlugin: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__.B; },\n/* harmony export */   BackgroundSyncQueue: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__.Q; },\n/* harmony export */   BackgroundSyncQueueStore: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__.a; },\n/* harmony export */   BroadcastCacheUpdate: function() { return /* binding */ BroadcastCacheUpdate; },\n/* harmony export */   BroadcastUpdatePlugin: function() { return /* binding */ BroadcastUpdatePlugin; },\n/* harmony export */   CacheExpiration: function() { return /* binding */ CacheExpiration; },\n/* harmony export */   CacheableResponse: function() { return /* binding */ CacheableResponse; },\n/* harmony export */   CacheableResponsePlugin: function() { return /* binding */ CacheableResponsePlugin; },\n/* harmony export */   ExpirationPlugin: function() { return /* binding */ ExpirationPlugin; },\n/* harmony export */   PrecacheFallbackPlugin: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__.P; },\n/* harmony export */   RangeRequestsPlugin: function() { return /* binding */ RangeRequestsPlugin; },\n/* harmony export */   StorableRequest: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__.S; },\n/* harmony export */   createPartialResponse: function() { return /* binding */ createPartialResponse; },\n/* harmony export */   initializeGoogleAnalytics: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__.i; },\n/* harmony export */   responsesAreSame: function() { return /* binding */ responsesAreSame; }\n/* harmony export */ });\n/* harmony import */ var _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/PrecacheFallbackPlugin.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/PrecacheFallbackPlugin.js\");\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! idb */ \"./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js\");\n/* harmony import */ var _serwist_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @serwist/core */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.js\");\n/* harmony import */ var _chunks_singletonRouter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunks/singletonRouter.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonRouter.js\");\n/* harmony import */ var _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunks/NetworkOnly.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/NetworkOnly.js\");\n/* harmony import */ var _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunks/Strategy.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js\");\n/* harmony import */ var _chunks_singletonPrecacheController_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chunks/singletonPrecacheController.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/singletonPrecacheController.js\");\n\n\n\n\n\n\n\n\n\nconst CACHE_UPDATED_MESSAGE_TYPE = \"CACHE_UPDATED\";\nconst CACHE_UPDATED_MESSAGE_META = \"serwist-broadcast-update\";\nconst defaultNotifyAllClients = true;\nconst defaultHeadersToCheck = [\n    \"content-length\",\n    \"etag\",\n    \"last-modified\"\n];\n\nconst responsesAreSame = (firstResponse, secondResponse, headersToCheck)=>{\n    if (true) {\n        if (!(firstResponse instanceof Response && secondResponse instanceof Response)) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"invalid-responses-are-same-args\");\n        }\n    }\n    const atLeastOneHeaderAvailable = headersToCheck.some((header)=>{\n        return firstResponse.headers.has(header) && secondResponse.headers.has(header);\n    });\n    if (!atLeastOneHeaderAvailable) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"Unable to determine where the response has been updated because none of the headers that would be checked are present.\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.debug(\"Attempting to compare the following: \", firstResponse, secondResponse, headersToCheck);\n        }\n        return true;\n    }\n    return headersToCheck.every((header)=>{\n        const headerStateComparison = firstResponse.headers.has(header) === secondResponse.headers.has(header);\n        const headerValueComparison = firstResponse.headers.get(header) === secondResponse.headers.get(header);\n        return headerStateComparison && headerValueComparison;\n    });\n};\n\nconst isSafari = typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\nconst defaultPayloadGenerator = (data)=>{\n    return {\n        cacheName: data.cacheName,\n        updatedURL: data.request.url\n    };\n};\nclass BroadcastCacheUpdate {\n    _headersToCheck;\n    _generatePayload;\n    _notifyAllClients;\n    constructor({ generatePayload, headersToCheck, notifyAllClients } = {}){\n        this._headersToCheck = headersToCheck || defaultHeadersToCheck;\n        this._generatePayload = generatePayload || defaultPayloadGenerator;\n        this._notifyAllClients = notifyAllClients ?? defaultNotifyAllClients;\n    }\n    async notifyIfUpdated(options) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(options.cacheName, \"string\", {\n                moduleName: \"@serwist/broadcast-update\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"cacheName\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(options.newResponse, Response, {\n                moduleName: \"@serwist/broadcast-update\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"newResponse\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(options.request, Request, {\n                moduleName: \"@serwist/broadcast-update\",\n                className: \"BroadcastCacheUpdate\",\n                funcName: \"notifyIfUpdated\",\n                paramName: \"request\"\n            });\n        }\n        if (!options.oldResponse) {\n            return;\n        }\n        if (!responsesAreSame(options.oldResponse, options.newResponse, this._headersToCheck)) {\n            if (true) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(\"Newer response found (and cached) for:\", options.request.url);\n            }\n            const messageData = {\n                type: CACHE_UPDATED_MESSAGE_TYPE,\n                meta: CACHE_UPDATED_MESSAGE_META,\n                payload: this._generatePayload(options)\n            };\n            if (options.request.mode === \"navigate\") {\n                let resultingClientId;\n                if (options.event instanceof FetchEvent) {\n                    resultingClientId = options.event.resultingClientId;\n                }\n                const resultingWin = await (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.resultingClientExists)(resultingClientId);\n                if (!resultingWin || isSafari) {\n                    await (0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.timeout)(3500);\n                }\n            }\n            if (this._notifyAllClients) {\n                const windows = await self.clients.matchAll({\n                    type: \"window\"\n                });\n                for (const win of windows){\n                    win.postMessage(messageData);\n                }\n            } else {\n                if (options.event instanceof FetchEvent) {\n                    const client = await self.clients.get(options.event.clientId);\n                    client?.postMessage(messageData);\n                }\n            }\n        }\n    }\n}\n\nclass BroadcastUpdatePlugin {\n    _broadcastUpdate;\n    constructor(options){\n        this._broadcastUpdate = new BroadcastCacheUpdate(options);\n    }\n    cacheDidUpdate(options) {\n        void this._broadcastUpdate.notifyIfUpdated(options);\n    }\n}\n\nclass CacheableResponse {\n    _statuses;\n    _headers;\n    constructor(config = {}){\n        if (true) {\n            if (!(config.statuses || config.headers)) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"statuses-or-headers-required\", {\n                    moduleName: \"@serwist/cacheable-response\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.statuses) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isArray(config.statuses, {\n                    moduleName: \"@serwist/cacheable-response\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\",\n                    paramName: \"config.statuses\"\n                });\n            }\n            if (config.headers) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(config.headers, \"object\", {\n                    moduleName: \"@serwist/cacheable-response\",\n                    className: \"CacheableResponse\",\n                    funcName: \"constructor\",\n                    paramName: \"config.headers\"\n                });\n            }\n        }\n        this._statuses = config.statuses;\n        if (config.headers) {\n            this._headers = new Headers(config.headers);\n        }\n    }\n    isResponseCacheable(response) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(response, Response, {\n                moduleName: \"@serwist/cacheable-response\",\n                className: \"CacheableResponse\",\n                funcName: \"isResponseCacheable\",\n                paramName: \"response\"\n            });\n        }\n        let cacheable = true;\n        if (this._statuses) {\n            cacheable = this._statuses.includes(response.status);\n        }\n        if (this._headers && cacheable) {\n            for (const [headerName, headerValue] of this._headers.entries()){\n                if (response.headers.get(headerName) !== headerValue) {\n                    cacheable = false;\n                    break;\n                }\n            }\n        }\n        if (true) {\n            if (!cacheable) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupCollapsed(`The request for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.getFriendlyURL)(response.url)}' returned a response that does not meet the criteria for being cached.`);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupCollapsed(\"View cacheability criteria here.\");\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Cacheable statuses: ${JSON.stringify(this._statuses)}`);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Cacheable headers: ${JSON.stringify(this._headers, null, 2)}`);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupEnd();\n                const logFriendlyHeaders = {};\n                response.headers.forEach((value, key)=>{\n                    logFriendlyHeaders[key] = value;\n                });\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupCollapsed(\"View response status and headers here.\");\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Response status: ${response.status}`);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Response headers: ${JSON.stringify(logFriendlyHeaders, null, 2)}`);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupEnd();\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupCollapsed(\"View full response details here.\");\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(response.headers);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(response);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupEnd();\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupEnd();\n            }\n        }\n        return cacheable;\n    }\n}\n\nclass CacheableResponsePlugin {\n    _cacheableResponse;\n    constructor(config){\n        this._cacheableResponse = new CacheableResponse(config);\n    }\n    cacheWillUpdate = async ({ response })=>{\n        if (this._cacheableResponse.isResponseCacheable(response)) {\n            return response;\n        }\n        return null;\n    };\n}\n\nconst DB_NAME = \"serwist-expiration\";\nconst CACHE_OBJECT_STORE = \"cache-entries\";\nconst normalizeURL = (unNormalizedUrl)=>{\n    const url = new URL(unNormalizedUrl, location.href);\n    url.hash = \"\";\n    return url.href;\n};\nclass CacheTimestampsModel {\n    _cacheName;\n    _db = null;\n    constructor(cacheName){\n        this._cacheName = cacheName;\n    }\n    _getId(url) {\n        return `${this._cacheName}|${normalizeURL(url)}`;\n    }\n    _upgradeDb(db) {\n        const objStore = db.createObjectStore(CACHE_OBJECT_STORE, {\n            keyPath: \"id\"\n        });\n        objStore.createIndex(\"cacheName\", \"cacheName\", {\n            unique: false\n        });\n        objStore.createIndex(\"timestamp\", \"timestamp\", {\n            unique: false\n        });\n    }\n    _upgradeDbAndDeleteOldDbs(db) {\n        this._upgradeDb(db);\n        if (this._cacheName) {\n            void (0,idb__WEBPACK_IMPORTED_MODULE_2__.deleteDB)(this._cacheName);\n        }\n    }\n    async setTimestamp(url, timestamp) {\n        url = normalizeURL(url);\n        const entry = {\n            id: this._getId(url),\n            cacheName: this._cacheName,\n            url,\n            timestamp\n        };\n        const db = await this.getDb();\n        const tx = db.transaction(CACHE_OBJECT_STORE, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.put(entry);\n        await tx.done;\n    }\n    async getTimestamp(url) {\n        const db = await this.getDb();\n        const entry = await db.get(CACHE_OBJECT_STORE, this._getId(url));\n        return entry?.timestamp;\n    }\n    async expireEntries(minTimestamp, maxCount) {\n        const db = await this.getDb();\n        let cursor = await db.transaction(CACHE_OBJECT_STORE, \"readwrite\").store.index(\"timestamp\").openCursor(null, \"prev\");\n        const urlsDeleted = [];\n        let entriesNotDeletedCount = 0;\n        while(cursor){\n            const result = cursor.value;\n            if (result.cacheName === this._cacheName) {\n                if (minTimestamp && result.timestamp < minTimestamp || maxCount && entriesNotDeletedCount >= maxCount) {\n                    cursor.delete();\n                    urlsDeleted.push(result.url);\n                } else {\n                    entriesNotDeletedCount++;\n                }\n            }\n            cursor = await cursor.continue();\n        }\n        return urlsDeleted;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await (0,idb__WEBPACK_IMPORTED_MODULE_2__.openDB)(DB_NAME, 1, {\n                upgrade: this._upgradeDbAndDeleteOldDbs.bind(this)\n            });\n        }\n        return this._db;\n    }\n}\n\nclass CacheExpiration {\n    _isRunning = false;\n    _rerunRequested = false;\n    _maxEntries;\n    _maxAgeSeconds;\n    _matchOptions;\n    _cacheName;\n    _timestampModel;\n    constructor(cacheName, config = {}){\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(cacheName, \"string\", {\n                moduleName: \"@serwist/expiration\",\n                className: \"CacheExpiration\",\n                funcName: \"constructor\",\n                paramName: \"cacheName\"\n            });\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"max-entries-or-age-required\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.maxEntries) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(config.maxEntries, \"number\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxEntries\"\n                });\n            }\n            if (config.maxAgeSeconds) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(config.maxAgeSeconds, \"number\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"CacheExpiration\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeSeconds\"\n                });\n            }\n        }\n        this._maxEntries = config.maxEntries;\n        this._maxAgeSeconds = config.maxAgeSeconds;\n        this._matchOptions = config.matchOptions;\n        this._cacheName = cacheName;\n        this._timestampModel = new CacheTimestampsModel(cacheName);\n    }\n    async expireEntries() {\n        if (this._isRunning) {\n            this._rerunRequested = true;\n            return;\n        }\n        this._isRunning = true;\n        const minTimestamp = this._maxAgeSeconds ? Date.now() - this._maxAgeSeconds * 1000 : 0;\n        const urlsExpired = await this._timestampModel.expireEntries(minTimestamp, this._maxEntries);\n        const cache = await self.caches.open(this._cacheName);\n        for (const url of urlsExpired){\n            await cache.delete(url, this._matchOptions);\n        }\n        if (true) {\n            if (urlsExpired.length > 0) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupCollapsed(`Expired ${urlsExpired.length} ` + `${urlsExpired.length === 1 ? \"entry\" : \"entries\"} and removed ` + `${urlsExpired.length === 1 ? \"it\" : \"them\"} from the ` + `'${this._cacheName}' cache.`);\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(`Expired the following ${urlsExpired.length === 1 ? \"URL\" : \"URLs\"}:`);\n                for (const url of urlsExpired){\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(`    ${url}`);\n                }\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupEnd();\n            } else {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.debug(\"Cache expiration ran and found no entries to remove.\");\n            }\n        }\n        this._isRunning = false;\n        if (this._rerunRequested) {\n            this._rerunRequested = false;\n            void this.expireEntries();\n        }\n    }\n    async updateTimestamp(url) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(url, \"string\", {\n                moduleName: \"@serwist/expiration\",\n                className: \"CacheExpiration\",\n                funcName: \"updateTimestamp\",\n                paramName: \"url\"\n            });\n        }\n        await this._timestampModel.setTimestamp(url, Date.now());\n    }\n    async isURLExpired(url) {\n        if (!this._maxAgeSeconds) {\n            if (true) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"expired-test-without-max-age\", {\n                    methodName: \"isURLExpired\",\n                    paramName: \"maxAgeSeconds\"\n                });\n            }\n            return false;\n        }\n        const timestamp = await this._timestampModel.getTimestamp(url);\n        const expireOlderThan = Date.now() - this._maxAgeSeconds * 1000;\n        return timestamp !== undefined ? timestamp < expireOlderThan : true;\n    }\n    async delete() {\n        this._rerunRequested = false;\n        await this._timestampModel.expireEntries(Number.POSITIVE_INFINITY);\n    }\n}\n\nclass ExpirationPlugin {\n    _config;\n    _cacheExpirations;\n    constructor(config = {}){\n        if (true) {\n            if (!(config.maxEntries || config.maxAgeSeconds)) {\n                throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"max-entries-or-age-required\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\"\n                });\n            }\n            if (config.maxEntries) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(config.maxEntries, \"number\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxEntries\"\n                });\n            }\n            if (config.maxAgeSeconds) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(config.maxAgeSeconds, \"number\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeSeconds\"\n                });\n            }\n            if (config.maxAgeFrom) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(config.maxAgeFrom, \"string\", {\n                    moduleName: \"@serwist/expiration\",\n                    className: \"ExpirationPlugin\",\n                    funcName: \"constructor\",\n                    paramName: \"config.maxAgeFrom\"\n                });\n            }\n        }\n        this._config = config;\n        this._cacheExpirations = new Map();\n        if (!this._config.maxAgeFrom) {\n            this._config.maxAgeFrom = \"last-fetched\";\n        }\n        if (this._config.purgeOnQuotaError) {\n            (0,_serwist_core__WEBPACK_IMPORTED_MODULE_3__.registerQuotaErrorCallback)(()=>this.deleteCacheAndMetadata());\n        }\n    }\n    _getCacheExpiration(cacheName) {\n        if (cacheName === _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.privateCacheNames.getRuntimeName()) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"expire-custom-caches-only\");\n        }\n        let cacheExpiration = this._cacheExpirations.get(cacheName);\n        if (!cacheExpiration) {\n            cacheExpiration = new CacheExpiration(cacheName, this._config);\n            this._cacheExpirations.set(cacheName, cacheExpiration);\n        }\n        return cacheExpiration;\n    }\n    cachedResponseWillBeUsed({ event, cacheName, request, cachedResponse }) {\n        if (!cachedResponse) {\n            return null;\n        }\n        const isFresh = this._isResponseDateFresh(cachedResponse);\n        const cacheExpiration = this._getCacheExpiration(cacheName);\n        const isMaxAgeFromLastUsed = this._config.maxAgeFrom === \"last-used\";\n        const done = (async ()=>{\n            if (isMaxAgeFromLastUsed) {\n                await cacheExpiration.updateTimestamp(request.url);\n            }\n            await cacheExpiration.expireEntries();\n        })();\n        try {\n            event.waitUntil(done);\n        } catch (error) {\n            if (true) {\n                if (event instanceof FetchEvent) {\n                    _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.warn(`Unable to ensure service worker stays alive when updating cache entry for '${(0,_serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.getFriendlyURL)(event.request.url)}'.`);\n                }\n            }\n        }\n        return isFresh ? cachedResponse : null;\n    }\n    _isResponseDateFresh(cachedResponse) {\n        const isMaxAgeFromLastUsed = this._config.maxAgeFrom === \"last-used\";\n        if (isMaxAgeFromLastUsed) {\n            return true;\n        }\n        const now = Date.now();\n        if (!this._config.maxAgeSeconds) {\n            return true;\n        }\n        const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n        if (dateHeaderTimestamp === null) {\n            return true;\n        }\n        return dateHeaderTimestamp >= now - this._config.maxAgeSeconds * 1000;\n    }\n    _getDateHeaderTimestamp(cachedResponse) {\n        if (!cachedResponse.headers.has(\"date\")) {\n            return null;\n        }\n        const dateHeader = cachedResponse.headers.get(\"date\");\n        const parsedDate = new Date(dateHeader);\n        const headerTime = parsedDate.getTime();\n        if (Number.isNaN(headerTime)) {\n            return null;\n        }\n        return headerTime;\n    }\n    async cacheDidUpdate({ cacheName, request }) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(cacheName, \"string\", {\n                moduleName: \"@serwist/expiration\",\n                className: \"Plugin\",\n                funcName: \"cacheDidUpdate\",\n                paramName: \"cacheName\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/expiration\",\n                className: \"Plugin\",\n                funcName: \"cacheDidUpdate\",\n                paramName: \"request\"\n            });\n        }\n        const cacheExpiration = this._getCacheExpiration(cacheName);\n        await cacheExpiration.updateTimestamp(request.url);\n        await cacheExpiration.expireEntries();\n    }\n    async deleteCacheAndMetadata() {\n        for (const [cacheName, cacheExpiration] of this._cacheExpirations){\n            await self.caches.delete(cacheName);\n            await cacheExpiration.delete();\n        }\n        this._cacheExpirations = new Map();\n    }\n}\n\nconst calculateEffectiveBoundaries = (blob, start, end)=>{\n    if (true) {\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(blob, Blob, {\n            moduleName: \"@serwist/range-requests\",\n            funcName: \"calculateEffectiveBoundaries\",\n            paramName: \"blob\"\n        });\n    }\n    const blobSize = blob.size;\n    if (end && end > blobSize || start && start < 0) {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"range-not-satisfiable\", {\n            size: blobSize,\n            end,\n            start\n        });\n    }\n    let effectiveStart;\n    let effectiveEnd;\n    if (start !== undefined && end !== undefined) {\n        effectiveStart = start;\n        effectiveEnd = end + 1;\n    } else if (start !== undefined && end === undefined) {\n        effectiveStart = start;\n        effectiveEnd = blobSize;\n    } else if (end !== undefined && start === undefined) {\n        effectiveStart = blobSize - end;\n        effectiveEnd = blobSize;\n    }\n    return {\n        start: effectiveStart,\n        end: effectiveEnd\n    };\n};\n\nconst parseRangeHeader = (rangeHeader)=>{\n    if (true) {\n        _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isType(rangeHeader, \"string\", {\n            moduleName: \"@serwist/range-requests\",\n            funcName: \"parseRangeHeader\",\n            paramName: \"rangeHeader\"\n        });\n    }\n    const normalizedRangeHeader = rangeHeader.trim().toLowerCase();\n    if (!normalizedRangeHeader.startsWith(\"bytes=\")) {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"unit-must-be-bytes\", {\n            normalizedRangeHeader\n        });\n    }\n    if (normalizedRangeHeader.includes(\",\")) {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"single-range-only\", {\n            normalizedRangeHeader\n        });\n    }\n    const rangeParts = /(\\d*)-(\\d*)/.exec(normalizedRangeHeader);\n    if (!rangeParts || !(rangeParts[1] || rangeParts[2])) {\n        throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"invalid-range-values\", {\n            normalizedRangeHeader\n        });\n    }\n    return {\n        start: rangeParts[1] === \"\" ? undefined : Number(rangeParts[1]),\n        end: rangeParts[2] === \"\" ? undefined : Number(rangeParts[2])\n    };\n};\n\nconst createPartialResponse = async (request, originalResponse)=>{\n    try {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/range-requests\",\n                funcName: \"createPartialResponse\",\n                paramName: \"request\"\n            });\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.assert.isInstance(originalResponse, Response, {\n                moduleName: \"@serwist/range-requests\",\n                funcName: \"createPartialResponse\",\n                paramName: \"originalResponse\"\n            });\n        }\n        if (originalResponse.status === 206) {\n            return originalResponse;\n        }\n        const rangeHeader = request.headers.get(\"range\");\n        if (!rangeHeader) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.SerwistError(\"no-range-header\");\n        }\n        const boundaries = parseRangeHeader(rangeHeader);\n        const originalBlob = await originalResponse.blob();\n        const effectiveBoundaries = calculateEffectiveBoundaries(originalBlob, boundaries.start, boundaries.end);\n        const slicedBlob = originalBlob.slice(effectiveBoundaries.start, effectiveBoundaries.end);\n        const slicedBlobSize = slicedBlob.size;\n        const slicedResponse = new Response(slicedBlob, {\n            status: 206,\n            statusText: \"Partial Content\",\n            headers: originalResponse.headers\n        });\n        slicedResponse.headers.set(\"Content-Length\", String(slicedBlobSize));\n        slicedResponse.headers.set(\"Content-Range\", `bytes ${effectiveBoundaries.start}-${effectiveBoundaries.end - 1}/` + `${originalBlob.size}`);\n        return slicedResponse;\n    } catch (error) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.warn(\"Unable to construct a partial response; returning a \" + \"416 Range Not Satisfiable response instead.\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupCollapsed(\"View details here.\");\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(error);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(request);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.log(originalResponse);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_1__.logger.groupEnd();\n        }\n        return new Response(\"\", {\n            status: 416,\n            statusText: \"Range Not Satisfiable\"\n        });\n    }\n};\n\nclass RangeRequestsPlugin {\n    cachedResponseWillBeUsed = async ({ request, cachedResponse })=>{\n        if (cachedResponse && request.headers.has(\"range\")) {\n            return await createPartialResponse(request, cachedResponse);\n        }\n        return cachedResponse;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2luZGV4LnBsdWdpbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMk47QUFDbEY7QUFDbEc7QUFDb0I7QUFDdEI7QUFDSjtBQUNIO0FBQ21COztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQW9ELElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRCxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyw2RUFBcUI7QUFDaEU7QUFDQSwwQkFBMEIsK0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRUFBWTtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFZO0FBQzlCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnRUFBWTtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNkRBQTZELDBCQUEwQixHQUFHLDRCQUE0QixRQUFRLGtCQUFrQjtBQUNoSjtBQUNBLE1BQU07QUFDTixZQUFZLElBQXFDO0FBQ2pELFlBQVksMERBQU0sK0NBQStDO0FBQ2pFLFlBQVksMERBQU07QUFDbEIsWUFBWSwwREFBTTtBQUNsQixZQUFZLDBEQUFNO0FBQ2xCLFlBQVksMERBQU07QUFDbEIsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHlCQUF5QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9Ac2Vyd2lzdCtzd0A5LjAuMC1wcmV2aWV3LjIxX3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL0BzZXJ3aXN0L3N3L2Rpc3QvaW5kZXgucGx1Z2lucy5qcz85NjAwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IEIgYXMgQmFja2dyb3VuZFN5bmNQbHVnaW4sIFEgYXMgQmFja2dyb3VuZFN5bmNRdWV1ZSwgYSBhcyBCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmUsIFAgYXMgUHJlY2FjaGVGYWxsYmFja1BsdWdpbiwgUyBhcyBTdG9yYWJsZVJlcXVlc3QsIGkgYXMgaW5pdGlhbGl6ZUdvb2dsZUFuYWx5dGljcyB9IGZyb20gJy4vY2h1bmtzL1ByZWNhY2hlRmFsbGJhY2tQbHVnaW4uanMnO1xuaW1wb3J0IHsgU2Vyd2lzdEVycm9yLCBsb2dnZXIsIGFzc2VydCwgcmVzdWx0aW5nQ2xpZW50RXhpc3RzLCB0aW1lb3V0LCBnZXRGcmllbmRseVVSTCwgcHJpdmF0ZUNhY2hlTmFtZXMgfSBmcm9tICdAc2Vyd2lzdC9jb3JlL2ludGVybmFsJztcbmltcG9ydCB7IGRlbGV0ZURCLCBvcGVuREIgfSBmcm9tICdpZGInO1xuaW1wb3J0IHsgcmVnaXN0ZXJRdW90YUVycm9yQ2FsbGJhY2sgfSBmcm9tICdAc2Vyd2lzdC9jb3JlJztcbmltcG9ydCAnLi9jaHVua3Mvc2luZ2xldG9uUm91dGVyLmpzJztcbmltcG9ydCAnLi9jaHVua3MvTmV0d29ya09ubHkuanMnO1xuaW1wb3J0ICcuL2NodW5rcy9TdHJhdGVneS5qcyc7XG5pbXBvcnQgJy4vY2h1bmtzL3NpbmdsZXRvblByZWNhY2hlQ29udHJvbGxlci5qcyc7XG5cbmNvbnN0IENBQ0hFX1VQREFURURfTUVTU0FHRV9UWVBFID0gXCJDQUNIRV9VUERBVEVEXCI7XG5jb25zdCBDQUNIRV9VUERBVEVEX01FU1NBR0VfTUVUQSA9IFwic2Vyd2lzdC1icm9hZGNhc3QtdXBkYXRlXCI7XG5jb25zdCBkZWZhdWx0Tm90aWZ5QWxsQ2xpZW50cyA9IHRydWU7XG5jb25zdCBkZWZhdWx0SGVhZGVyc1RvQ2hlY2sgPSBbXG4gICAgXCJjb250ZW50LWxlbmd0aFwiLFxuICAgIFwiZXRhZ1wiLFxuICAgIFwibGFzdC1tb2RpZmllZFwiXG5dO1xuXG5jb25zdCByZXNwb25zZXNBcmVTYW1lID0gKGZpcnN0UmVzcG9uc2UsIHNlY29uZFJlc3BvbnNlLCBoZWFkZXJzVG9DaGVjayk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmICghKGZpcnN0UmVzcG9uc2UgaW5zdGFuY2VvZiBSZXNwb25zZSAmJiBzZWNvbmRSZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImludmFsaWQtcmVzcG9uc2VzLWFyZS1zYW1lLWFyZ3NcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYXRMZWFzdE9uZUhlYWRlckF2YWlsYWJsZSA9IGhlYWRlcnNUb0NoZWNrLnNvbWUoKGhlYWRlcik9PntcbiAgICAgICAgcmV0dXJuIGZpcnN0UmVzcG9uc2UuaGVhZGVycy5oYXMoaGVhZGVyKSAmJiBzZWNvbmRSZXNwb25zZS5oZWFkZXJzLmhhcyhoZWFkZXIpO1xuICAgIH0pO1xuICAgIGlmICghYXRMZWFzdE9uZUhlYWRlckF2YWlsYWJsZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIlVuYWJsZSB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIHJlc3BvbnNlIGhhcyBiZWVuIHVwZGF0ZWQgYmVjYXVzZSBub25lIG9mIHRoZSBoZWFkZXJzIHRoYXQgd291bGQgYmUgY2hlY2tlZCBhcmUgcHJlc2VudC5cIik7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoXCJBdHRlbXB0aW5nIHRvIGNvbXBhcmUgdGhlIGZvbGxvd2luZzogXCIsIGZpcnN0UmVzcG9uc2UsIHNlY29uZFJlc3BvbnNlLCBoZWFkZXJzVG9DaGVjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzVG9DaGVjay5ldmVyeSgoaGVhZGVyKT0+e1xuICAgICAgICBjb25zdCBoZWFkZXJTdGF0ZUNvbXBhcmlzb24gPSBmaXJzdFJlc3BvbnNlLmhlYWRlcnMuaGFzKGhlYWRlcikgPT09IHNlY29uZFJlc3BvbnNlLmhlYWRlcnMuaGFzKGhlYWRlcik7XG4gICAgICAgIGNvbnN0IGhlYWRlclZhbHVlQ29tcGFyaXNvbiA9IGZpcnN0UmVzcG9uc2UuaGVhZGVycy5nZXQoaGVhZGVyKSA9PT0gc2Vjb25kUmVzcG9uc2UuaGVhZGVycy5nZXQoaGVhZGVyKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlclN0YXRlQ29tcGFyaXNvbiAmJiBoZWFkZXJWYWx1ZUNvbXBhcmlzb247XG4gICAgfSk7XG59O1xuXG5jb25zdCBpc1NhZmFyaSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IGRlZmF1bHRQYXlsb2FkR2VuZXJhdG9yID0gKGRhdGEpPT57XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FjaGVOYW1lOiBkYXRhLmNhY2hlTmFtZSxcbiAgICAgICAgdXBkYXRlZFVSTDogZGF0YS5yZXF1ZXN0LnVybFxuICAgIH07XG59O1xuY2xhc3MgQnJvYWRjYXN0Q2FjaGVVcGRhdGUge1xuICAgIF9oZWFkZXJzVG9DaGVjaztcbiAgICBfZ2VuZXJhdGVQYXlsb2FkO1xuICAgIF9ub3RpZnlBbGxDbGllbnRzO1xuICAgIGNvbnN0cnVjdG9yKHsgZ2VuZXJhdGVQYXlsb2FkLCBoZWFkZXJzVG9DaGVjaywgbm90aWZ5QWxsQ2xpZW50cyB9ID0ge30pe1xuICAgICAgICB0aGlzLl9oZWFkZXJzVG9DaGVjayA9IGhlYWRlcnNUb0NoZWNrIHx8IGRlZmF1bHRIZWFkZXJzVG9DaGVjaztcbiAgICAgICAgdGhpcy5fZ2VuZXJhdGVQYXlsb2FkID0gZ2VuZXJhdGVQYXlsb2FkIHx8IGRlZmF1bHRQYXlsb2FkR2VuZXJhdG9yO1xuICAgICAgICB0aGlzLl9ub3RpZnlBbGxDbGllbnRzID0gbm90aWZ5QWxsQ2xpZW50cyA/PyBkZWZhdWx0Tm90aWZ5QWxsQ2xpZW50cztcbiAgICB9XG4gICAgYXN5bmMgbm90aWZ5SWZVcGRhdGVkKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShvcHRpb25zLmNhY2hlTmFtZSwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvYnJvYWRjYXN0LXVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm5vdGlmeUlmVXBkYXRlZFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjYWNoZU5hbWVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShvcHRpb25zLm5ld1Jlc3BvbnNlLCBSZXNwb25zZSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvYnJvYWRjYXN0LXVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm5vdGlmeUlmVXBkYXRlZFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJuZXdSZXNwb25zZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKG9wdGlvbnMucmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvYnJvYWRjYXN0LXVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm5vdGlmeUlmVXBkYXRlZFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5vbGRSZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVzcG9uc2VzQXJlU2FtZShvcHRpb25zLm9sZFJlc3BvbnNlLCBvcHRpb25zLm5ld1Jlc3BvbnNlLCB0aGlzLl9oZWFkZXJzVG9DaGVjaykpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiTmV3ZXIgcmVzcG9uc2UgZm91bmQgKGFuZCBjYWNoZWQpIGZvcjpcIiwgb3B0aW9ucy5yZXF1ZXN0LnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDQUNIRV9VUERBVEVEX01FU1NBR0VfVFlQRSxcbiAgICAgICAgICAgICAgICBtZXRhOiBDQUNIRV9VUERBVEVEX01FU1NBR0VfTUVUQSxcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB0aGlzLl9nZW5lcmF0ZVBheWxvYWQob3B0aW9ucylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5yZXF1ZXN0Lm1vZGUgPT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHRpbmdDbGllbnRJZDtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ldmVudCBpbnN0YW5jZW9mIEZldGNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0aW5nQ2xpZW50SWQgPSBvcHRpb25zLmV2ZW50LnJlc3VsdGluZ0NsaWVudElkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRpbmdXaW4gPSBhd2FpdCByZXN1bHRpbmdDbGllbnRFeGlzdHMocmVzdWx0aW5nQ2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0aW5nV2luIHx8IGlzU2FmYXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQoMzUwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX25vdGlmeUFsbENsaWVudHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aW5kb3dzID0gYXdhaXQgc2VsZi5jbGllbnRzLm1hdGNoQWxsKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ3aW5kb3dcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgd2luIG9mIHdpbmRvd3Mpe1xuICAgICAgICAgICAgICAgICAgICB3aW4ucG9zdE1lc3NhZ2UobWVzc2FnZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXZlbnQgaW5zdGFuY2VvZiBGZXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IHNlbGYuY2xpZW50cy5nZXQob3B0aW9ucy5ldmVudC5jbGllbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudD8ucG9zdE1lc3NhZ2UobWVzc2FnZURhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQnJvYWRjYXN0VXBkYXRlUGx1Z2luIHtcbiAgICBfYnJvYWRjYXN0VXBkYXRlO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpe1xuICAgICAgICB0aGlzLl9icm9hZGNhc3RVcGRhdGUgPSBuZXcgQnJvYWRjYXN0Q2FjaGVVcGRhdGUob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhY2hlRGlkVXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgdm9pZCB0aGlzLl9icm9hZGNhc3RVcGRhdGUubm90aWZ5SWZVcGRhdGVkKG9wdGlvbnMpO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FjaGVhYmxlUmVzcG9uc2Uge1xuICAgIF9zdGF0dXNlcztcbiAgICBfaGVhZGVycztcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5zdGF0dXNlcyB8fCBjb25maWcuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwic3RhdHVzZXMtb3ItaGVhZGVycy1yZXF1aXJlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvY2FjaGVhYmxlLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDYWNoZWFibGVSZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLnN0YXR1c2VzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzQXJyYXkoY29uZmlnLnN0YXR1c2VzLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvY2FjaGVhYmxlLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDYWNoZWFibGVSZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiY29uZmlnLnN0YXR1c2VzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcuaGVhZGVycykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLmhlYWRlcnMsIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9jYWNoZWFibGUtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNhY2hlYWJsZVJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcuaGVhZGVyc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdHVzZXMgPSBjb25maWcuc3RhdHVzZXM7XG4gICAgICAgIGlmIChjb25maWcuaGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycyA9IG5ldyBIZWFkZXJzKGNvbmZpZy5oZWFkZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1Jlc3BvbnNlQ2FjaGVhYmxlKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlc3BvbnNlLCBSZXNwb25zZSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvY2FjaGVhYmxlLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkNhY2hlYWJsZVJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiaXNSZXNwb25zZUNhY2hlYWJsZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXNwb25zZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXR1c2VzKSB7XG4gICAgICAgICAgICBjYWNoZWFibGUgPSB0aGlzLl9zdGF0dXNlcy5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9oZWFkZXJzICYmIGNhY2hlYWJsZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdIG9mIHRoaXMuX2hlYWRlcnMuZW50cmllcygpKXtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuaGVhZGVycy5nZXQoaGVhZGVyTmFtZSkgIT09IGhlYWRlclZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKCFjYWNoZWFibGUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYFRoZSByZXF1ZXN0IGZvciAnJHtnZXRGcmllbmRseVVSTChyZXNwb25zZS51cmwpfScgcmV0dXJuZWQgYSByZXNwb25zZSB0aGF0IGRvZXMgbm90IG1lZXQgdGhlIGNyaXRlcmlhIGZvciBiZWluZyBjYWNoZWQuYCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiVmlldyBjYWNoZWFiaWxpdHkgY3JpdGVyaWEgaGVyZS5cIik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgQ2FjaGVhYmxlIHN0YXR1c2VzOiAke0pTT04uc3RyaW5naWZ5KHRoaXMuX3N0YXR1c2VzKX1gKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBDYWNoZWFibGUgaGVhZGVyczogJHtKU09OLnN0cmluZ2lmeSh0aGlzLl9oZWFkZXJzLCBudWxsLCAyKX1gKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2dGcmllbmRseUhlYWRlcnMgPSB7fTtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpPT57XG4gICAgICAgICAgICAgICAgICAgIGxvZ0ZyaWVuZGx5SGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiVmlldyByZXNwb25zZSBzdGF0dXMgYW5kIGhlYWRlcnMgaGVyZS5cIik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVzcG9uc2Ugc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBSZXNwb25zZSBoZWFkZXJzOiAke0pTT04uc3RyaW5naWZ5KGxvZ0ZyaWVuZGx5SGVhZGVycywgbnVsbCwgMil9YCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiVmlldyBmdWxsIHJlc3BvbnNlIGRldGFpbHMgaGVyZS5cIik7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXNwb25zZS5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVhYmxlO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FjaGVhYmxlUmVzcG9uc2VQbHVnaW4ge1xuICAgIF9jYWNoZWFibGVSZXNwb25zZTtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpe1xuICAgICAgICB0aGlzLl9jYWNoZWFibGVSZXNwb25zZSA9IG5ldyBDYWNoZWFibGVSZXNwb25zZShjb25maWcpO1xuICAgIH1cbiAgICBjYWNoZVdpbGxVcGRhdGUgPSBhc3luYyAoeyByZXNwb25zZSB9KT0+e1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVhYmxlUmVzcG9uc2UuaXNSZXNwb25zZUNhY2hlYWJsZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xufVxuXG5jb25zdCBEQl9OQU1FID0gXCJzZXJ3aXN0LWV4cGlyYXRpb25cIjtcbmNvbnN0IENBQ0hFX09CSkVDVF9TVE9SRSA9IFwiY2FjaGUtZW50cmllc1wiO1xuY29uc3Qgbm9ybWFsaXplVVJMID0gKHVuTm9ybWFsaXplZFVybCk9PntcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuTm9ybWFsaXplZFVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgdXJsLmhhc2ggPSBcIlwiO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbn07XG5jbGFzcyBDYWNoZVRpbWVzdGFtcHNNb2RlbCB7XG4gICAgX2NhY2hlTmFtZTtcbiAgICBfZGIgPSBudWxsO1xuICAgIGNvbnN0cnVjdG9yKGNhY2hlTmFtZSl7XG4gICAgICAgIHRoaXMuX2NhY2hlTmFtZSA9IGNhY2hlTmFtZTtcbiAgICB9XG4gICAgX2dldElkKHVybCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5fY2FjaGVOYW1lfXwke25vcm1hbGl6ZVVSTCh1cmwpfWA7XG4gICAgfVxuICAgIF91cGdyYWRlRGIoZGIpIHtcbiAgICAgICAgY29uc3Qgb2JqU3RvcmUgPSBkYi5jcmVhdGVPYmplY3RTdG9yZShDQUNIRV9PQkpFQ1RfU1RPUkUsIHtcbiAgICAgICAgICAgIGtleVBhdGg6IFwiaWRcIlxuICAgICAgICB9KTtcbiAgICAgICAgb2JqU3RvcmUuY3JlYXRlSW5kZXgoXCJjYWNoZU5hbWVcIiwgXCJjYWNoZU5hbWVcIiwge1xuICAgICAgICAgICAgdW5pcXVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgb2JqU3RvcmUuY3JlYXRlSW5kZXgoXCJ0aW1lc3RhbXBcIiwgXCJ0aW1lc3RhbXBcIiwge1xuICAgICAgICAgICAgdW5pcXVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3VwZ3JhZGVEYkFuZERlbGV0ZU9sZERicyhkYikge1xuICAgICAgICB0aGlzLl91cGdyYWRlRGIoZGIpO1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVOYW1lKSB7XG4gICAgICAgICAgICB2b2lkIGRlbGV0ZURCKHRoaXMuX2NhY2hlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0VGltZXN0YW1wKHVybCwgdGltZXN0YW1wKSB7XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLl9nZXRJZCh1cmwpLFxuICAgICAgICAgICAgY2FjaGVOYW1lOiB0aGlzLl9jYWNoZU5hbWUsXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICB0aW1lc3RhbXBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oQ0FDSEVfT0JKRUNUX1NUT1JFLCBcInJlYWR3cml0ZVwiLCB7XG4gICAgICAgICAgICBkdXJhYmlsaXR5OiBcInJlbGF4ZWRcIlxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHguc3RvcmUucHV0KGVudHJ5KTtcbiAgICAgICAgYXdhaXQgdHguZG9uZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VGltZXN0YW1wKHVybCkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0RGIoKTtcbiAgICAgICAgY29uc3QgZW50cnkgPSBhd2FpdCBkYi5nZXQoQ0FDSEVfT0JKRUNUX1NUT1JFLCB0aGlzLl9nZXRJZCh1cmwpKTtcbiAgICAgICAgcmV0dXJuIGVudHJ5Py50aW1lc3RhbXA7XG4gICAgfVxuICAgIGFzeW5jIGV4cGlyZUVudHJpZXMobWluVGltZXN0YW1wLCBtYXhDb3VudCkge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0RGIoKTtcbiAgICAgICAgbGV0IGN1cnNvciA9IGF3YWl0IGRiLnRyYW5zYWN0aW9uKENBQ0hFX09CSkVDVF9TVE9SRSwgXCJyZWFkd3JpdGVcIikuc3RvcmUuaW5kZXgoXCJ0aW1lc3RhbXBcIikub3BlbkN1cnNvcihudWxsLCBcInByZXZcIik7XG4gICAgICAgIGNvbnN0IHVybHNEZWxldGVkID0gW107XG4gICAgICAgIGxldCBlbnRyaWVzTm90RGVsZXRlZENvdW50ID0gMDtcbiAgICAgICAgd2hpbGUoY3Vyc29yKXtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuY2FjaGVOYW1lID09PSB0aGlzLl9jYWNoZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluVGltZXN0YW1wICYmIHJlc3VsdC50aW1lc3RhbXAgPCBtaW5UaW1lc3RhbXAgfHwgbWF4Q291bnQgJiYgZW50cmllc05vdERlbGV0ZWRDb3VudCA+PSBtYXhDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJzb3IuZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHVybHNEZWxldGVkLnB1c2gocmVzdWx0LnVybCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllc05vdERlbGV0ZWRDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnNvciA9IGF3YWl0IGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmxzRGVsZXRlZDtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RGIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGIpIHtcbiAgICAgICAgICAgIHRoaXMuX2RiID0gYXdhaXQgb3BlbkRCKERCX05BTUUsIDEsIHtcbiAgICAgICAgICAgICAgICB1cGdyYWRlOiB0aGlzLl91cGdyYWRlRGJBbmREZWxldGVPbGREYnMuYmluZCh0aGlzKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RiO1xuICAgIH1cbn1cblxuY2xhc3MgQ2FjaGVFeHBpcmF0aW9uIHtcbiAgICBfaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgX21heEVudHJpZXM7XG4gICAgX21heEFnZVNlY29uZHM7XG4gICAgX21hdGNoT3B0aW9ucztcbiAgICBfY2FjaGVOYW1lO1xuICAgIF90aW1lc3RhbXBNb2RlbDtcbiAgICBjb25zdHJ1Y3RvcihjYWNoZU5hbWUsIGNvbmZpZyA9IHt9KXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjYWNoZU5hbWUsIFwic3RyaW5nXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2V4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ2FjaGVFeHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiY2FjaGVOYW1lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCEoY29uZmlnLm1heEVudHJpZXMgfHwgY29uZmlnLm1heEFnZVNlY29uZHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcIm1heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvZXhwaXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQ2FjaGVFeHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4RW50cmllcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEVudHJpZXMsIFwibnVtYmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9leHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDYWNoZUV4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNvbmZpZy5tYXhFbnRyaWVzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEFnZVNlY29uZHMsIFwibnVtYmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9leHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDYWNoZUV4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNvbmZpZy5tYXhBZ2VTZWNvbmRzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXhFbnRyaWVzID0gY29uZmlnLm1heEVudHJpZXM7XG4gICAgICAgIHRoaXMuX21heEFnZVNlY29uZHMgPSBjb25maWcubWF4QWdlU2Vjb25kcztcbiAgICAgICAgdGhpcy5fbWF0Y2hPcHRpb25zID0gY29uZmlnLm1hdGNoT3B0aW9ucztcbiAgICAgICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuICAgICAgICB0aGlzLl90aW1lc3RhbXBNb2RlbCA9IG5ldyBDYWNoZVRpbWVzdGFtcHNNb2RlbChjYWNoZU5hbWUpO1xuICAgIH1cbiAgICBhc3luYyBleHBpcmVFbnRyaWVzKCkge1xuICAgICAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWluVGltZXN0YW1wID0gdGhpcy5fbWF4QWdlU2Vjb25kcyA/IERhdGUubm93KCkgLSB0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCA6IDA7XG4gICAgICAgIGNvbnN0IHVybHNFeHBpcmVkID0gYXdhaXQgdGhpcy5fdGltZXN0YW1wTW9kZWwuZXhwaXJlRW50cmllcyhtaW5UaW1lc3RhbXAsIHRoaXMuX21heEVudHJpZXMpO1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4odGhpcy5fY2FjaGVOYW1lKTtcbiAgICAgICAgZm9yIChjb25zdCB1cmwgb2YgdXJsc0V4cGlyZWQpe1xuICAgICAgICAgICAgYXdhaXQgY2FjaGUuZGVsZXRlKHVybCwgdGhpcy5fbWF0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodXJsc0V4cGlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgRXhwaXJlZCAke3VybHNFeHBpcmVkLmxlbmd0aH0gYCArIGAke3VybHNFeHBpcmVkLmxlbmd0aCA9PT0gMSA/IFwiZW50cnlcIiA6IFwiZW50cmllc1wifSBhbmQgcmVtb3ZlZCBgICsgYCR7dXJsc0V4cGlyZWQubGVuZ3RoID09PSAxID8gXCJpdFwiIDogXCJ0aGVtXCJ9IGZyb20gdGhlIGAgKyBgJyR7dGhpcy5fY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRXhwaXJlZCB0aGUgZm9sbG93aW5nICR7dXJsc0V4cGlyZWQubGVuZ3RoID09PSAxID8gXCJVUkxcIiA6IFwiVVJMc1wifTpgKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzRXhwaXJlZCl7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYCAgICAke3VybH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhcIkNhY2hlIGV4cGlyYXRpb24gcmFuIGFuZCBmb3VuZCBubyBlbnRyaWVzIHRvIHJlbW92ZS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9yZXJ1blJlcXVlc3RlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZvaWQgdGhpcy5leHBpcmVFbnRyaWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlVGltZXN0YW1wKHVybCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNUeXBlKHVybCwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvZXhwaXJhdGlvblwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJDYWNoZUV4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ1cGRhdGVUaW1lc3RhbXBcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwidXJsXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLnNldFRpbWVzdGFtcCh1cmwsIERhdGUubm93KCkpO1xuICAgIH1cbiAgICBhc3luYyBpc1VSTEV4cGlyZWQodXJsKSB7XG4gICAgICAgIGlmICghdGhpcy5fbWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJleHBpcmVkLXRlc3Qtd2l0aG91dC1tYXgtYWdlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogXCJpc1VSTEV4cGlyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm1heEFnZVNlY29uZHNcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmdldFRpbWVzdGFtcCh1cmwpO1xuICAgICAgICBjb25zdCBleHBpcmVPbGRlclRoYW4gPSBEYXRlLm5vdygpIC0gdGhpcy5fbWF4QWdlU2Vjb25kcyAqIDEwMDA7XG4gICAgICAgIHJldHVybiB0aW1lc3RhbXAgIT09IHVuZGVmaW5lZCA/IHRpbWVzdGFtcCA8IGV4cGlyZU9sZGVyVGhhbiA6IHRydWU7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5fcmVydW5SZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgYXdhaXQgdGhpcy5fdGltZXN0YW1wTW9kZWwuZXhwaXJlRW50cmllcyhOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIH1cbn1cblxuY2xhc3MgRXhwaXJhdGlvblBsdWdpbiB7XG4gICAgX2NvbmZpZztcbiAgICBfY2FjaGVFeHBpcmF0aW9ucztcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSl7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKGNvbmZpZy5tYXhFbnRyaWVzIHx8IGNvbmZpZy5tYXhBZ2VTZWNvbmRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJtYXgtZW50cmllcy1vci1hZ2UtcmVxdWlyZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2V4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkV4cGlyYXRpb25QbHVnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4RW50cmllcywgXCJudW1iZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2V4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkV4cGlyYXRpb25QbHVnaW5cIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNvbmZpZy5tYXhFbnRyaWVzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEFnZVNlY29uZHMsIFwibnVtYmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9leHBpcmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJFeHBpcmF0aW9uUGx1Z2luXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJjb25maWcubWF4QWdlU2Vjb25kc1wiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLm1heEFnZUZyb20pIHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhBZ2VGcm9tLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvZXhwaXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiRXhwaXJhdGlvblBsdWdpblwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiY29uZmlnLm1heEFnZUZyb21cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcubWF4QWdlRnJvbSkge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLm1heEFnZUZyb20gPSBcImxhc3QtZmV0Y2hlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcucHVyZ2VPblF1b3RhRXJyb3IpIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrKCgpPT50aGlzLmRlbGV0ZUNhY2hlQW5kTWV0YWRhdGEoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpIHtcbiAgICAgICAgaWYgKGNhY2hlTmFtZSA9PT0gcHJpdmF0ZUNhY2hlTmFtZXMuZ2V0UnVudGltZU5hbWUoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImV4cGlyZS1jdXN0b20tY2FjaGVzLW9ubHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMuZ2V0KGNhY2hlTmFtZSk7XG4gICAgICAgIGlmICghY2FjaGVFeHBpcmF0aW9uKSB7XG4gICAgICAgICAgICBjYWNoZUV4cGlyYXRpb24gPSBuZXcgQ2FjaGVFeHBpcmF0aW9uKGNhY2hlTmFtZSwgdGhpcy5fY29uZmlnKTtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMuc2V0KGNhY2hlTmFtZSwgY2FjaGVFeHBpcmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVFeHBpcmF0aW9uO1xuICAgIH1cbiAgICBjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQoeyBldmVudCwgY2FjaGVOYW1lLCByZXF1ZXN0LCBjYWNoZWRSZXNwb25zZSB9KSB7XG4gICAgICAgIGlmICghY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRnJlc2ggPSB0aGlzLl9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgY2FjaGVFeHBpcmF0aW9uID0gdGhpcy5fZ2V0Q2FjaGVFeHBpcmF0aW9uKGNhY2hlTmFtZSk7XG4gICAgICAgIGNvbnN0IGlzTWF4QWdlRnJvbUxhc3RVc2VkID0gdGhpcy5fY29uZmlnLm1heEFnZUZyb20gPT09IFwibGFzdC11c2VkXCI7XG4gICAgICAgIGNvbnN0IGRvbmUgPSAoYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGlmIChpc01heEFnZUZyb21MYXN0VXNlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi51cGRhdGVUaW1lc3RhbXAocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLmV4cGlyZUVudHJpZXMoKTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV2ZW50LndhaXRVbnRpbChkb25lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBGZXRjaEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKGBVbmFibGUgdG8gZW5zdXJlIHNlcnZpY2Ugd29ya2VyIHN0YXlzIGFsaXZlIHdoZW4gdXBkYXRpbmcgY2FjaGUgZW50cnkgZm9yICcke2dldEZyaWVuZGx5VVJMKGV2ZW50LnJlcXVlc3QudXJsKX0nLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNGcmVzaCA/IGNhY2hlZFJlc3BvbnNlIDogbnVsbDtcbiAgICB9XG4gICAgX2lzUmVzcG9uc2VEYXRlRnJlc2goY2FjaGVkUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgaXNNYXhBZ2VGcm9tTGFzdFVzZWQgPSB0aGlzLl9jb25maWcubWF4QWdlRnJvbSA9PT0gXCJsYXN0LXVzZWRcIjtcbiAgICAgICAgaWYgKGlzTWF4QWdlRnJvbUxhc3RVc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5tYXhBZ2VTZWNvbmRzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlSGVhZGVyVGltZXN0YW1wID0gdGhpcy5fZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSk7XG4gICAgICAgIGlmIChkYXRlSGVhZGVyVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUhlYWRlclRpbWVzdGFtcCA+PSBub3cgLSB0aGlzLl9jb25maWcubWF4QWdlU2Vjb25kcyAqIDEwMDA7XG4gICAgfVxuICAgIF9nZXREYXRlSGVhZGVyVGltZXN0YW1wKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgIGlmICghY2FjaGVkUmVzcG9uc2UuaGVhZGVycy5oYXMoXCJkYXRlXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRlSGVhZGVyID0gY2FjaGVkUmVzcG9uc2UuaGVhZGVycy5nZXQoXCJkYXRlXCIpO1xuICAgICAgICBjb25zdCBwYXJzZWREYXRlID0gbmV3IERhdGUoZGF0ZUhlYWRlcik7XG4gICAgICAgIGNvbnN0IGhlYWRlclRpbWUgPSBwYXJzZWREYXRlLmdldFRpbWUoKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihoZWFkZXJUaW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlclRpbWU7XG4gICAgfVxuICAgIGFzeW5jIGNhY2hlRGlkVXBkYXRlKHsgY2FjaGVOYW1lLCByZXF1ZXN0IH0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzVHlwZShjYWNoZU5hbWUsIFwic3RyaW5nXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2V4cGlyYXRpb25cIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUGx1Z2luXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY2FjaGVEaWRVcGRhdGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiY2FjaGVOYW1lXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvZXhwaXJhdGlvblwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJQbHVnaW5cIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjYWNoZURpZFVwZGF0ZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpO1xuICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24udXBkYXRlVGltZXN0YW1wKHJlcXVlc3QudXJsKTtcbiAgICAgICAgYXdhaXQgY2FjaGVFeHBpcmF0aW9uLmV4cGlyZUVudHJpZXMoKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlQ2FjaGVBbmRNZXRhZGF0YSgpIHtcbiAgICAgICAgZm9yIChjb25zdCBbY2FjaGVOYW1lLCBjYWNoZUV4cGlyYXRpb25dIG9mIHRoaXMuX2NhY2hlRXhwaXJhdGlvbnMpe1xuICAgICAgICAgICAgYXdhaXQgc2VsZi5jYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSk7XG4gICAgICAgICAgICBhd2FpdCBjYWNoZUV4cGlyYXRpb24uZGVsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FjaGVFeHBpcmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB9XG59XG5cbmNvbnN0IGNhbGN1bGF0ZUVmZmVjdGl2ZUJvdW5kYXJpZXMgPSAoYmxvYiwgc3RhcnQsIGVuZCk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGFzc2VydC5pc0luc3RhbmNlKGJsb2IsIEJsb2IsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvcmFuZ2UtcmVxdWVzdHNcIixcbiAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNhbGN1bGF0ZUVmZmVjdGl2ZUJvdW5kYXJpZXNcIixcbiAgICAgICAgICAgIHBhcmFtTmFtZTogXCJibG9iXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJsb2JTaXplID0gYmxvYi5zaXplO1xuICAgIGlmIChlbmQgJiYgZW5kID4gYmxvYlNpemUgfHwgc3RhcnQgJiYgc3RhcnQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJyYW5nZS1ub3Qtc2F0aXNmaWFibGVcIiwge1xuICAgICAgICAgICAgc2l6ZTogYmxvYlNpemUsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBzdGFydFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGVmZmVjdGl2ZVN0YXJ0O1xuICAgIGxldCBlZmZlY3RpdmVFbmQ7XG4gICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWZmZWN0aXZlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgZWZmZWN0aXZlRW5kID0gZW5kICsgMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQgJiYgZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWZmZWN0aXZlU3RhcnQgPSBzdGFydDtcbiAgICAgICAgZWZmZWN0aXZlRW5kID0gYmxvYlNpemU7XG4gICAgfSBlbHNlIGlmIChlbmQgIT09IHVuZGVmaW5lZCAmJiBzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVmZmVjdGl2ZVN0YXJ0ID0gYmxvYlNpemUgLSBlbmQ7XG4gICAgICAgIGVmZmVjdGl2ZUVuZCA9IGJsb2JTaXplO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZWZmZWN0aXZlU3RhcnQsXG4gICAgICAgIGVuZDogZWZmZWN0aXZlRW5kXG4gICAgfTtcbn07XG5cbmNvbnN0IHBhcnNlUmFuZ2VIZWFkZXIgPSAocmFuZ2VIZWFkZXIpPT57XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBhc3NlcnQuaXNUeXBlKHJhbmdlSGVhZGVyLCBcInN0cmluZ1wiLCB7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JhbmdlLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICBmdW5jTmFtZTogXCJwYXJzZVJhbmdlSGVhZGVyXCIsXG4gICAgICAgICAgICBwYXJhbU5hbWU6IFwicmFuZ2VIZWFkZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgbm9ybWFsaXplZFJhbmdlSGVhZGVyID0gcmFuZ2VIZWFkZXIudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIuc3RhcnRzV2l0aChcImJ5dGVzPVwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwidW5pdC1tdXN0LWJlLWJ5dGVzXCIsIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRSYW5nZUhlYWRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRSYW5nZUhlYWRlci5pbmNsdWRlcyhcIixcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInNpbmdsZS1yYW5nZS1vbmx5XCIsIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRSYW5nZUhlYWRlclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VQYXJ0cyA9IC8oXFxkKiktKFxcZCopLy5leGVjKG5vcm1hbGl6ZWRSYW5nZUhlYWRlcik7XG4gICAgaWYgKCFyYW5nZVBhcnRzIHx8ICEocmFuZ2VQYXJ0c1sxXSB8fCByYW5nZVBhcnRzWzJdKSkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC1yYW5nZS12YWx1ZXNcIiwge1xuICAgICAgICAgICAgbm9ybWFsaXplZFJhbmdlSGVhZGVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogcmFuZ2VQYXJ0c1sxXSA9PT0gXCJcIiA/IHVuZGVmaW5lZCA6IE51bWJlcihyYW5nZVBhcnRzWzFdKSxcbiAgICAgICAgZW5kOiByYW5nZVBhcnRzWzJdID09PSBcIlwiID8gdW5kZWZpbmVkIDogTnVtYmVyKHJhbmdlUGFydHNbMl0pXG4gICAgfTtcbn07XG5cbmNvbnN0IGNyZWF0ZVBhcnRpYWxSZXNwb25zZSA9IGFzeW5jIChyZXF1ZXN0LCBvcmlnaW5hbFJlc3BvbnNlKT0+e1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L3JhbmdlLXJlcXVlc3RzXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY3JlYXRlUGFydGlhbFJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShvcmlnaW5hbFJlc3BvbnNlLCBSZXNwb25zZSwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3QvcmFuZ2UtcmVxdWVzdHNcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjcmVhdGVQYXJ0aWFsUmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwib3JpZ2luYWxSZXNwb25zZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luYWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNikge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwicmFuZ2VcIik7XG4gICAgICAgIGlmICghcmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJuby1yYW5nZS1oZWFkZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYm91bmRhcmllcyA9IHBhcnNlUmFuZ2VIZWFkZXIocmFuZ2VIZWFkZXIpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEJsb2IgPSBhd2FpdCBvcmlnaW5hbFJlc3BvbnNlLmJsb2IoKTtcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlQm91bmRhcmllcyA9IGNhbGN1bGF0ZUVmZmVjdGl2ZUJvdW5kYXJpZXMob3JpZ2luYWxCbG9iLCBib3VuZGFyaWVzLnN0YXJ0LCBib3VuZGFyaWVzLmVuZCk7XG4gICAgICAgIGNvbnN0IHNsaWNlZEJsb2IgPSBvcmlnaW5hbEJsb2Iuc2xpY2UoZWZmZWN0aXZlQm91bmRhcmllcy5zdGFydCwgZWZmZWN0aXZlQm91bmRhcmllcy5lbmQpO1xuICAgICAgICBjb25zdCBzbGljZWRCbG9iU2l6ZSA9IHNsaWNlZEJsb2Iuc2l6ZTtcbiAgICAgICAgY29uc3Qgc2xpY2VkUmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoc2xpY2VkQmxvYiwge1xuICAgICAgICAgICAgc3RhdHVzOiAyMDYsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIlBhcnRpYWwgQ29udGVudFwiLFxuICAgICAgICAgICAgaGVhZGVyczogb3JpZ2luYWxSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgIH0pO1xuICAgICAgICBzbGljZWRSZXNwb25zZS5oZWFkZXJzLnNldChcIkNvbnRlbnQtTGVuZ3RoXCIsIFN0cmluZyhzbGljZWRCbG9iU2l6ZSkpO1xuICAgICAgICBzbGljZWRSZXNwb25zZS5oZWFkZXJzLnNldChcIkNvbnRlbnQtUmFuZ2VcIiwgYGJ5dGVzICR7ZWZmZWN0aXZlQm91bmRhcmllcy5zdGFydH0tJHtlZmZlY3RpdmVCb3VuZGFyaWVzLmVuZCAtIDF9L2AgKyBgJHtvcmlnaW5hbEJsb2Iuc2l6ZX1gKTtcbiAgICAgICAgcmV0dXJuIHNsaWNlZFJlc3BvbnNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiVW5hYmxlIHRvIGNvbnN0cnVjdCBhIHBhcnRpYWwgcmVzcG9uc2U7IHJldHVybmluZyBhIFwiICsgXCI0MTYgUmFuZ2UgTm90IFNhdGlzZmlhYmxlIHJlc3BvbnNlIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFwiVmlldyBkZXRhaWxzIGhlcmUuXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhlcnJvcik7XG4gICAgICAgICAgICBsb2dnZXIubG9nKHJlcXVlc3QpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhvcmlnaW5hbFJlc3BvbnNlKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoXCJcIiwge1xuICAgICAgICAgICAgc3RhdHVzOiA0MTYsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBcIlJhbmdlIE5vdCBTYXRpc2ZpYWJsZVwiXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmNsYXNzIFJhbmdlUmVxdWVzdHNQbHVnaW4ge1xuICAgIGNhY2hlZFJlc3BvbnNlV2lsbEJlVXNlZCA9IGFzeW5jICh7IHJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlIH0pPT57XG4gICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSAmJiByZXF1ZXN0LmhlYWRlcnMuaGFzKFwicmFuZ2VcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBjcmVhdGVQYXJ0aWFsUmVzcG9uc2UocmVxdWVzdCwgY2FjaGVkUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBkZWZhdWx0SGVhZGVyc1RvQ2hlY2sgYXMgQlJPQURDQVNUX1VQREFURV9ERUZBVUxUX0hFQURFUlMsIENBQ0hFX1VQREFURURfTUVTU0FHRV9NRVRBIGFzIEJST0FEQ0FTVF9VUERBVEVfTUVTU0FHRV9NRVRBLCBDQUNIRV9VUERBVEVEX01FU1NBR0VfVFlQRSBhcyBCUk9BRENBU1RfVVBEQVRFX01FU1NBR0VfVFlQRSwgQnJvYWRjYXN0Q2FjaGVVcGRhdGUsIEJyb2FkY2FzdFVwZGF0ZVBsdWdpbiwgQ2FjaGVFeHBpcmF0aW9uLCBDYWNoZWFibGVSZXNwb25zZSwgQ2FjaGVhYmxlUmVzcG9uc2VQbHVnaW4sIEV4cGlyYXRpb25QbHVnaW4sIFJhbmdlUmVxdWVzdHNQbHVnaW4sIGNyZWF0ZVBhcnRpYWxSZXNwb25zZSwgcmVzcG9uc2VzQXJlU2FtZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.plugins.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.strategies.js":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.strategies.js ***!
  \****************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheFirst: function() { return /* binding */ CacheFirst; },\n/* harmony export */   CacheOnly: function() { return /* binding */ CacheOnly; },\n/* harmony export */   NetworkFirst: function() { return /* reexport safe */ _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.a; },\n/* harmony export */   NetworkOnly: function() { return /* reexport safe */ _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.N; },\n/* harmony export */   StaleWhileRevalidate: function() { return /* binding */ StaleWhileRevalidate; },\n/* harmony export */   Strategy: function() { return /* reexport safe */ _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_1__.S; },\n/* harmony export */   StrategyHandler: function() { return /* reexport safe */ _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_1__.a; }\n/* harmony export */ });\n/* harmony import */ var _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/core/internal */ \"./node_modules/.pnpm/@serwist+core@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/core/dist/index.internal.js\");\n/* harmony import */ var _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/Strategy.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/Strategy.js\");\n/* harmony import */ var _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/NetworkOnly.js */ \"./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/chunks/NetworkOnly.js\");\n\n\n\n\n\n\nclass CacheFirst extends _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_1__.S {\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"makeRequest\",\n                paramName: \"request\"\n            });\n        }\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (!response) {\n            if (true) {\n                logs.push(`No response found in the '${this.cacheName}' cache. Will respond with a network request.`);\n            }\n            try {\n                response = await handler.fetchAndCachePut(request);\n            } catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n            if (true) {\n                if (response) {\n                    logs.push(\"Got response from network.\");\n                } else {\n                    logs.push(\"Unable to get a response from the network.\");\n                }\n            }\n        } else {\n            if (true) {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n            }\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(_chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.m.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(log);\n            }\n            _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.m.printFinalResponse(response);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        if (!response) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\nclass CacheOnly extends _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_1__.S {\n    async _handle(request, handler) {\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"makeRequest\",\n                paramName: \"request\"\n            });\n        }\n        const response = await handler.cacheMatch(request);\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(_chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.m.strategyStart(this.constructor.name, request));\n            if (response) {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`Found a cached response in the '${this.cacheName}' cache.`);\n                _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.m.printFinalResponse(response);\n            } else {\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(`No response found in the '${this.cacheName}' cache.`);\n            }\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        if (!response) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n}\n\nclass StaleWhileRevalidate extends _chunks_Strategy_js__WEBPACK_IMPORTED_MODULE_1__.S {\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(_chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.c);\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.assert.isInstance(request, Request, {\n                moduleName: \"@serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"request\"\n            });\n        }\n        const fetchAndCachePromise = handler.fetchAndCachePut(request).catch(()=>{});\n        void handler.waitUntil(fetchAndCachePromise);\n        let response = await handler.cacheMatch(request);\n        let error = undefined;\n        if (response) {\n            if (true) {\n                logs.push(`Found a cached response in the '${this.cacheName}' cache. Will update with the network response in the background.`);\n            }\n        } else {\n            if (true) {\n                logs.push(`No response found in the '${this.cacheName}' cache. Will wait for the network response.`);\n            }\n            try {\n                response = await fetchAndCachePromise;\n            } catch (err) {\n                if (err instanceof Error) {\n                    error = err;\n                }\n            }\n        }\n        if (true) {\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupCollapsed(_chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.m.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.log(log);\n            }\n            _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_2__.m.printFinalResponse(response);\n            _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.logger.groupEnd();\n        }\n        if (!response) {\n            throw new _serwist_core_internal__WEBPACK_IMPORTED_MODULE_0__.SerwistError(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2luZGV4LnN0cmF0ZWdpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFzRTtBQUNqQjtBQUNPO0FBQ3lCO0FBQ1A7O0FBRTlFLHlCQUF5QixrREFBUTtBQUNqQztBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQXFDO0FBQ3JELHVEQUF1RCxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFxQztBQUNyRDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQkFBZ0IsSUFBcUM7QUFDckQsNkRBQTZELGVBQWU7QUFDNUU7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTSxnQkFBZ0IscURBQVE7QUFDMUM7QUFDQSxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQSxZQUFZLHFEQUFRO0FBQ3BCLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixrREFBUTtBQUNoQztBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBEQUFNLGdCQUFnQixxREFBUTtBQUMxQztBQUNBLGdCQUFnQiwwREFBTSx3Q0FBd0MsZUFBZTtBQUM3RSxnQkFBZ0IscURBQVE7QUFDeEIsY0FBYztBQUNkLGdCQUFnQiwwREFBTSxrQ0FBa0MsZUFBZTtBQUN2RTtBQUNBLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsa0RBQVE7QUFDM0MsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSxpQ0FBaUMscURBQXNCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBEQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQXFDO0FBQ3JELDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQixJQUFxQztBQUNyRCx1REFBdUQsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQsWUFBWSwwREFBTSxnQkFBZ0IscURBQVE7QUFDMUM7QUFDQSxnQkFBZ0IsMERBQU07QUFDdEI7QUFDQSxZQUFZLHFEQUFRO0FBQ3BCLFlBQVksMERBQU07QUFDbEI7QUFDQTtBQUNBLHNCQUFzQixnRUFBWTtBQUNsQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVpRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNlcndpc3Qrc3dAOS4wLjAtcHJldmlldy4yMV90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9Ac2Vyd2lzdC9zdy9kaXN0L2luZGV4LnN0cmF0ZWdpZXMuanM/M2VhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhc3NlcnQsIGxvZ2dlciwgU2Vyd2lzdEVycm9yIH0gZnJvbSAnQHNlcndpc3QvY29yZS9pbnRlcm5hbCc7XG5pbXBvcnQgeyBTIGFzIFN0cmF0ZWd5IH0gZnJvbSAnLi9jaHVua3MvU3RyYXRlZ3kuanMnO1xuZXhwb3J0IHsgYSBhcyBTdHJhdGVneUhhbmRsZXIgfSBmcm9tICcuL2NodW5rcy9TdHJhdGVneS5qcyc7XG5pbXBvcnQgeyBtIGFzIG1lc3NhZ2VzLCBjIGFzIGNhY2hlT2tBbmRPcGFxdWVQbHVnaW4gfSBmcm9tICcuL2NodW5rcy9OZXR3b3JrT25seS5qcyc7XG5leHBvcnQgeyBhIGFzIE5ldHdvcmtGaXJzdCwgTiBhcyBOZXR3b3JrT25seSB9IGZyb20gJy4vY2h1bmtzL05ldHdvcmtPbmx5LmpzJztcblxuY2xhc3MgQ2FjaGVGaXJzdCBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbG9ncyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJAc2Vyd2lzdC9zdHJhdGVnaWVzXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwibWFrZVJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwicmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgTm8gcmVzcG9uc2UgZm91bmQgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuIFdpbGwgcmVzcG9uZCB3aXRoIGEgbmV0d29yayByZXF1ZXN0LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIuZmV0Y2hBbmRDYWNoZVB1dChyZXF1ZXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChcIkdvdCByZXNwb25zZSBmcm9tIG5ldHdvcmsuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChcIlVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3Mpe1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNsYXNzIENhY2hlT25seSBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3RyYXRlZ2llc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcIm1ha2VSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChtZXNzYWdlcy5zdHJhdGVneVN0YXJ0KHRoaXMuY29uc3RydWN0b3IubmFtZSwgcmVxdWVzdCkpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgRm91bmQgYSBjYWNoZWQgcmVzcG9uc2UgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXMucHJpbnRGaW5hbFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTm8gcmVzcG9uc2UgZm91bmQgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNsYXNzIFN0YWxlV2hpbGVSZXZhbGlkYXRlIGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMucGx1Z2lucy5zb21lKChwKT0+XCJjYWNoZVdpbGxVcGRhdGVcIiBpbiBwKSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnVuc2hpZnQoY2FjaGVPa0FuZE9wYXF1ZVBsdWdpbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZShyZXF1ZXN0LCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IGxvZ3MgPSBbXTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgYXNzZXJ0LmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwiQHNlcndpc3Qvc3RyYXRlZ2llc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImhhbmRsZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZldGNoQW5kQ2FjaGVQcm9taXNlID0gaGFuZGxlci5mZXRjaEFuZENhY2hlUHV0KHJlcXVlc3QpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgIHZvaWQgaGFuZGxlci53YWl0VW50aWwoZmV0Y2hBbmRDYWNoZVByb21pc2UpO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKGBGb3VuZCBhIGNhY2hlZCByZXNwb25zZSBpbiB0aGUgJyR7dGhpcy5jYWNoZU5hbWV9JyBjYWNoZS4gV2lsbCB1cGRhdGUgd2l0aCB0aGUgbmV0d29yayByZXNwb25zZSBpbiB0aGUgYmFja2dyb3VuZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dzLnB1c2goYE5vIHJlc3BvbnNlIGZvdW5kIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLiBXaWxsIHdhaXQgZm9yIHRoZSBuZXR3b3JrIHJlc3BvbnNlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoQW5kQ2FjaGVQcm9taXNlO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3Mpe1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENhY2hlRmlyc3QsIENhY2hlT25seSwgU3RhbGVXaGlsZVJldmFsaWRhdGUsIFN0cmF0ZWd5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/@serwist+sw@9.0.0-preview.21_typescript@5.4.5/node_modules/@serwist/sw/dist/index.strategies.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: function() { return /* binding */ deleteDB; },\n/* harmony export */   openDB: function() { return /* binding */ openDB; },\n/* harmony export */   unwrap: function() { return /* binding */ unwrap; },\n/* harmony export */   wrap: function() { return /* binding */ wrap; }\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vaWRiQDguMC4wL25vZGVfbW9kdWxlcy9pZGIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUNBQXlDLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsVUFBVSxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2lkYkA4LjAuMC9ub2RlX21vZHVsZXMvaWRiL2J1aWxkL2luZGV4LmpzPzIzZGQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaW5zdGFuY2VPZkFueSA9IChvYmplY3QsIGNvbnN0cnVjdG9ycykgPT4gY29uc3RydWN0b3JzLnNvbWUoKGMpID0+IG9iamVjdCBpbnN0YW5jZW9mIGMpO1xuXG5sZXQgaWRiUHJveHlhYmxlVHlwZXM7XG5sZXQgY3Vyc29yQWR2YW5jZU1ldGhvZHM7XG4vLyBUaGlzIGlzIGEgZnVuY3Rpb24gdG8gcHJldmVudCBpdCB0aHJvd2luZyB1cCBpbiBub2RlIGVudmlyb25tZW50cy5cbmZ1bmN0aW9uIGdldElkYlByb3h5YWJsZVR5cGVzKCkge1xuICAgIHJldHVybiAoaWRiUHJveHlhYmxlVHlwZXMgfHxcbiAgICAgICAgKGlkYlByb3h5YWJsZVR5cGVzID0gW1xuICAgICAgICAgICAgSURCRGF0YWJhc2UsXG4gICAgICAgICAgICBJREJPYmplY3RTdG9yZSxcbiAgICAgICAgICAgIElEQkluZGV4LFxuICAgICAgICAgICAgSURCQ3Vyc29yLFxuICAgICAgICAgICAgSURCVHJhbnNhY3Rpb24sXG4gICAgICAgIF0pKTtcbn1cbi8vIFRoaXMgaXMgYSBmdW5jdGlvbiB0byBwcmV2ZW50IGl0IHRocm93aW5nIHVwIGluIG5vZGUgZW52aXJvbm1lbnRzLlxuZnVuY3Rpb24gZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKSB7XG4gICAgcmV0dXJuIChjdXJzb3JBZHZhbmNlTWV0aG9kcyB8fFxuICAgICAgICAoY3Vyc29yQWR2YW5jZU1ldGhvZHMgPSBbXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmFkdmFuY2UsXG4gICAgICAgICAgICBJREJDdXJzb3IucHJvdG90eXBlLmNvbnRpbnVlLFxuICAgICAgICAgICAgSURCQ3Vyc29yLnByb3RvdHlwZS5jb250aW51ZVByaW1hcnlLZXksXG4gICAgICAgIF0pKTtcbn1cbmNvbnN0IHRyYW5zYWN0aW9uRG9uZU1hcCA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCB0cmFuc2Zvcm1DYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gcHJvbWlzaWZ5UmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgdW5saXN0ZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N1Y2Nlc3MnLCBzdWNjZXNzKTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHdyYXAocmVxdWVzdC5yZXN1bHQpKTtcbiAgICAgICAgICAgIHVubGlzdGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHJlcXVlc3QuZXJyb3IpO1xuICAgICAgICAgICAgdW5saXN0ZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdzdWNjZXNzJywgc3VjY2Vzcyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gICAgLy8gVGhpcyBtYXBwaW5nIGV4aXN0cyBpbiByZXZlcnNlVHJhbnNmb3JtQ2FjaGUgYnV0IGRvZXNuJ3QgZG9lc24ndCBleGlzdCBpbiB0cmFuc2Zvcm1DYWNoZS4gVGhpc1xuICAgIC8vIGlzIGJlY2F1c2Ugd2UgY3JlYXRlIG1hbnkgcHJvbWlzZXMgZnJvbSBhIHNpbmdsZSBJREJSZXF1ZXN0LlxuICAgIHJldmVyc2VUcmFuc2Zvcm1DYWNoZS5zZXQocHJvbWlzZSwgcmVxdWVzdCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5mdW5jdGlvbiBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odHgpIHtcbiAgICAvLyBFYXJseSBiYWlsIGlmIHdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBhIGRvbmUgcHJvbWlzZSBmb3IgdGhpcyB0cmFuc2FjdGlvbi5cbiAgICBpZiAodHJhbnNhY3Rpb25Eb25lTWFwLmhhcyh0eCkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBkb25lID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1bmxpc3RlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHR4LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbXBsZXRlJywgY29tcGxldGUpO1xuICAgICAgICAgICAgdHgucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB0eC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGVycm9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdCh0eC5lcnJvciB8fCBuZXcgRE9NRXhjZXB0aW9uKCdBYm9ydEVycm9yJywgJ0Fib3J0RXJyb3InKSk7XG4gICAgICAgICAgICB1bmxpc3RlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0eC5hZGRFdmVudExpc3RlbmVyKCdjb21wbGV0ZScsIGNvbXBsZXRlKTtcbiAgICAgICAgdHguYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHR4LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgZXJyb3IpO1xuICAgIH0pO1xuICAgIC8vIENhY2hlIGl0IGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAgdHJhbnNhY3Rpb25Eb25lTWFwLnNldCh0eCwgZG9uZSk7XG59XG5sZXQgaWRiUHJveHlUcmFwcyA9IHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSURCVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIHRyYW5zYWN0aW9uLmRvbmUuXG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ2RvbmUnKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkRvbmVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgICAgICAvLyBNYWtlIHR4LnN0b3JlIHJldHVybiB0aGUgb25seSBzdG9yZSBpbiB0aGUgdHJhbnNhY3Rpb24sIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBhcmUgbWFueS5cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnc3RvcmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpdmVyLm9iamVjdFN0b3JlTmFtZXNbMV1cbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiByZWNlaXZlci5vYmplY3RTdG9yZShyZWNlaXZlci5vYmplY3RTdG9yZU5hbWVzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBFbHNlIHRyYW5zZm9ybSB3aGF0ZXZlciB3ZSBnZXQgYmFjay5cbiAgICAgICAgcmV0dXJuIHdyYXAodGFyZ2V0W3Byb3BdKTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICAocHJvcCA9PT0gJ2RvbmUnIHx8IHByb3AgPT09ICdzdG9yZScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcCBpbiB0YXJnZXQ7XG4gICAgfSxcbn07XG5mdW5jdGlvbiByZXBsYWNlVHJhcHMoY2FsbGJhY2spIHtcbiAgICBpZGJQcm94eVRyYXBzID0gY2FsbGJhY2soaWRiUHJveHlUcmFwcyk7XG59XG5mdW5jdGlvbiB3cmFwRnVuY3Rpb24oZnVuYykge1xuICAgIC8vIER1ZSB0byBleHBlY3RlZCBvYmplY3QgZXF1YWxpdHkgKHdoaWNoIGlzIGVuZm9yY2VkIGJ5IHRoZSBjYWNoaW5nIGluIGB3cmFwYCksIHdlXG4gICAgLy8gb25seSBjcmVhdGUgb25lIG5ldyBmdW5jIHBlciBmdW5jLlxuICAgIC8vIEN1cnNvciBtZXRob2RzIGFyZSBzcGVjaWFsLCBhcyB0aGUgYmVoYXZpb3VyIGlzIGEgbGl0dGxlIG1vcmUgZGlmZmVyZW50IHRvIHN0YW5kYXJkIElEQi4gSW5cbiAgICAvLyBJREIsIHlvdSBhZHZhbmNlIHRoZSBjdXJzb3IgYW5kIHdhaXQgZm9yIGEgbmV3ICdzdWNjZXNzJyBvbiB0aGUgSURCUmVxdWVzdCB0aGF0IGdhdmUgeW91IHRoZVxuICAgIC8vIGN1cnNvci4gSXQncyBraW5kYSBsaWtlIGEgcHJvbWlzZSB0aGF0IGNhbiByZXNvbHZlIHdpdGggbWFueSB2YWx1ZXMuIFRoYXQgZG9lc24ndCBtYWtlIHNlbnNlXG4gICAgLy8gd2l0aCByZWFsIHByb21pc2VzLCBzbyBlYWNoIGFkdmFuY2UgbWV0aG9kcyByZXR1cm5zIGEgbmV3IHByb21pc2UgZm9yIHRoZSBjdXJzb3Igb2JqZWN0LCBvclxuICAgIC8vIHVuZGVmaW5lZCBpZiB0aGUgZW5kIG9mIHRoZSBjdXJzb3IgaGFzIGJlZW4gcmVhY2hlZC5cbiAgICBpZiAoZ2V0Q3Vyc29yQWR2YW5jZU1ldGhvZHMoKS5pbmNsdWRlcyhmdW5jKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIENhbGxpbmcgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3h5IGFzICd0aGlzJyBjYXVzZXMgSUxMRUdBTCBJTlZPQ0FUSU9OLCBzbyB3ZSB1c2VcbiAgICAgICAgICAgIC8vIHRoZSBvcmlnaW5hbCBvYmplY3QuXG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gd3JhcCh0aGlzLnJlcXVlc3QpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgLy8gQ2FsbGluZyB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJveHkgYXMgJ3RoaXMnIGNhdXNlcyBJTExFR0FMIElOVk9DQVRJT04sIHNvIHdlIHVzZVxuICAgICAgICAvLyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgICByZXR1cm4gd3JhcChmdW5jLmFwcGx5KHVud3JhcCh0aGlzKSwgYXJncykpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbih2YWx1ZSk7XG4gICAgLy8gVGhpcyBkb2Vzbid0IHJldHVybiwgaXQganVzdCBjcmVhdGVzIGEgJ2RvbmUnIHByb21pc2UgZm9yIHRoZSB0cmFuc2FjdGlvbixcbiAgICAvLyB3aGljaCBpcyBsYXRlciByZXR1cm5lZCBmb3IgdHJhbnNhY3Rpb24uZG9uZSAoc2VlIGlkYk9iamVjdEhhbmRsZXIpLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlRyYW5zYWN0aW9uKVxuICAgICAgICBjYWNoZURvbmVQcm9taXNlRm9yVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIGlmIChpbnN0YW5jZU9mQW55KHZhbHVlLCBnZXRJZGJQcm94eWFibGVUeXBlcygpKSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh2YWx1ZSwgaWRiUHJveHlUcmFwcyk7XG4gICAgLy8gUmV0dXJuIHRoZSBzYW1lIHZhbHVlIGJhY2sgaWYgd2UncmUgbm90IGdvaW5nIHRvIHRyYW5zZm9ybSBpdC5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB3cmFwKHZhbHVlKSB7XG4gICAgLy8gV2Ugc29tZXRpbWVzIGdlbmVyYXRlIG11bHRpcGxlIHByb21pc2VzIGZyb20gYSBzaW5nbGUgSURCUmVxdWVzdCAoZWcgd2hlbiBjdXJzb3JpbmcpLCBiZWNhdXNlXG4gICAgLy8gSURCIGlzIHdlaXJkIGFuZCBhIHNpbmdsZSBJREJSZXF1ZXN0IGNhbiB5aWVsZCBtYW55IHJlc3BvbnNlcywgc28gdGhlc2UgY2FuJ3QgYmUgY2FjaGVkLlxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIElEQlJlcXVlc3QpXG4gICAgICAgIHJldHVybiBwcm9taXNpZnlSZXF1ZXN0KHZhbHVlKTtcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHRyYW5zZm9ybWVkIHRoaXMgdmFsdWUgYmVmb3JlLCByZXVzZSB0aGUgdHJhbnNmb3JtZWQgdmFsdWUuXG4gICAgLy8gVGhpcyBpcyBmYXN0ZXIsIGJ1dCBpdCBhbHNvIHByb3ZpZGVzIG9iamVjdCBlcXVhbGl0eS5cbiAgICBpZiAodHJhbnNmb3JtQ2FjaGUuaGFzKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB0cmFuc2Zvcm1DYWNoYWJsZVZhbHVlKHZhbHVlKTtcbiAgICAvLyBOb3QgYWxsIHR5cGVzIGFyZSB0cmFuc2Zvcm1lZC5cbiAgICAvLyBUaGVzZSBtYXkgYmUgcHJpbWl0aXZlIHR5cGVzLCBzbyB0aGV5IGNhbid0IGJlIFdlYWtNYXAga2V5cy5cbiAgICBpZiAobmV3VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgIHRyYW5zZm9ybUNhY2hlLnNldCh2YWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICByZXZlcnNlVHJhbnNmb3JtQ2FjaGUuc2V0KG5ld1ZhbHVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZTtcbn1cbmNvbnN0IHVud3JhcCA9ICh2YWx1ZSkgPT4gcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLmdldCh2YWx1ZSk7XG5cbi8qKlxuICogT3BlbiBhIGRhdGFiYXNlLlxuICpcbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGRhdGFiYXNlLlxuICogQHBhcmFtIHZlcnNpb24gU2NoZW1hIHZlcnNpb24uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIEFkZGl0aW9uYWwgY2FsbGJhY2tzLlxuICovXG5mdW5jdGlvbiBvcGVuREIobmFtZSwgdmVyc2lvbiwgeyBibG9ja2VkLCB1cGdyYWRlLCBibG9ja2luZywgdGVybWluYXRlZCB9ID0ge30pIHtcbiAgICBjb25zdCByZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4obmFtZSwgdmVyc2lvbik7XG4gICAgY29uc3Qgb3BlblByb21pc2UgPSB3cmFwKHJlcXVlc3QpO1xuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigndXBncmFkZW5lZWRlZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdXBncmFkZSh3cmFwKHJlcXVlc3QucmVzdWx0KSwgZXZlbnQub2xkVmVyc2lvbiwgZXZlbnQubmV3VmVyc2lvbiwgd3JhcChyZXF1ZXN0LnRyYW5zYWN0aW9uKSwgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50Lm5ld1ZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIG9wZW5Qcm9taXNlXG4gICAgICAgIC50aGVuKChkYikgPT4ge1xuICAgICAgICBpZiAodGVybWluYXRlZClcbiAgICAgICAgICAgIGRiLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4gdGVybWluYXRlZCgpKTtcbiAgICAgICAgaWYgKGJsb2NraW5nKSB7XG4gICAgICAgICAgICBkYi5hZGRFdmVudExpc3RlbmVyKCd2ZXJzaW9uY2hhbmdlJywgKGV2ZW50KSA9PiBibG9ja2luZyhldmVudC5vbGRWZXJzaW9uLCBldmVudC5uZXdWZXJzaW9uLCBldmVudCkpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgcmV0dXJuIG9wZW5Qcm9taXNlO1xufVxuLyoqXG4gKiBEZWxldGUgYSBkYXRhYmFzZS5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBkYXRhYmFzZS5cbiAqL1xuZnVuY3Rpb24gZGVsZXRlREIobmFtZSwgeyBibG9ja2VkIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UobmFtZSk7XG4gICAgaWYgKGJsb2NrZWQpIHtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdibG9ja2VkJywgKGV2ZW50KSA9PiBibG9ja2VkKFxuICAgICAgICAvLyBDYXN0aW5nIGR1ZSB0byBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQtRE9NLWxpYi1nZW5lcmF0b3IvcHVsbC8xNDA1XG4gICAgICAgIGV2ZW50Lm9sZFZlcnNpb24sIGV2ZW50KSk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKHJlcXVlc3QpLnRoZW4oKCkgPT4gdW5kZWZpbmVkKTtcbn1cblxuY29uc3QgcmVhZE1ldGhvZHMgPSBbJ2dldCcsICdnZXRLZXknLCAnZ2V0QWxsJywgJ2dldEFsbEtleXMnLCAnY291bnQnXTtcbmNvbnN0IHdyaXRlTWV0aG9kcyA9IFsncHV0JywgJ2FkZCcsICdkZWxldGUnLCAnY2xlYXInXTtcbmNvbnN0IGNhY2hlZE1ldGhvZHMgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB7XG4gICAgaWYgKCEodGFyZ2V0IGluc3RhbmNlb2YgSURCRGF0YWJhc2UgJiZcbiAgICAgICAgIShwcm9wIGluIHRhcmdldCkgJiZcbiAgICAgICAgdHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjYWNoZWRNZXRob2RzLmdldChwcm9wKSlcbiAgICAgICAgcmV0dXJuIGNhY2hlZE1ldGhvZHMuZ2V0KHByb3ApO1xuICAgIGNvbnN0IHRhcmdldEZ1bmNOYW1lID0gcHJvcC5yZXBsYWNlKC9Gcm9tSW5kZXgkLywgJycpO1xuICAgIGNvbnN0IHVzZUluZGV4ID0gcHJvcCAhPT0gdGFyZ2V0RnVuY05hbWU7XG4gICAgY29uc3QgaXNXcml0ZSA9IHdyaXRlTWV0aG9kcy5pbmNsdWRlcyh0YXJnZXRGdW5jTmFtZSk7XG4gICAgaWYgKFxuICAgIC8vIEJhaWwgaWYgdGhlIHRhcmdldCBkb2Vzbid0IGV4aXN0IG9uIHRoZSB0YXJnZXQuIEVnLCBnZXRBbGwgaXNuJ3QgaW4gRWRnZS5cbiAgICAhKHRhcmdldEZ1bmNOYW1lIGluICh1c2VJbmRleCA/IElEQkluZGV4IDogSURCT2JqZWN0U3RvcmUpLnByb3RvdHlwZSkgfHxcbiAgICAgICAgIShpc1dyaXRlIHx8IHJlYWRNZXRob2RzLmluY2x1ZGVzKHRhcmdldEZ1bmNOYW1lKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2QgPSBhc3luYyBmdW5jdGlvbiAoc3RvcmVOYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIGlzV3JpdGUgPyAncmVhZHdyaXRlJyA6IHVuZGVmaW5lZCBnemlwcHMgYmV0dGVyLCBidXQgZmFpbHMgaW4gRWRnZSA6KFxuICAgICAgICBjb25zdCB0eCA9IHRoaXMudHJhbnNhY3Rpb24oc3RvcmVOYW1lLCBpc1dyaXRlID8gJ3JlYWR3cml0ZScgOiAncmVhZG9ubHknKTtcbiAgICAgICAgbGV0IHRhcmdldCA9IHR4LnN0b3JlO1xuICAgICAgICBpZiAodXNlSW5kZXgpXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaW5kZXgoYXJncy5zaGlmdCgpKTtcbiAgICAgICAgLy8gTXVzdCByZWplY3QgaWYgb3AgcmVqZWN0cy5cbiAgICAgICAgLy8gSWYgaXQncyBhIHdyaXRlIG9wZXJhdGlvbiwgbXVzdCByZWplY3QgaWYgdHguZG9uZSByZWplY3RzLlxuICAgICAgICAvLyBNdXN0IHJlamVjdCB3aXRoIG9wIHJlamVjdGlvbiBmaXJzdC5cbiAgICAgICAgLy8gTXVzdCByZXNvbHZlIHdpdGggb3AgdmFsdWUuXG4gICAgICAgIC8vIE11c3QgaGFuZGxlIGJvdGggcHJvbWlzZXMgKG5vIHVuaGFuZGxlZCByZWplY3Rpb25zKVxuICAgICAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIHRhcmdldFt0YXJnZXRGdW5jTmFtZV0oLi4uYXJncyksXG4gICAgICAgICAgICBpc1dyaXRlICYmIHR4LmRvbmUsXG4gICAgICAgIF0pKVswXTtcbiAgICB9O1xuICAgIGNhY2hlZE1ldGhvZHMuc2V0KHByb3AsIG1ldGhvZCk7XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4gZ2V0TWV0aG9kKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpLFxuICAgIGhhczogKHRhcmdldCwgcHJvcCkgPT4gISFnZXRNZXRob2QodGFyZ2V0LCBwcm9wKSB8fCBvbGRUcmFwcy5oYXModGFyZ2V0LCBwcm9wKSxcbn0pKTtcblxuY29uc3QgYWR2YW5jZU1ldGhvZFByb3BzID0gWydjb250aW51ZScsICdjb250aW51ZVByaW1hcnlLZXknLCAnYWR2YW5jZSddO1xuY29uc3QgbWV0aG9kTWFwID0ge307XG5jb25zdCBhZHZhbmNlUmVzdWx0cyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eSA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBjdXJzb3JJdGVyYXRvclRyYXBzID0ge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgaWYgKCFhZHZhbmNlTWV0aG9kUHJvcHMuaW5jbHVkZXMocHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICBsZXQgY2FjaGVkRnVuYyA9IG1ldGhvZE1hcFtwcm9wXTtcbiAgICAgICAgaWYgKCFjYWNoZWRGdW5jKSB7XG4gICAgICAgICAgICBjYWNoZWRGdW5jID0gbWV0aG9kTWFwW3Byb3BdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhZHZhbmNlUmVzdWx0cy5zZXQodGhpcywgaXR0clByb3hpZWRDdXJzb3JUb09yaWdpbmFsUHJveHkuZ2V0KHRoaXMpW3Byb3BdKC4uLmFyZ3MpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZEZ1bmM7XG4gICAgfSxcbn07XG5hc3luYyBmdW5jdGlvbiogaXRlcmF0ZSguLi5hcmdzKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXRoaXMtYXNzaWdubWVudFxuICAgIGxldCBjdXJzb3IgPSB0aGlzO1xuICAgIGlmICghKGN1cnNvciBpbnN0YW5jZW9mIElEQkN1cnNvcikpIHtcbiAgICAgICAgY3Vyc29yID0gYXdhaXQgY3Vyc29yLm9wZW5DdXJzb3IoLi4uYXJncyk7XG4gICAgfVxuICAgIGlmICghY3Vyc29yKVxuICAgICAgICByZXR1cm47XG4gICAgY3Vyc29yID0gY3Vyc29yO1xuICAgIGNvbnN0IHByb3hpZWRDdXJzb3IgPSBuZXcgUHJveHkoY3Vyc29yLCBjdXJzb3JJdGVyYXRvclRyYXBzKTtcbiAgICBpdHRyUHJveGllZEN1cnNvclRvT3JpZ2luYWxQcm94eS5zZXQocHJveGllZEN1cnNvciwgY3Vyc29yKTtcbiAgICAvLyBNYXAgdGhpcyBkb3VibGUtcHJveHkgYmFjayB0byB0aGUgb3JpZ2luYWwsIHNvIG90aGVyIGN1cnNvciBtZXRob2RzIHdvcmsuXG4gICAgcmV2ZXJzZVRyYW5zZm9ybUNhY2hlLnNldChwcm94aWVkQ3Vyc29yLCB1bndyYXAoY3Vyc29yKSk7XG4gICAgd2hpbGUgKGN1cnNvcikge1xuICAgICAgICB5aWVsZCBwcm94aWVkQ3Vyc29yO1xuICAgICAgICAvLyBJZiBvbmUgb2YgdGhlIGFkdmFuY2luZyBtZXRob2RzIHdhcyBub3QgY2FsbGVkLCBjYWxsIGNvbnRpbnVlKCkuXG4gICAgICAgIGN1cnNvciA9IGF3YWl0IChhZHZhbmNlUmVzdWx0cy5nZXQocHJveGllZEN1cnNvcikgfHwgY3Vyc29yLmNvbnRpbnVlKCkpO1xuICAgICAgICBhZHZhbmNlUmVzdWx0cy5kZWxldGUocHJveGllZEN1cnNvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJdGVyYXRvclByb3AodGFyZ2V0LCBwcm9wKSB7XG4gICAgcmV0dXJuICgocHJvcCA9PT0gU3ltYm9sLmFzeW5jSXRlcmF0b3IgJiZcbiAgICAgICAgaW5zdGFuY2VPZkFueSh0YXJnZXQsIFtJREJJbmRleCwgSURCT2JqZWN0U3RvcmUsIElEQkN1cnNvcl0pKSB8fFxuICAgICAgICAocHJvcCA9PT0gJ2l0ZXJhdGUnICYmIGluc3RhbmNlT2ZBbnkodGFyZ2V0LCBbSURCSW5kZXgsIElEQk9iamVjdFN0b3JlXSkpKTtcbn1cbnJlcGxhY2VUcmFwcygob2xkVHJhcHMpID0+ICh7XG4gICAgLi4ub2xkVHJhcHMsXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgaWYgKGlzSXRlcmF0b3JQcm9wKHRhcmdldCwgcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZTtcbiAgICAgICAgcmV0dXJuIG9sZFRyYXBzLmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGlzSXRlcmF0b3JQcm9wKHRhcmdldCwgcHJvcCkgfHwgb2xkVHJhcHMuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgfSxcbn0pKTtcblxuZXhwb3J0IHsgZGVsZXRlREIsIG9wZW5EQiwgdW53cmFwLCB3cmFwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js\n"));

/***/ }),

/***/ "./app/sw.js":
/*!*******************!*\
  !*** ./app/sw.js ***!
  \*******************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _serwist_next_worker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @serwist/next/worker */ \"./node_modules/.pnpm/@serwist+next@9.0.0-preview.21_next@14.2.1_typescript@5.4.5_webpack@5.91.0/node_modules/@serwist/next/dist/index.worker.js\");\n/* harmony import */ var serwist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! serwist */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/index.js\");\n\n\nconst serwist = new serwist__WEBPACK_IMPORTED_MODULE_1__.Serwist({\n    precacheEntries: undefined,\n    skipWaiting: true,\n    clientsClaim: true,\n    navigationPreload: true,\n    runtimeCaching: _serwist_next_worker__WEBPACK_IMPORTED_MODULE_0__.defaultCache\n});\nserwist.addEventListeners();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = __webpack_module__.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                __webpack_module__.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                /* unsupported import.meta.webpackHot */ undefined.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        __webpack_module__.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    __webpack_module__.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAvc3cuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQW1EO0FBQ2xCO0FBRWpDLE1BQU1FLFVBQVUsSUFBSUQsNENBQU9BLENBQUM7SUFDMUJFLGlCQUFpQkMsS0FBS0MsYUFBYTtJQUNuQ0MsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLG1CQUFtQjtJQUNuQkMsZ0JBQWdCVCw4REFBWUE7QUFDOUI7QUFFQUUsUUFBUVEsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9zdy5qcz9lODQ4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlZmF1bHRDYWNoZSB9IGZyb20gJ0BzZXJ3aXN0L25leHQvd29ya2VyJ1xuaW1wb3J0IHsgU2Vyd2lzdCB9IGZyb20gJ3Nlcndpc3QnXG5cbmNvbnN0IHNlcndpc3QgPSBuZXcgU2Vyd2lzdCh7XG4gIHByZWNhY2hlRW50cmllczogc2VsZi5fX1NXX01BTklGRVNULFxuICBza2lwV2FpdGluZzogdHJ1ZSxcbiAgY2xpZW50c0NsYWltOiB0cnVlLFxuICBuYXZpZ2F0aW9uUHJlbG9hZDogdHJ1ZSxcbiAgcnVudGltZUNhY2hpbmc6IGRlZmF1bHRDYWNoZSxcbn0pXG5cbnNlcndpc3QuYWRkRXZlbnRMaXN0ZW5lcnMoKVxuIl0sIm5hbWVzIjpbImRlZmF1bHRDYWNoZSIsIlNlcndpc3QiLCJzZXJ3aXN0IiwicHJlY2FjaGVFbnRyaWVzIiwic2VsZiIsIl9fU1dfTUFOSUZFU1QiLCJza2lwV2FpdGluZyIsImNsaWVudHNDbGFpbSIsIm5hdmlnYXRpb25QcmVsb2FkIiwicnVudGltZUNhY2hpbmciLCJhZGRFdmVudExpc3RlbmVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/sw.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/NetworkOnly.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/NetworkOnly.js ***!
  \**********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: function() { return /* binding */ NetworkOnly; },\n/* harmony export */   S: function() { return /* binding */ Strategy; },\n/* harmony export */   a: function() { return /* binding */ NetworkFirst; },\n/* harmony export */   b: function() { return /* binding */ StrategyHandler; },\n/* harmony export */   c: function() { return /* binding */ cacheOkAndOpaquePlugin; },\n/* harmony export */   m: function() { return /* binding */ messages; }\n/* harmony export */ });\n/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timeout.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js\");\n\n\nfunction toRequest(input) {\n    return typeof input === \"string\" ? new Request(input) : input;\n}\nclass StrategyHandler {\n    event;\n    request;\n    url;\n    params;\n    _cacheKeys = {};\n    _strategy;\n    _handlerDeferred;\n    _extendLifetimePromises;\n    _plugins;\n    _pluginStateMap;\n    constructor(strategy, options){\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(options.event, ExtendableEvent, {\n                moduleName: \"serwist/strategies\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.event\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(options.request, Request, {\n                moduleName: \"serwist/strategies\",\n                className: \"StrategyHandler\",\n                funcName: \"constructor\",\n                paramName: \"options.request\"\n            });\n        }\n        this.event = options.event;\n        this.request = options.request;\n        if (options.url) {\n            this.url = options.url;\n            this.params = options.params;\n        }\n        this._strategy = strategy;\n        this._handlerDeferred = new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.D();\n        this._extendLifetimePromises = [];\n        this._plugins = [\n            ...strategy.plugins\n        ];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins){\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    async fetch(input) {\n        const { event } = this;\n        let request = toRequest(input);\n        if (request.mode === \"navigate\" && event instanceof FetchEvent && event.preloadResponse) {\n            const possiblePreloadResponse = await event.preloadResponse;\n            if (possiblePreloadResponse) {\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Using a preloaded navigation response for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}'`);\n                }\n                return possiblePreloadResponse;\n            }\n        }\n        const originalRequest = this.hasCallback(\"fetchDidFail\") ? request.clone() : null;\n        try {\n            for (const cb of this.iterateCallbacks(\"requestWillFetch\")){\n                request = await cb({\n                    request: request.clone(),\n                    event\n                });\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"plugin-error-request-will-fetch\", {\n                    thrownErrorMessage: err.message\n                });\n            }\n        }\n        const pluginFilteredRequest = request.clone();\n        try {\n            let fetchResponse;\n            fetchResponse = await fetch(request, request.mode === \"navigate\" ? undefined : this._strategy.fetchOptions);\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Network request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}' returned a response with status '${fetchResponse.status}'.`);\n            }\n            for (const callback of this.iterateCallbacks(\"fetchDidSucceed\")){\n                fetchResponse = await callback({\n                    event,\n                    request: pluginFilteredRequest,\n                    response: fetchResponse\n                });\n            }\n            return fetchResponse;\n        } catch (error) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Network request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}' threw an error.`, error);\n            }\n            if (originalRequest) {\n                await this.runCallbacks(\"fetchDidFail\", {\n                    error: error,\n                    event,\n                    originalRequest: originalRequest.clone(),\n                    request: pluginFilteredRequest.clone()\n                });\n            }\n            throw error;\n        }\n    }\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        void this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    async cacheMatch(key) {\n        const request = toRequest(key);\n        let cachedResponse;\n        const { cacheName, matchOptions } = this._strategy;\n        const effectiveRequest = await this.getCacheKey(request, \"read\");\n        const multiMatchOptions = {\n            ...matchOptions,\n            ...{\n                cacheName\n            }\n        };\n        cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n        if (true) {\n            if (cachedResponse) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Found a cached response in '${cacheName}'.`);\n            } else {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`No cached response found in '${cacheName}'.`);\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cachedResponseWillBeUsed\")){\n            cachedResponse = await callback({\n                cacheName,\n                matchOptions,\n                cachedResponse,\n                request: effectiveRequest,\n                event: this.event\n            }) || undefined;\n        }\n        return cachedResponse;\n    }\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        await (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.t)(0);\n        const effectiveRequest = await this.getCacheKey(request, \"write\");\n        if (true) {\n            if (effectiveRequest.method && effectiveRequest.method !== \"GET\") {\n                throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"attempt-to-cache-non-get-request\", {\n                    url: (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url),\n                    method: effectiveRequest.method\n                });\n            }\n        }\n        if (!response) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.error(`Cannot cache non-existent response for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)}'.`);\n            }\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"cache-put-with-no-response\", {\n                url: (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Response '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)}' will not be cached.`, responseToCache);\n            }\n            return false;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        if (true) {\n            const vary = response.headers.get(\"Vary\");\n            if (vary && matchOptions?.ignoreVary !== true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The response for ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)} has a 'Vary: ${vary}' header. Consider setting the {ignoreVary: true} option on your strategy to ensure cache matching and deletion works as expected.`);\n            }\n        }\n        const hasCacheUpdateCallback = this.hasCallback(\"cacheDidUpdate\");\n        const oldResponse = hasCacheUpdateCallback ? await (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.a)(cache, effectiveRequest.clone(), [\n            \"__WB_REVISION__\"\n        ], matchOptions) : null;\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Updating the '${cacheName}' cache with a new Response for ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n        } catch (error) {\n            if (error instanceof Error) {\n                if (error.name === \"QuotaExceededError\") {\n                    await (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.e)();\n                }\n                throw error;\n            }\n        }\n        for (const callback of this.iterateCallbacks(\"cacheDidUpdate\")){\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event\n            });\n        }\n        return true;\n    }\n    async getCacheKey(request, mode) {\n        const key = `${request.url} | ${mode}`;\n        if (!this._cacheKeys[key]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks(\"cacheKeyWillBeUsed\")){\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    params: this.params\n                }));\n            }\n            this._cacheKeys[key] = effectiveRequest;\n        }\n        return this._cacheKeys[key];\n    }\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins){\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)){\n            await callback(param);\n        }\n    }\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins){\n            if (typeof plugin[name] === \"function\") {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param)=>{\n                    const statefulParam = {\n                        ...param,\n                        state\n                    };\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    async doneWaiting() {\n        let promise = undefined;\n        while(promise = this._extendLifetimePromises.shift()){\n            await promise;\n        }\n    }\n    destroy() {\n        this._handlerDeferred.resolve(null);\n    }\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks(\"cacheWillUpdate\")){\n            responseToCache = await callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event\n            }) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (true) {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`The response for '${this.request.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`);\n                        } else {\n                            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The response for '${this.request.url}' returned a status code of '${response.status}' and won't be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\n\nclass Strategy {\n    cacheName;\n    plugins;\n    fetchOptions;\n    matchOptions;\n    constructor(options = {}){\n        this.cacheName = _timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getRuntimeName(options.cacheName);\n        this.plugins = options.plugins || [];\n        this.fetchOptions = options.fetchOptions;\n        this.matchOptions = options.matchOptions;\n    }\n    handle(options) {\n        const [responseDone] = this.handleAll(options);\n        return responseDone;\n    }\n    handleAll(options) {\n        if (options instanceof FetchEvent) {\n            options = {\n                event: options,\n                request: options.request\n            };\n        }\n        const event = options.event;\n        const request = typeof options.request === \"string\" ? new Request(options.request) : options.request;\n        const handler = new StrategyHandler(this, options.url ? {\n            event,\n            request,\n            url: options.url,\n            params: options.params\n        } : {\n            event,\n            request\n        });\n        const responseDone = this._getResponse(handler, request, event);\n        const handlerDone = this._awaitComplete(responseDone, handler, request, event);\n        return [\n            responseDone,\n            handlerDone\n        ];\n    }\n    async _getResponse(handler, request, event) {\n        await handler.runCallbacks(\"handlerWillStart\", {\n            event,\n            request\n        });\n        let response = undefined;\n        try {\n            response = await this._handle(request, handler);\n            if (response === undefined || response.type === \"error\") {\n                throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"no-response\", {\n                    url: request.url\n                });\n            }\n        } catch (error) {\n            if (error instanceof Error) {\n                for (const callback of handler.iterateCallbacks(\"handlerDidError\")){\n                    response = await callback({\n                        error,\n                        event,\n                        request\n                    });\n                    if (response !== undefined) {\n                        break;\n                    }\n                }\n            }\n            if (!response) {\n                throw error;\n            }\n            if (true) {\n                throw _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`While responding to '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}', an ${error instanceof Error ? error.toString() : \"\"} error occurred. Using a fallback response provided by a handlerDidError plugin.`);\n            }\n        }\n        for (const callback of handler.iterateCallbacks(\"handlerWillRespond\")){\n            response = await callback({\n                event,\n                request,\n                response\n            });\n        }\n        return response;\n    }\n    async _awaitComplete(responseDone, handler, request, event) {\n        let response = undefined;\n        let error = undefined;\n        try {\n            response = await responseDone;\n        } catch (error) {}\n        try {\n            await handler.runCallbacks(\"handlerDidRespond\", {\n                event,\n                request,\n                response\n            });\n            await handler.doneWaiting();\n        } catch (waitUntilError) {\n            if (waitUntilError instanceof Error) {\n                error = waitUntilError;\n            }\n        }\n        await handler.runCallbacks(\"handlerDidComplete\", {\n            event,\n            request,\n            response,\n            error\n        });\n        handler.destroy();\n        if (error) {\n            throw error;\n        }\n    }\n}\n\nconst cacheOkAndOpaquePlugin = {\n    cacheWillUpdate: async ({ response })=>{\n        if (response.status === 200 || response.status === 0) {\n            return response;\n        }\n        return null;\n    }\n};\n\nconst messages = {\n    strategyStart: (strategyName, request)=>`Using ${strategyName} to respond to '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}'`,\n    printFinalResponse: (response)=>{\n        if (response) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(\"View the final response here.\");\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(response || \"[No response returned]\");\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n    }\n};\n\nclass NetworkFirst extends Strategy {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        if (!this.plugins.some((p)=>\"cacheWillUpdate\" in p)) {\n            this.plugins.unshift(cacheOkAndOpaquePlugin);\n        }\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n        if (true) {\n            if (this._networkTimeoutSeconds) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(this._networkTimeoutSeconds, \"number\", {\n                    moduleName: \"serwist/strategies\",\n                    className: this.constructor.name,\n                    funcName: \"constructor\",\n                    paramName: \"networkTimeoutSeconds\"\n                });\n            }\n        }\n    }\n    async _handle(request, handler) {\n        const logs = [];\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(request, Request, {\n                moduleName: \"serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"handle\",\n                paramName: \"makeRequest\"\n            });\n        }\n        const promises = [];\n        let timeoutId;\n        if (this._networkTimeoutSeconds) {\n            const { id, promise } = this._getTimeoutPromise({\n                request,\n                logs,\n                handler\n            });\n            timeoutId = id;\n            promises.push(promise);\n        }\n        const networkPromise = this._getNetworkPromise({\n            timeoutId,\n            request,\n            logs,\n            handler\n        });\n        promises.push(networkPromise);\n        const response = await handler.waitUntil((async ()=>{\n            return await handler.waitUntil(Promise.race(promises)) || await networkPromise;\n        })());\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            for (const log of logs){\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(log);\n            }\n            messages.printFinalResponse(response);\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"no-response\", {\n                url: request.url\n            });\n        }\n        return response;\n    }\n    _getTimeoutPromise({ request, logs, handler }) {\n        let timeoutId;\n        const timeoutPromise = new Promise((resolve)=>{\n            const onNetworkTimeout = async ()=>{\n                if (true) {\n                    logs.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`);\n                }\n                resolve(await handler.cacheMatch(request));\n            };\n            timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n        });\n        return {\n            promise: timeoutPromise,\n            id: timeoutId\n        };\n    }\n    async _getNetworkPromise({ timeoutId, request, logs, handler }) {\n        let error = undefined;\n        let response = undefined;\n        try {\n            response = await handler.fetchAndCachePut(request);\n        } catch (fetchError) {\n            if (fetchError instanceof Error) {\n                error = fetchError;\n            }\n        }\n        if (timeoutId) {\n            clearTimeout(timeoutId);\n        }\n        if (true) {\n            if (response) {\n                logs.push(\"Got response from network.\");\n            } else {\n                logs.push(\"Unable to get a response from the network. Will respond \" + \"with a cached response.\");\n            }\n        }\n        if (error || !response) {\n            response = await handler.cacheMatch(request);\n            if (true) {\n                if (response) {\n                    logs.push(`Found a cached response in the '${this.cacheName}' cache.`);\n                } else {\n                    logs.push(`No response found in the '${this.cacheName}' cache.`);\n                }\n            }\n        }\n        return response;\n    }\n}\n\nclass NetworkOnly extends Strategy {\n    _networkTimeoutSeconds;\n    constructor(options = {}){\n        super(options);\n        this._networkTimeoutSeconds = options.networkTimeoutSeconds || 0;\n    }\n    async _handle(request, handler) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(request, Request, {\n                moduleName: \"serwist/strategies\",\n                className: this.constructor.name,\n                funcName: \"_handle\",\n                paramName: \"request\"\n            });\n        }\n        let error = undefined;\n        let response;\n        try {\n            const promises = [\n                handler.fetch(request)\n            ];\n            if (this._networkTimeoutSeconds) {\n                const timeoutPromise = (0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.t)(this._networkTimeoutSeconds * 1000);\n                promises.push(timeoutPromise);\n            }\n            response = await Promise.race(promises);\n            if (!response) {\n                throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`);\n            }\n        } catch (err) {\n            if (err instanceof Error) {\n                error = err;\n            }\n        }\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(messages.strategyStart(this.constructor.name, request));\n            if (response) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Got response from network.\");\n            } else {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Unable to get a response from the network.\");\n            }\n            messages.printFinalResponse(response);\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        if (!response) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"no-response\", {\n                url: request.url,\n                error\n            });\n        }\n        return response;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvTmV0d29ya09ubHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3Tjs7QUFFeE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDBDQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQXFDO0FBQ3pELG9CQUFvQiwwQ0FBTSxtREFBbUQsOENBQWMsY0FBYztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBLDBCQUEwQiwwQ0FBWTtBQUN0QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsSUFBcUM7QUFDckQsZ0JBQWdCLDBDQUFNLCtCQUErQiw4Q0FBYyxjQUFjLHFDQUFxQyxxQkFBcUI7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsZ0JBQWdCLElBQXFDO0FBQ3JELGdCQUFnQiwwQ0FBTSw2QkFBNkIsOENBQWMs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QTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksMENBQU07QUFDbEI7QUFDQSxnQkFBZ0IsMENBQU07QUFDdEIsY0FBYztBQUNkLGdCQUFnQiwwQ0FBTTtBQUN0QjtBQUNBO0FBQ0EsWUFBWSwwQ0FBTTtBQUNsQjtBQUNBO0FBQ0Esc0JBQXNCLDBDQUFZO0FBQ2xDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRWdJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zZXJ3aXN0QDkuMC4wLXByZXZpZXcuMjRfdHlwZXNjcmlwdEA1LjQuNS9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2NodW5rcy9OZXR3b3JrT25seS5qcz82NTFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGYgYXMgZmluYWxBc3NlcnRFeHBvcnRzLCBEIGFzIERlZmVycmVkLCBsIGFzIGxvZ2dlciwgZyBhcyBnZXRGcmllbmRseVVSTCwgUyBhcyBTZXJ3aXN0RXJyb3IsIHQgYXMgdGltZW91dCwgYSBhcyBjYWNoZU1hdGNoSWdub3JlUGFyYW1zLCBlIGFzIGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzLCBjIGFzIGNhY2hlTmFtZXMgfSBmcm9tICcuL3RpbWVvdXQuanMnO1xuXG5mdW5jdGlvbiB0b1JlcXVlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiID8gbmV3IFJlcXVlc3QoaW5wdXQpIDogaW5wdXQ7XG59XG5jbGFzcyBTdHJhdGVneUhhbmRsZXIge1xuICAgIGV2ZW50O1xuICAgIHJlcXVlc3Q7XG4gICAgdXJsO1xuICAgIHBhcmFtcztcbiAgICBfY2FjaGVLZXlzID0ge307XG4gICAgX3N0cmF0ZWd5O1xuICAgIF9oYW5kbGVyRGVmZXJyZWQ7XG4gICAgX2V4dGVuZExpZmV0aW1lUHJvbWlzZXM7XG4gICAgX3BsdWdpbnM7XG4gICAgX3BsdWdpblN0YXRlTWFwO1xuICAgIGNvbnN0cnVjdG9yKHN0cmF0ZWd5LCBvcHRpb25zKXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2Uob3B0aW9ucy5ldmVudCwgRXh0ZW5kYWJsZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0L3N0cmF0ZWdpZXNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiU3RyYXRlZ3lIYW5kbGVyXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwib3B0aW9ucy5ldmVudFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKG9wdGlvbnMucmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdC9zdHJhdGVnaWVzXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlN0cmF0ZWd5SGFuZGxlclwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9wdGlvbnMucmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gb3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgIHRoaXMudXJsID0gb3B0aW9ucy51cmw7XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIHRoaXMuX2hhbmRsZXJEZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLl9leHRlbmRMaWZldGltZVByb21pc2VzID0gW107XG4gICAgICAgIHRoaXMuX3BsdWdpbnMgPSBbXG4gICAgICAgICAgICAuLi5zdHJhdGVneS5wbHVnaW5zXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX3BsdWdpblN0YXRlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9wbHVnaW5zKXtcbiAgICAgICAgICAgIHRoaXMuX3BsdWdpblN0YXRlTWFwLnNldChwbHVnaW4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50LndhaXRVbnRpbCh0aGlzLl9oYW5kbGVyRGVmZXJyZWQucHJvbWlzZSk7XG4gICAgfVxuICAgIGFzeW5jIGZldGNoKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgZXZlbnQgfSA9IHRoaXM7XG4gICAgICAgIGxldCByZXF1ZXN0ID0gdG9SZXF1ZXN0KGlucHV0KTtcbiAgICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gXCJuYXZpZ2F0ZVwiICYmIGV2ZW50IGluc3RhbmNlb2YgRmV0Y2hFdmVudCAmJiBldmVudC5wcmVsb2FkUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlID0gYXdhaXQgZXZlbnQucHJlbG9hZFJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJlbG9hZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBVc2luZyBhIHByZWxvYWRlZCBuYXZpZ2F0aW9uIHJlc3BvbnNlIGZvciAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcG9zc2libGVQcmVsb2FkUmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXF1ZXN0ID0gdGhpcy5oYXNDYWxsYmFjayhcImZldGNoRGlkRmFpbFwiKSA/IHJlcXVlc3QuY2xvbmUoKSA6IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNiIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcInJlcXVlc3RXaWxsRmV0Y2hcIikpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBhd2FpdCBjYih7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwicGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93bkVycm9yTWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QgPSByZXF1ZXN0LmNsb25lKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgICAgIGZldGNoUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCByZXF1ZXN0Lm1vZGUgPT09IFwibmF2aWdhdGVcIiA/IHVuZGVmaW5lZCA6IHRoaXMuX3N0cmF0ZWd5LmZldGNoT3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBOZXR3b3JrIHJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nIHJldHVybmVkIGEgcmVzcG9uc2Ugd2l0aCBzdGF0dXMgJyR7ZmV0Y2hSZXNwb25zZS5zdGF0dXN9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiZmV0Y2hEaWRTdWNjZWVkXCIpKXtcbiAgICAgICAgICAgICAgICBmZXRjaFJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcGx1Z2luRmlsdGVyZWRSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZmV0Y2hSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoUmVzcG9uc2U7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgTmV0d29yayByZXF1ZXN0IGZvciAnJHtnZXRGcmllbmRseVVSTChyZXF1ZXN0LnVybCl9JyB0aHJldyBhbiBlcnJvci5gLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5ydW5DYWxsYmFja3MoXCJmZXRjaERpZEZhaWxcIiwge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFJlcXVlc3Q6IG9yaWdpbmFsUmVxdWVzdC5jbG9uZSgpLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBwbHVnaW5GaWx0ZXJlZFJlcXVlc3QuY2xvbmUoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hBbmRDYWNoZVB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZmV0Y2goaW5wdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZUNsb25lID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgdm9pZCB0aGlzLndhaXRVbnRpbCh0aGlzLmNhY2hlUHV0KGlucHV0LCByZXNwb25zZUNsb25lKSk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgY2FjaGVNYXRjaChrZXkpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRvUmVxdWVzdChrZXkpO1xuICAgICAgICBsZXQgY2FjaGVkUmVzcG9uc2U7XG4gICAgICAgIGNvbnN0IHsgY2FjaGVOYW1lLCBtYXRjaE9wdGlvbnMgfSA9IHRoaXMuX3N0cmF0ZWd5O1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRDYWNoZUtleShyZXF1ZXN0LCBcInJlYWRcIik7XG4gICAgICAgIGNvbnN0IG11bHRpTWF0Y2hPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ubWF0Y2hPcHRpb25zLFxuICAgICAgICAgICAgLi4ue1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjYWNoZWRSZXNwb25zZSA9IGF3YWl0IGNhY2hlcy5tYXRjaChlZmZlY3RpdmVSZXF1ZXN0LCBtdWx0aU1hdGNoT3B0aW9ucyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgRm91bmQgYSBjYWNoZWQgcmVzcG9uc2UgaW4gJyR7Y2FjaGVOYW1lfScuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgTm8gY2FjaGVkIHJlc3BvbnNlIGZvdW5kIGluICcke2NhY2hlTmFtZX0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiY2FjaGVkUmVzcG9uc2VXaWxsQmVVc2VkXCIpKXtcbiAgICAgICAgICAgIGNhY2hlZFJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZSxcbiAgICAgICAgICAgICAgICBtYXRjaE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogZWZmZWN0aXZlUmVxdWVzdCxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudFxuICAgICAgICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZWRSZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgY2FjaGVQdXQoa2V5LCByZXNwb25zZSkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdG9SZXF1ZXN0KGtleSk7XG4gICAgICAgIGF3YWl0IHRpbWVvdXQoMCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZVJlcXVlc3QgPSBhd2FpdCB0aGlzLmdldENhY2hlS2V5KHJlcXVlc3QsIFwid3JpdGVcIik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAmJiBlZmZlY3RpdmVSZXF1ZXN0Lm1ldGhvZCAhPT0gXCJHRVRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJhdHRlbXB0LXRvLWNhY2hlLW5vbi1nZXQtcmVxdWVzdFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHVybDogZ2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IGVmZmVjdGl2ZVJlcXVlc3QubWV0aG9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgQ2Fubm90IGNhY2hlIG5vbi1leGlzdGVudCByZXNwb25zZSBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiY2FjaGUtcHV0LXdpdGgtbm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogZ2V0RnJpZW5kbHlVUkwoZWZmZWN0aXZlUmVxdWVzdC51cmwpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZVRvQ2FjaGUgPSBhd2FpdCB0aGlzLl9lbnN1cmVSZXNwb25zZVNhZmVUb0NhY2hlKHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFJlc3BvbnNlICcke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0nIHdpbGwgbm90IGJlIGNhY2hlZC5gLCByZXNwb25zZVRvQ2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FjaGVOYW1lLCBtYXRjaE9wdGlvbnMgfSA9IHRoaXMuX3N0cmF0ZWd5O1xuICAgICAgICBjb25zdCBjYWNoZSA9IGF3YWl0IHNlbGYuY2FjaGVzLm9wZW4oY2FjaGVOYW1lKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgdmFyeSA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiVmFyeVwiKTtcbiAgICAgICAgICAgIGlmICh2YXJ5ICYmIG1hdGNoT3B0aW9ucz8uaWdub3JlVmFyeSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIHJlc3BvbnNlIGZvciAke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0gaGFzIGEgJ1Zhcnk6ICR7dmFyeX0nIGhlYWRlci4gQ29uc2lkZXIgc2V0dGluZyB0aGUge2lnbm9yZVZhcnk6IHRydWV9IG9wdGlvbiBvbiB5b3VyIHN0cmF0ZWd5IHRvIGVuc3VyZSBjYWNoZSBtYXRjaGluZyBhbmQgZGVsZXRpb24gd29ya3MgYXMgZXhwZWN0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzQ2FjaGVVcGRhdGVDYWxsYmFjayA9IHRoaXMuaGFzQ2FsbGJhY2soXCJjYWNoZURpZFVwZGF0ZVwiKTtcbiAgICAgICAgY29uc3Qgb2xkUmVzcG9uc2UgPSBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID8gYXdhaXQgY2FjaGVNYXRjaElnbm9yZVBhcmFtcyhjYWNoZSwgZWZmZWN0aXZlUmVxdWVzdC5jbG9uZSgpLCBbXG4gICAgICAgICAgICBcIl9fV0JfUkVWSVNJT05fX1wiXG4gICAgICAgIF0sIG1hdGNoT3B0aW9ucykgOiBudWxsO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYFVwZGF0aW5nIHRoZSAnJHtjYWNoZU5hbWV9JyBjYWNoZSB3aXRoIGEgbmV3IFJlc3BvbnNlIGZvciAke2dldEZyaWVuZGx5VVJMKGVmZmVjdGl2ZVJlcXVlc3QudXJsKX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGNhY2hlLnB1dChlZmZlY3RpdmVSZXF1ZXN0LCBoYXNDYWNoZVVwZGF0ZUNhbGxiYWNrID8gcmVzcG9uc2VUb0NhY2hlLmNsb25lKCkgOiByZXNwb25zZVRvQ2FjaGUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBleGVjdXRlUXVvdGFFcnJvckNhbGxiYWNrcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcImNhY2hlRGlkVXBkYXRlXCIpKXtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWUsXG4gICAgICAgICAgICAgICAgb2xkUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgbmV3UmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZS5jbG9uZSgpLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBnZXRDYWNoZUtleShyZXF1ZXN0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGAke3JlcXVlc3QudXJsfSB8ICR7bW9kZX1gO1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlS2V5c1trZXldKSB7XG4gICAgICAgICAgICBsZXQgZWZmZWN0aXZlUmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuaXRlcmF0ZUNhbGxiYWNrcyhcImNhY2hlS2V5V2lsbEJlVXNlZFwiKSl7XG4gICAgICAgICAgICAgICAgZWZmZWN0aXZlUmVxdWVzdCA9IHRvUmVxdWVzdChhd2FpdCBjYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IGVmZmVjdGl2ZVJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiB0aGlzLmV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHRoaXMucGFyYW1zXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2FjaGVLZXlzW2tleV0gPSBlZmZlY3RpdmVSZXF1ZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUtleXNba2V5XTtcbiAgICB9XG4gICAgaGFzQ2FsbGJhY2sobmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiB0aGlzLl9zdHJhdGVneS5wbHVnaW5zKXtcbiAgICAgICAgICAgIGlmIChuYW1lIGluIHBsdWdpbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgcnVuQ2FsbGJhY2tzKG5hbWUsIHBhcmFtKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKG5hbWUpKXtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKHBhcmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqaXRlcmF0ZUNhbGxiYWNrcyhuYW1lKSB7XG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHRoaXMuX3N0cmF0ZWd5LnBsdWdpbnMpe1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwbHVnaW5bbmFtZV0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fcGx1Z2luU3RhdGVNYXAuZ2V0KHBsdWdpbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxDYWxsYmFjayA9IChwYXJhbSk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGVmdWxQYXJhbSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBhcmFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbltuYW1lXShzdGF0ZWZ1bFBhcmFtKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHlpZWxkIHN0YXRlZnVsQ2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2FpdFVudGlsKHByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgYXN5bmMgZG9uZVdhaXRpbmcoKSB7XG4gICAgICAgIGxldCBwcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZShwcm9taXNlID0gdGhpcy5fZXh0ZW5kTGlmZXRpbWVQcm9taXNlcy5zaGlmdCgpKXtcbiAgICAgICAgICAgIGF3YWl0IHByb21pc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlckRlZmVycmVkLnJlc29sdmUobnVsbCk7XG4gICAgfVxuICAgIGFzeW5jIF9lbnN1cmVSZXNwb25zZVNhZmVUb0NhY2hlKHJlc3BvbnNlKSB7XG4gICAgICAgIGxldCByZXNwb25zZVRvQ2FjaGUgPSByZXNwb25zZTtcbiAgICAgICAgbGV0IHBsdWdpbnNVc2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5pdGVyYXRlQ2FsbGJhY2tzKFwiY2FjaGVXaWxsVXBkYXRlXCIpKXtcbiAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IGF3YWl0IGNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB0aGlzLnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlVG9DYWNoZSxcbiAgICAgICAgICAgICAgICBldmVudDogdGhpcy5ldmVudFxuICAgICAgICAgICAgfSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgcGx1Z2luc1VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZVRvQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsdWdpbnNVc2VkKSB7XG4gICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlICYmIHJlc3BvbnNlVG9DYWNoZS5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlVG9DYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUb0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvQ2FjaGUuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRvQ2FjaGUuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSByZXNwb25zZSBmb3IgJyR7dGhpcy5yZXF1ZXN0LnVybH0nIGlzIGFuIG9wYXF1ZSByZXNwb25zZS4gVGhlIGNhY2hpbmcgc3RyYXRlZ3kgdGhhdCB5b3UncmUgdXNpbmcgd2lsbCBub3QgY2FjaGUgb3BhcXVlIHJlc3BvbnNlcyBieSBkZWZhdWx0LmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZXNwb25zZSBmb3IgJyR7dGhpcy5yZXF1ZXN0LnVybH0nIHJldHVybmVkIGEgc3RhdHVzIGNvZGUgb2YgJyR7cmVzcG9uc2Uuc3RhdHVzfScgYW5kIHdvbid0IGJlIGNhY2hlZCBhcyBhIHJlc3VsdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VUb0NhY2hlO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyYXRlZ3kge1xuICAgIGNhY2hlTmFtZTtcbiAgICBwbHVnaW5zO1xuICAgIGZldGNoT3B0aW9ucztcbiAgICBtYXRjaE9wdGlvbnM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgdGhpcy5jYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFJ1bnRpbWVOYW1lKG9wdGlvbnMuY2FjaGVOYW1lKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gb3B0aW9ucy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IG9wdGlvbnMuZmV0Y2hPcHRpb25zO1xuICAgICAgICB0aGlzLm1hdGNoT3B0aW9ucyA9IG9wdGlvbnMubWF0Y2hPcHRpb25zO1xuICAgIH1cbiAgICBoYW5kbGUob3B0aW9ucykge1xuICAgICAgICBjb25zdCBbcmVzcG9uc2VEb25lXSA9IHRoaXMuaGFuZGxlQWxsKG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VEb25lO1xuICAgIH1cbiAgICBoYW5kbGVBbGwob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEZldGNoRXZlbnQpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogb3B0aW9ucy5yZXF1ZXN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gb3B0aW9ucy5ldmVudDtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHR5cGVvZiBvcHRpb25zLnJlcXVlc3QgPT09IFwic3RyaW5nXCIgPyBuZXcgUmVxdWVzdChvcHRpb25zLnJlcXVlc3QpIDogb3B0aW9ucy5yZXF1ZXN0O1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbmV3IFN0cmF0ZWd5SGFuZGxlcih0aGlzLCBvcHRpb25zLnVybCA/IHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgICAgICAgICBwYXJhbXM6IG9wdGlvbnMucGFyYW1zXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRG9uZSA9IHRoaXMuX2dldFJlc3BvbnNlKGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgaGFuZGxlckRvbmUgPSB0aGlzLl9hd2FpdENvbXBsZXRlKHJlc3BvbnNlRG9uZSwgaGFuZGxlciwgcmVxdWVzdCwgZXZlbnQpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcmVzcG9uc2VEb25lLFxuICAgICAgICAgICAgaGFuZGxlckRvbmVcbiAgICAgICAgXTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3BvbnNlKGhhbmRsZXIsIHJlcXVlc3QsIGV2ZW50KSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKFwiaGFuZGxlcldpbGxTdGFydFwiLCB7XG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCByZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5faGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSB1bmRlZmluZWQgfHwgcmVzcG9uc2UudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcIm5vLXJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIGhhbmRsZXIuaXRlcmF0ZUNhbGxiYWNrcyhcImhhbmRsZXJEaWRFcnJvclwiKSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBsb2dnZXIubG9nKGBXaGlsZSByZXNwb25kaW5nIHRvICcke2dldEZyaWVuZGx5VVJMKHJlcXVlc3QudXJsKX0nLCBhbiAke2Vycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci50b1N0cmluZygpIDogXCJcIn0gZXJyb3Igb2NjdXJyZWQuIFVzaW5nIGEgZmFsbGJhY2sgcmVzcG9uc2UgcHJvdmlkZWQgYnkgYSBoYW5kbGVyRGlkRXJyb3IgcGx1Z2luLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgaGFuZGxlci5pdGVyYXRlQ2FsbGJhY2tzKFwiaGFuZGxlcldpbGxSZXNwb25kXCIpKXtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2soe1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgYXN5bmMgX2F3YWl0Q29tcGxldGUocmVzcG9uc2VEb25lLCBoYW5kbGVyLCByZXF1ZXN0LCBldmVudCkge1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VEb25lO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKFwiaGFuZGxlckRpZFJlc3BvbmRcIiwge1xuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlci5kb25lV2FpdGluZygpO1xuICAgICAgICB9IGNhdGNoICh3YWl0VW50aWxFcnJvcikge1xuICAgICAgICAgICAgaWYgKHdhaXRVbnRpbEVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IHdhaXRVbnRpbEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGhhbmRsZXIucnVuQ2FsbGJhY2tzKFwiaGFuZGxlckRpZENvbXBsZXRlXCIsIHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBjYWNoZU9rQW5kT3BhcXVlUGx1Z2luID0ge1xuICAgIGNhY2hlV2lsbFVwZGF0ZTogYXN5bmMgKHsgcmVzcG9uc2UgfSk9PntcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbmNvbnN0IG1lc3NhZ2VzID0ge1xuICAgIHN0cmF0ZWd5U3RhcnQ6IChzdHJhdGVneU5hbWUsIHJlcXVlc3QpPT5gVXNpbmcgJHtzdHJhdGVneU5hbWV9IHRvIHJlc3BvbmQgdG8gJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSdgLFxuICAgIHByaW50RmluYWxSZXNwb25zZTogKHJlc3BvbnNlKT0+e1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgdGhlIGZpbmFsIHJlc3BvbnNlIGhlcmUuXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhyZXNwb25zZSB8fCBcIltObyByZXNwb25zZSByZXR1cm5lZF1cIik7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbmNsYXNzIE5ldHdvcmtGaXJzdCBleHRlbmRzIFN0cmF0ZWd5IHtcbiAgICBfbmV0d29ya1RpbWVvdXRTZWNvbmRzO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSl7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXRoaXMucGx1Z2lucy5zb21lKChwKT0+XCJjYWNoZVdpbGxVcGRhdGVcIiBpbiBwKSkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnVuc2hpZnQoY2FjaGVPa0FuZE9wYXF1ZVBsdWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzID0gb3B0aW9ucy5uZXR3b3JrVGltZW91dFNlY29uZHMgfHwgMDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUodGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzLCBcIm51bWJlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdC9zdHJhdGVnaWVzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwibmV0d29ya1RpbWVvdXRTZWNvbmRzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgbG9ncyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0L3N0cmF0ZWdpZXNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJoYW5kbGVcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwibWFrZVJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgbGV0IHRpbWVvdXRJZDtcbiAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcykge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgcHJvbWlzZSB9ID0gdGhpcy5fZ2V0VGltZW91dFByb21pc2Uoe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgbG9ncyxcbiAgICAgICAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IGlkO1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXR3b3JrUHJvbWlzZSA9IHRoaXMuX2dldE5ldHdvcmtQcm9taXNlKHtcbiAgICAgICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBsb2dzLFxuICAgICAgICAgICAgaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChuZXR3b3JrUHJvbWlzZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci53YWl0VW50aWwoKGFzeW5jICgpPT57XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlci53YWl0VW50aWwoUHJvbWlzZS5yYWNlKHByb21pc2VzKSkgfHwgYXdhaXQgbmV0d29ya1Byb21pc2U7XG4gICAgICAgIH0pKCkpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbG9nIG9mIGxvZ3Mpe1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobG9nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgX2dldFRpbWVvdXRQcm9taXNlKHsgcmVxdWVzdCwgbG9ncywgaGFuZGxlciB9KSB7XG4gICAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgICAgICBjb25zdCBvbk5ldHdvcmtUaW1lb3V0ID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgVGltaW5nIG91dCB0aGUgbmV0d29yayByZXNwb25zZSBhdCAke3RoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kc30gc2Vjb25kcy5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQob25OZXR3b3JrVGltZW91dCwgdGhpcy5fbmV0d29ya1RpbWVvdXRTZWNvbmRzICogMTAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJvbWlzZTogdGltZW91dFByb21pc2UsXG4gICAgICAgICAgICBpZDogdGltZW91dElkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIF9nZXROZXR3b3JrUHJvbWlzZSh7IHRpbWVvdXRJZCwgcmVxdWVzdCwgbG9ncywgaGFuZGxlciB9KSB7XG4gICAgICAgIGxldCBlcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoQW5kQ2FjaGVQdXQocmVxdWVzdCk7XG4gICAgICAgIH0gY2F0Y2ggKGZldGNoRXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChmZXRjaEVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGZldGNoRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgbG9ncy5wdXNoKFwiR290IHJlc3BvbnNlIGZyb20gbmV0d29yay5cIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ3MucHVzaChcIlVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLiBXaWxsIHJlc3BvbmQgXCIgKyBcIndpdGggYSBjYWNoZWQgcmVzcG9uc2UuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciB8fCAhcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5jYWNoZU1hdGNoKHJlcXVlc3QpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dzLnB1c2goYEZvdW5kIGEgY2FjaGVkIHJlc3BvbnNlIGluIHRoZSAnJHt0aGlzLmNhY2hlTmFtZX0nIGNhY2hlLmApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ3MucHVzaChgTm8gcmVzcG9uc2UgZm91bmQgaW4gdGhlICcke3RoaXMuY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNsYXNzIE5ldHdvcmtPbmx5IGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIF9uZXR3b3JrVGltZW91dFNlY29uZHM7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KXtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcyA9IG9wdGlvbnMubmV0d29ya1RpbWVvdXRTZWNvbmRzIHx8IDA7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGUocmVxdWVzdCwgaGFuZGxlcikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNJbnN0YW5jZShyZXF1ZXN0LCBSZXF1ZXN0LCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0L3N0cmF0ZWdpZXNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJfaGFuZGxlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmZldGNoKHJlcXVlc3QpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVvdXRQcm9taXNlID0gdGltZW91dCh0aGlzLl9uZXR3b3JrVGltZW91dFNlY29uZHMgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRpbWVvdXRQcm9taXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5yYWNlKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRpbWVkIG91dCB0aGUgbmV0d29yayByZXNwb25zZSBhZnRlciAke3RoaXMuX25ldHdvcmtUaW1lb3V0U2Vjb25kc30gc2Vjb25kcy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQobWVzc2FnZXMuc3RyYXRlZ3lTdGFydCh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHJlcXVlc3QpKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJHb3QgcmVzcG9uc2UgZnJvbSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIlVuYWJsZSB0byBnZXQgYSByZXNwb25zZSBmcm9tIHRoZSBuZXR3b3JrLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lc3NhZ2VzLnByaW50RmluYWxSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm8tcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IE5ldHdvcmtPbmx5IGFzIE4sIFN0cmF0ZWd5IGFzIFMsIE5ldHdvcmtGaXJzdCBhcyBhLCBTdHJhdGVneUhhbmRsZXIgYXMgYiwgY2FjaGVPa0FuZE9wYXF1ZVBsdWdpbiBhcyBjLCBtZXNzYWdlcyBhcyBtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/NetworkOnly.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/PrecacheFallbackPlugin.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/PrecacheFallbackPlugin.js ***!
  \*********************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   B: function() { return /* binding */ BackgroundSyncPlugin; },\n/* harmony export */   P: function() { return /* binding */ PrecacheFallbackPlugin; },\n/* harmony export */   Q: function() { return /* binding */ Queue; },\n/* harmony export */   R: function() { return /* binding */ Route; },\n/* harmony export */   S: function() { return /* binding */ StorableRequest; },\n/* harmony export */   a: function() { return /* binding */ QueueStore; },\n/* harmony export */   d: function() { return /* binding */ defaultMethod; },\n/* harmony export */   i: function() { return /* binding */ initialize; },\n/* harmony export */   n: function() { return /* binding */ normalizeHandler; }\n/* harmony export */ });\n/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timeout.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js\");\n/* harmony import */ var _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NetworkOnly.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/NetworkOnly.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! idb */ \"./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js\");\n\n\n\n\nconst defaultMethod = \"GET\";\nconst validMethods = [\n    \"DELETE\",\n    \"GET\",\n    \"HEAD\",\n    \"PATCH\",\n    \"POST\",\n    \"PUT\"\n];\n\nconst normalizeHandler = (handler)=>{\n    if (handler && typeof handler === \"object\") {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.hasMethod(handler, \"handle\", {\n                moduleName: \"serwist\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"handler\"\n            });\n        }\n        return handler;\n    }\n    if (true) {\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(handler, \"function\", {\n            moduleName: \"serwist\",\n            className: \"Route\",\n            funcName: \"constructor\",\n            paramName: \"handler\"\n        });\n    }\n    return {\n        handle: handler\n    };\n};\n\nclass Route {\n    handler;\n    match;\n    method;\n    catchHandler;\n    constructor(match, handler, method = defaultMethod){\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(match, \"function\", {\n                moduleName: \"serwist\",\n                className: \"Route\",\n                funcName: \"constructor\",\n                paramName: \"match\"\n            });\n            if (method) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isOneOf(method, validMethods, {\n                    paramName: \"method\"\n                });\n            }\n        }\n        this.handler = normalizeHandler(handler);\n        this.match = match;\n        this.method = method;\n    }\n    setCatchHandler(handler) {\n        this.catchHandler = normalizeHandler(handler);\n    }\n}\n\nconst DB_VERSION = 3;\nconst DB_NAME = \"serwist-background-sync\";\nconst REQUEST_OBJECT_STORE_NAME = \"requests\";\nconst QUEUE_NAME_INDEX = \"queueName\";\nclass QueueDb {\n    _db = null;\n    async addEntry(entry) {\n        const db = await this.getDb();\n        const tx = db.transaction(REQUEST_OBJECT_STORE_NAME, \"readwrite\", {\n            durability: \"relaxed\"\n        });\n        await tx.store.add(entry);\n        await tx.done;\n    }\n    async getFirstEntryId() {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.openCursor();\n        return cursor?.value.id;\n    }\n    async getAllEntriesByQueueName(queueName) {\n        const db = await this.getDb();\n        const results = await db.getAllFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n        return results ? results : new Array();\n    }\n    async getEntryCountByQueueName(queueName) {\n        const db = await this.getDb();\n        return db.countFromIndex(REQUEST_OBJECT_STORE_NAME, QUEUE_NAME_INDEX, IDBKeyRange.only(queueName));\n    }\n    async deleteEntry(id) {\n        const db = await this.getDb();\n        await db.delete(REQUEST_OBJECT_STORE_NAME, id);\n    }\n    async getFirstEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"next\");\n    }\n    async getLastEntryByQueueName(queueName) {\n        return await this.getEndEntryFromIndex(IDBKeyRange.only(queueName), \"prev\");\n    }\n    async getEndEntryFromIndex(query, direction) {\n        const db = await this.getDb();\n        const cursor = await db.transaction(REQUEST_OBJECT_STORE_NAME).store.index(QUEUE_NAME_INDEX).openCursor(query, direction);\n        return cursor?.value;\n    }\n    async getDb() {\n        if (!this._db) {\n            this._db = await (0,idb__WEBPACK_IMPORTED_MODULE_2__.openDB)(DB_NAME, DB_VERSION, {\n                upgrade: this._upgradeDb\n            });\n        }\n        return this._db;\n    }\n    _upgradeDb(db, oldVersion) {\n        if (oldVersion > 0 && oldVersion < DB_VERSION) {\n            if (db.objectStoreNames.contains(REQUEST_OBJECT_STORE_NAME)) {\n                db.deleteObjectStore(REQUEST_OBJECT_STORE_NAME);\n            }\n        }\n        const objStore = db.createObjectStore(REQUEST_OBJECT_STORE_NAME, {\n            autoIncrement: true,\n            keyPath: \"id\"\n        });\n        objStore.createIndex(QUEUE_NAME_INDEX, QUEUE_NAME_INDEX, {\n            unique: false\n        });\n    }\n}\n\nclass QueueStore {\n    _queueName;\n    _queueDb;\n    constructor(queueName){\n        this._queueName = queueName;\n        this._queueDb = new QueueDb();\n    }\n    async pushEntry(entry) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry.requestData, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"pushEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        delete entry.id;\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async unshiftEntry(entry) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry.requestData, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueueStore\",\n                funcName: \"unshiftEntry\",\n                paramName: \"entry.requestData\"\n            });\n        }\n        const firstId = await this._queueDb.getFirstEntryId();\n        if (firstId) {\n            entry.id = firstId - 1;\n        } else {\n            delete entry.id;\n        }\n        entry.queueName = this._queueName;\n        await this._queueDb.addEntry(entry);\n    }\n    async popEntry() {\n        return this._removeEntry(await this._queueDb.getLastEntryByQueueName(this._queueName));\n    }\n    async shiftEntry() {\n        return this._removeEntry(await this._queueDb.getFirstEntryByQueueName(this._queueName));\n    }\n    async getAll() {\n        return await this._queueDb.getAllEntriesByQueueName(this._queueName);\n    }\n    async size() {\n        return await this._queueDb.getEntryCountByQueueName(this._queueName);\n    }\n    async deleteEntry(id) {\n        await this._queueDb.deleteEntry(id);\n    }\n    async _removeEntry(entry) {\n        if (entry) {\n            await this.deleteEntry(entry.id);\n        }\n        return entry;\n    }\n}\n\nconst serializableProperties = [\n    \"method\",\n    \"referrer\",\n    \"referrerPolicy\",\n    \"mode\",\n    \"credentials\",\n    \"cache\",\n    \"redirect\",\n    \"integrity\",\n    \"keepalive\"\n];\nclass StorableRequest {\n    _requestData;\n    static async fromRequest(request) {\n        const requestData = {\n            url: request.url,\n            headers: {}\n        };\n        if (request.method !== \"GET\") {\n            requestData.body = await request.clone().arrayBuffer();\n        }\n        request.headers.forEach((value, key)=>{\n            requestData.headers[key] = value;\n        });\n        for (const prop of serializableProperties){\n            if (request[prop] !== undefined) {\n                requestData[prop] = request[prop];\n            }\n        }\n        return new StorableRequest(requestData);\n    }\n    constructor(requestData){\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(requestData, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(requestData.url, \"string\", {\n                moduleName: \"serwist/plugins\",\n                className: \"StorableRequest\",\n                funcName: \"constructor\",\n                paramName: \"requestData.url\"\n            });\n        }\n        if (requestData.mode === \"navigate\") {\n            requestData.mode = \"same-origin\";\n        }\n        this._requestData = requestData;\n    }\n    toObject() {\n        const requestData = Object.assign({}, this._requestData);\n        requestData.headers = Object.assign({}, this._requestData.headers);\n        if (requestData.body) {\n            requestData.body = requestData.body.slice(0);\n        }\n        return requestData;\n    }\n    toRequest() {\n        return new Request(this._requestData.url, this._requestData);\n    }\n    clone() {\n        return new StorableRequest(this.toObject());\n    }\n}\n\nconst TAG_PREFIX = \"serwist-background-sync\";\nconst MAX_RETENTION_TIME$1 = 60 * 24 * 7;\nconst queueNames = new Set();\nconst convertEntry = (queueStoreEntry)=>{\n    const queueEntry = {\n        request: new StorableRequest(queueStoreEntry.requestData).toRequest(),\n        timestamp: queueStoreEntry.timestamp\n    };\n    if (queueStoreEntry.metadata) {\n        queueEntry.metadata = queueStoreEntry.metadata;\n    }\n    return queueEntry;\n};\nclass Queue {\n    _name;\n    _onSync;\n    _maxRetentionTime;\n    _queueStore;\n    _forceSyncFallback;\n    _syncInProgress = false;\n    _requestsAddedDuringSync = false;\n    constructor(name, { forceSyncFallback, onSync, maxRetentionTime } = {}){\n        if (queueNames.has(name)) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"duplicate-queue-name\", {\n                name\n            });\n        }\n        queueNames.add(name);\n        this._name = name;\n        this._onSync = onSync || this.replayRequests;\n        this._maxRetentionTime = maxRetentionTime || MAX_RETENTION_TIME$1;\n        this._forceSyncFallback = Boolean(forceSyncFallback);\n        this._queueStore = new QueueStore(this._name);\n        this._addSyncListener();\n    }\n    get name() {\n        return this._name;\n    }\n    async pushRequest(entry) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(entry.request, Request, {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"pushRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"push\");\n    }\n    async unshiftRequest(entry) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(entry, \"object\", {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(entry.request, Request, {\n                moduleName: \"serwist/plugins\",\n                className: \"BackgroundSyncQueue\",\n                funcName: \"unshiftRequest\",\n                paramName: \"entry.request\"\n            });\n        }\n        await this._addRequest(entry, \"unshift\");\n    }\n    async popRequest() {\n        return this._removeRequest(\"pop\");\n    }\n    async shiftRequest() {\n        return this._removeRequest(\"shift\");\n    }\n    async getAll() {\n        const allEntries = await this._queueStore.getAll();\n        const now = Date.now();\n        const unexpiredEntries = [];\n        for (const entry of allEntries){\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                await this._queueStore.deleteEntry(entry.id);\n            } else {\n                unexpiredEntries.push(convertEntry(entry));\n            }\n        }\n        return unexpiredEntries;\n    }\n    async size() {\n        return await this._queueStore.size();\n    }\n    async _addRequest({ request, metadata, timestamp = Date.now() }, operation) {\n        const storableRequest = await StorableRequest.fromRequest(request.clone());\n        const entry = {\n            requestData: storableRequest.toObject(),\n            timestamp\n        };\n        if (metadata) {\n            entry.metadata = metadata;\n        }\n        switch(operation){\n            case \"push\":\n                await this._queueStore.pushEntry(entry);\n                break;\n            case \"unshift\":\n                await this._queueStore.unshiftEntry(entry);\n                break;\n        }\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}' has ` + `been added to background sync queue '${this._name}'.`);\n        }\n        if (this._syncInProgress) {\n            this._requestsAddedDuringSync = true;\n        } else {\n            await this.registerSync();\n        }\n    }\n    async _removeRequest(operation) {\n        const now = Date.now();\n        let entry;\n        switch(operation){\n            case \"pop\":\n                entry = await this._queueStore.popEntry();\n                break;\n            case \"shift\":\n                entry = await this._queueStore.shiftEntry();\n                break;\n        }\n        if (entry) {\n            const maxRetentionTimeInMs = this._maxRetentionTime * 60 * 1000;\n            if (now - entry.timestamp > maxRetentionTimeInMs) {\n                return this._removeRequest(operation);\n            }\n            return convertEntry(entry);\n        }\n        return undefined;\n    }\n    async replayRequests() {\n        let entry = undefined;\n        while(entry = await this.shiftRequest()){\n            try {\n                await fetch(entry.request.clone());\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(entry.request.url)}' ` + `has been replayed in queue '${this._name}'`);\n                }\n            } catch (error) {\n                await this.unshiftRequest(entry);\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(entry.request.url)}' ` + `failed to replay, putting it back in queue '${this._name}'`);\n                }\n                throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"queue-replay-failed\", {\n                    name: this._name\n                });\n            }\n        }\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`);\n        }\n    }\n    async registerSync() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            try {\n                await self.registration.sync.register(`${TAG_PREFIX}:${this._name}`);\n            } catch (err) {\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`Unable to register sync event for '${this._name}'.`, err);\n                }\n            }\n        }\n    }\n    _addSyncListener() {\n        if (\"sync\" in self.registration && !this._forceSyncFallback) {\n            self.addEventListener(\"sync\", (event)=>{\n                if (event.tag === `${TAG_PREFIX}:${this._name}`) {\n                    if (true) {\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Background sync for tag '${event.tag}' has been received`);\n                    }\n                    const syncComplete = async ()=>{\n                        this._syncInProgress = true;\n                        let syncError = undefined;\n                        try {\n                            await this._onSync({\n                                queue: this\n                            });\n                        } catch (error) {\n                            if (error instanceof Error) {\n                                syncError = error;\n                                throw syncError;\n                            }\n                        } finally{\n                            if (this._requestsAddedDuringSync && !(syncError && !event.lastChance)) {\n                                await this.registerSync();\n                            }\n                            this._syncInProgress = false;\n                            this._requestsAddedDuringSync = false;\n                        }\n                    };\n                    event.waitUntil(syncComplete());\n                }\n            });\n        } else {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Background sync replaying without background sync event\");\n            }\n            void this._onSync({\n                queue: this\n            });\n        }\n    }\n    static get _queueNames() {\n        return queueNames;\n    }\n}\n\nclass BackgroundSyncPlugin {\n    _queue;\n    constructor(name, options){\n        this._queue = new Queue(name, options);\n    }\n    async fetchDidFail({ request }) {\n        await this._queue.pushRequest({\n            request\n        });\n    }\n}\n\nconst QUEUE_NAME = \"serwist-google-analytics\";\nconst MAX_RETENTION_TIME = 60 * 48;\nconst GOOGLE_ANALYTICS_HOST = \"www.google-analytics.com\";\nconst GTM_HOST = \"www.googletagmanager.com\";\nconst ANALYTICS_JS_PATH = \"/analytics.js\";\nconst GTAG_JS_PATH = \"/gtag/js\";\nconst GTM_JS_PATH = \"/gtm.js\";\nconst COLLECT_PATHS_REGEX = /^\\/(\\w+\\/)?collect/;\n\nconst createOnSyncCallback = (config)=>{\n    return async ({ queue })=>{\n        let entry = undefined;\n        while(entry = await queue.shiftRequest()){\n            const { request, timestamp } = entry;\n            const url = new URL(request.url);\n            try {\n                const params = request.method === \"POST\" ? new URLSearchParams(await request.clone().text()) : url.searchParams;\n                const originalHitTime = timestamp - (Number(params.get(\"qt\")) || 0);\n                const queueTime = Date.now() - originalHitTime;\n                params.set(\"qt\", String(queueTime));\n                if (config.parameterOverrides) {\n                    for (const param of Object.keys(config.parameterOverrides)){\n                        const value = config.parameterOverrides[param];\n                        params.set(param, value);\n                    }\n                }\n                if (typeof config.hitFilter === \"function\") {\n                    config.hitFilter.call(null, params);\n                }\n                await fetch(new Request(url.origin + url.pathname, {\n                    body: params.toString(),\n                    method: \"POST\",\n                    mode: \"cors\",\n                    credentials: \"omit\",\n                    headers: {\n                        \"Content-Type\": \"text/plain\"\n                    }\n                }));\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url.href)}' has been replayed`);\n                }\n            } catch (err) {\n                await queue.unshiftRequest(entry);\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Request for '${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url.href)}' failed to replay, putting it back in the queue.`);\n                }\n                throw err;\n            }\n        }\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"All Google Analytics request successfully replayed; \" + \"the queue is now empty!\");\n        }\n    };\n};\nconst createCollectRoutes = (bgSyncPlugin)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && COLLECT_PATHS_REGEX.test(url.pathname);\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_1__.N({\n        plugins: [\n            bgSyncPlugin\n        ]\n    });\n    return [\n        new Route(match, handler, \"GET\"),\n        new Route(match, handler, \"POST\")\n    ];\n};\nconst createAnalyticsJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GOOGLE_ANALYTICS_HOST && url.pathname === ANALYTICS_JS_PATH;\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_1__.a({\n        cacheName\n    });\n    return new Route(match, handler, \"GET\");\n};\nconst createGtagJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_1__.a({\n        cacheName\n    });\n    return new Route(match, handler, \"GET\");\n};\nconst createGtmJsRoute = (cacheName)=>{\n    const match = ({ url })=>url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;\n    const handler = new _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_1__.a({\n        cacheName\n    });\n    return new Route(match, handler, \"GET\");\n};\nconst initialize = ({ serwist, cacheName, ...options })=>{\n    const resolvedCacheName = _timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getGoogleAnalyticsName(cacheName);\n    const bgSyncPlugin = new BackgroundSyncPlugin(QUEUE_NAME, {\n        maxRetentionTime: MAX_RETENTION_TIME,\n        onSync: createOnSyncCallback(options)\n    });\n    const routes = [\n        createGtmJsRoute(resolvedCacheName),\n        createAnalyticsJsRoute(resolvedCacheName),\n        createGtagJsRoute(resolvedCacheName),\n        ...createCollectRoutes(bgSyncPlugin)\n    ];\n    for (const route of routes){\n        serwist.registerRoute(route);\n    }\n};\n\nclass PrecacheFallbackPlugin {\n    _fallbackUrls;\n    _serwist;\n    constructor({ fallbackUrls, serwist }){\n        this._fallbackUrls = fallbackUrls;\n        this._serwist = serwist;\n    }\n    async handlerDidError(param) {\n        for (const fallback of this._fallbackUrls){\n            if (typeof fallback === \"string\") {\n                const fallbackResponse = await this._serwist.matchPrecache(fallback);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            } else if (fallback.matcher(param)) {\n                const fallbackResponse = await this._serwist.matchPrecache(fallback.url);\n                if (fallbackResponse !== undefined) {\n                    return fallbackResponse;\n                }\n            }\n        }\n        return undefined;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvUHJlY2FjaGVGYWxsYmFja1BsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDdEQ7QUFDMUM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDLFFBQVEsMENBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQiwwQ0FBa0I7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkNBQU07QUFDbkM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDBDQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksMENBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMENBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pELFlBQVksMENBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMENBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkwiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3Nlcndpc3RAOS4wLjAtcHJldmlldy4yNF90eXBlc2NyaXB0QDUuNC41L25vZGVfbW9kdWxlcy9zZXJ3aXN0L2Rpc3QvY2h1bmtzL1ByZWNhY2hlRmFsbGJhY2tQbHVnaW4uanM/N2E3OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmIGFzIGZpbmFsQXNzZXJ0RXhwb3J0cywgUyBhcyBTZXJ3aXN0RXJyb3IsIGwgYXMgbG9nZ2VyLCBnIGFzIGdldEZyaWVuZGx5VVJMLCBjIGFzIGNhY2hlTmFtZXMgfSBmcm9tICcuL3RpbWVvdXQuanMnO1xuaW1wb3J0IHsgTiBhcyBOZXR3b3JrT25seSwgYSBhcyBOZXR3b3JrRmlyc3QgfSBmcm9tICcuL05ldHdvcmtPbmx5LmpzJztcbmltcG9ydCB7IG9wZW5EQiB9IGZyb20gJ2lkYic7XG5cbmNvbnN0IGRlZmF1bHRNZXRob2QgPSBcIkdFVFwiO1xuY29uc3QgdmFsaWRNZXRob2RzID0gW1xuICAgIFwiREVMRVRFXCIsXG4gICAgXCJHRVRcIixcbiAgICBcIkhFQURcIixcbiAgICBcIlBBVENIXCIsXG4gICAgXCJQT1NUXCIsXG4gICAgXCJQVVRcIlxuXTtcblxuY29uc3Qgbm9ybWFsaXplSGFuZGxlciA9IChoYW5kbGVyKT0+e1xuICAgIGlmIChoYW5kbGVyICYmIHR5cGVvZiBoYW5kbGVyID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5oYXNNZXRob2QoaGFuZGxlciwgXCJoYW5kbGVcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJSb3V0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImhhbmRsZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShoYW5kbGVyLCBcImZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlJvdXRlXCIsXG4gICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiBcImhhbmRsZXJcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFuZGxlOiBoYW5kbGVyXG4gICAgfTtcbn07XG5cbmNsYXNzIFJvdXRlIHtcbiAgICBoYW5kbGVyO1xuICAgIG1hdGNoO1xuICAgIG1ldGhvZDtcbiAgICBjYXRjaEhhbmRsZXI7XG4gICAgY29uc3RydWN0b3IobWF0Y2gsIGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2Qpe1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKG1hdGNoLCBcImZ1bmN0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUm91dGVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJtYXRjaFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNPbmVPZihtZXRob2QsIHZhbGlkTWV0aG9kcywge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwibWV0aG9kXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIHRoaXMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cbiAgICBzZXRDYXRjaEhhbmRsZXIoaGFuZGxlcikge1xuICAgICAgICB0aGlzLmNhdGNoSGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxufVxuXG5jb25zdCBEQl9WRVJTSU9OID0gMztcbmNvbnN0IERCX05BTUUgPSBcInNlcndpc3QtYmFja2dyb3VuZC1zeW5jXCI7XG5jb25zdCBSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FID0gXCJyZXF1ZXN0c1wiO1xuY29uc3QgUVVFVUVfTkFNRV9JTkRFWCA9IFwicXVldWVOYW1lXCI7XG5jbGFzcyBRdWV1ZURiIHtcbiAgICBfZGIgPSBudWxsO1xuICAgIGFzeW5jIGFkZEVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICBjb25zdCB0eCA9IGRiLnRyYW5zYWN0aW9uKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUsIFwicmVhZHdyaXRlXCIsIHtcbiAgICAgICAgICAgIGR1cmFiaWxpdHk6IFwicmVsYXhlZFwiXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0eC5zdG9yZS5hZGQoZW50cnkpO1xuICAgICAgICBhd2FpdCB0eC5kb25lO1xuICAgIH1cbiAgICBhc3luYyBnZXRGaXJzdEVudHJ5SWQoKSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICBjb25zdCBjdXJzb3IgPSBhd2FpdCBkYi50cmFuc2FjdGlvbihSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FKS5zdG9yZS5vcGVuQ3Vyc29yKCk7XG4gICAgICAgIHJldHVybiBjdXJzb3I/LnZhbHVlLmlkO1xuICAgIH1cbiAgICBhc3luYyBnZXRBbGxFbnRyaWVzQnlRdWV1ZU5hbWUocXVldWVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgZGIuZ2V0QWxsRnJvbUluZGV4KFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUsIFFVRVVFX05BTUVfSU5ERVgsIElEQktleVJhbmdlLm9ubHkocXVldWVOYW1lKSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzID8gcmVzdWx0cyA6IG5ldyBBcnJheSgpO1xuICAgIH1cbiAgICBhc3luYyBnZXRFbnRyeUNvdW50QnlRdWV1ZU5hbWUocXVldWVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRiID0gYXdhaXQgdGhpcy5nZXREYigpO1xuICAgICAgICByZXR1cm4gZGIuY291bnRGcm9tSW5kZXgoUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSwgUVVFVUVfTkFNRV9JTkRFWCwgSURCS2V5UmFuZ2Uub25seShxdWV1ZU5hbWUpKTtcbiAgICB9XG4gICAgYXN5bmMgZGVsZXRlRW50cnkoaWQpIHtcbiAgICAgICAgY29uc3QgZGIgPSBhd2FpdCB0aGlzLmdldERiKCk7XG4gICAgICAgIGF3YWl0IGRiLmRlbGV0ZShSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FLCBpZCk7XG4gICAgfVxuICAgIGFzeW5jIGdldEZpcnN0RW50cnlCeVF1ZXVlTmFtZShxdWV1ZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0RW5kRW50cnlGcm9tSW5kZXgoSURCS2V5UmFuZ2Uub25seShxdWV1ZU5hbWUpLCBcIm5leHRcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldExhc3RFbnRyeUJ5UXVldWVOYW1lKHF1ZXVlTmFtZSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRFbmRFbnRyeUZyb21JbmRleChJREJLZXlSYW5nZS5vbmx5KHF1ZXVlTmFtZSksIFwicHJldlwiKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RW5kRW50cnlGcm9tSW5kZXgocXVlcnksIGRpcmVjdGlvbikge1xuICAgICAgICBjb25zdCBkYiA9IGF3YWl0IHRoaXMuZ2V0RGIoKTtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gYXdhaXQgZGIudHJhbnNhY3Rpb24oUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSkuc3RvcmUuaW5kZXgoUVVFVUVfTkFNRV9JTkRFWCkub3BlbkN1cnNvcihxdWVyeSwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvcj8udmFsdWU7XG4gICAgfVxuICAgIGFzeW5jIGdldERiKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RiKSB7XG4gICAgICAgICAgICB0aGlzLl9kYiA9IGF3YWl0IG9wZW5EQihEQl9OQU1FLCBEQl9WRVJTSU9OLCB7XG4gICAgICAgICAgICAgICAgdXBncmFkZTogdGhpcy5fdXBncmFkZURiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGI7XG4gICAgfVxuICAgIF91cGdyYWRlRGIoZGIsIG9sZFZlcnNpb24pIHtcbiAgICAgICAgaWYgKG9sZFZlcnNpb24gPiAwICYmIG9sZFZlcnNpb24gPCBEQl9WRVJTSU9OKSB7XG4gICAgICAgICAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcy5jb250YWlucyhSRVFVRVNUX09CSkVDVF9TVE9SRV9OQU1FKSkge1xuICAgICAgICAgICAgICAgIGRiLmRlbGV0ZU9iamVjdFN0b3JlKFJFUVVFU1RfT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9ialN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoUkVRVUVTVF9PQkpFQ1RfU1RPUkVfTkFNRSwge1xuICAgICAgICAgICAgYXV0b0luY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgIGtleVBhdGg6IFwiaWRcIlxuICAgICAgICB9KTtcbiAgICAgICAgb2JqU3RvcmUuY3JlYXRlSW5kZXgoUVVFVUVfTkFNRV9JTkRFWCwgUVVFVUVfTkFNRV9JTkRFWCwge1xuICAgICAgICAgICAgdW5pcXVlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFF1ZXVlU3RvcmUge1xuICAgIF9xdWV1ZU5hbWU7XG4gICAgX3F1ZXVlRGI7XG4gICAgY29uc3RydWN0b3IocXVldWVOYW1lKXtcbiAgICAgICAgdGhpcy5fcXVldWVOYW1lID0gcXVldWVOYW1lO1xuICAgICAgICB0aGlzLl9xdWV1ZURiID0gbmV3IFF1ZXVlRGIoKTtcbiAgICB9XG4gICAgYXN5bmMgcHVzaEVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoZW50cnksIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3QvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJwdXNoRW50cnlcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGVudHJ5LnJlcXVlc3REYXRhLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0L3BsdWdpbnNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVN0b3JlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwicHVzaEVudHJ5XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5LnJlcXVlc3REYXRhXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBlbnRyeS5pZDtcbiAgICAgICAgZW50cnkucXVldWVOYW1lID0gdGhpcy5fcXVldWVOYW1lO1xuICAgICAgICBhd2FpdCB0aGlzLl9xdWV1ZURiLmFkZEVudHJ5KGVudHJ5KTtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGlmdEVudHJ5KGVudHJ5KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc1R5cGUoZW50cnksIFwib2JqZWN0XCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3QvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlU3RvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ1bnNoaWZ0RW50cnlcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnlcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGVudHJ5LnJlcXVlc3REYXRhLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0L3BsdWdpbnNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVN0b3JlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwidW5zaGlmdEVudHJ5XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5LnJlcXVlc3REYXRhXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0SWQgPSBhd2FpdCB0aGlzLl9xdWV1ZURiLmdldEZpcnN0RW50cnlJZCgpO1xuICAgICAgICBpZiAoZmlyc3RJZCkge1xuICAgICAgICAgICAgZW50cnkuaWQgPSBmaXJzdElkIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBlbnRyeS5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5xdWV1ZU5hbWUgPSB0aGlzLl9xdWV1ZU5hbWU7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlRGIuYWRkRW50cnkoZW50cnkpO1xuICAgIH1cbiAgICBhc3luYyBwb3BFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUVudHJ5KGF3YWl0IHRoaXMuX3F1ZXVlRGIuZ2V0TGFzdEVudHJ5QnlRdWV1ZU5hbWUodGhpcy5fcXVldWVOYW1lKSk7XG4gICAgfVxuICAgIGFzeW5jIHNoaWZ0RW50cnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVFbnRyeShhd2FpdCB0aGlzLl9xdWV1ZURiLmdldEZpcnN0RW50cnlCeVF1ZXVlTmFtZSh0aGlzLl9xdWV1ZU5hbWUpKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWxsKCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcXVldWVEYi5nZXRBbGxFbnRyaWVzQnlRdWV1ZU5hbWUodGhpcy5fcXVldWVOYW1lKTtcbiAgICB9XG4gICAgYXN5bmMgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3F1ZXVlRGIuZ2V0RW50cnlDb3VudEJ5UXVldWVOYW1lKHRoaXMuX3F1ZXVlTmFtZSk7XG4gICAgfVxuICAgIGFzeW5jIGRlbGV0ZUVudHJ5KGlkKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlRGIuZGVsZXRlRW50cnkoaWQpO1xuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlRW50cnkoZW50cnkpIHtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmRlbGV0ZUVudHJ5KGVudHJ5LmlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfVxufVxuXG5jb25zdCBzZXJpYWxpemFibGVQcm9wZXJ0aWVzID0gW1xuICAgIFwibWV0aG9kXCIsXG4gICAgXCJyZWZlcnJlclwiLFxuICAgIFwicmVmZXJyZXJQb2xpY3lcIixcbiAgICBcIm1vZGVcIixcbiAgICBcImNyZWRlbnRpYWxzXCIsXG4gICAgXCJjYWNoZVwiLFxuICAgIFwicmVkaXJlY3RcIixcbiAgICBcImludGVncml0eVwiLFxuICAgIFwia2VlcGFsaXZlXCJcbl07XG5jbGFzcyBTdG9yYWJsZVJlcXVlc3Qge1xuICAgIF9yZXF1ZXN0RGF0YTtcbiAgICBzdGF0aWMgYXN5bmMgZnJvbVJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0RGF0YSA9IHtcbiAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxdWVzdC5tZXRob2QgIT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmJvZHkgPSBhd2FpdCByZXF1ZXN0LmNsb25lKCkuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSk9PntcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNlcmlhbGl6YWJsZVByb3BlcnRpZXMpe1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RbcHJvcF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhW3Byb3BdID0gcmVxdWVzdFtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFN0b3JhYmxlUmVxdWVzdChyZXF1ZXN0RGF0YSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3REYXRhKXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShyZXF1ZXN0RGF0YSwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdC9wbHVnaW5zXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlN0b3JhYmxlUmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJlcXVlc3REYXRhXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShyZXF1ZXN0RGF0YS51cmwsIFwic3RyaW5nXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3QvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTdG9yYWJsZVJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyZXF1ZXN0RGF0YS51cmxcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3REYXRhLm1vZGUgPT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgICAgcmVxdWVzdERhdGEubW9kZSA9IFwic2FtZS1vcmlnaW5cIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXF1ZXN0RGF0YSA9IHJlcXVlc3REYXRhO1xuICAgIH1cbiAgICB0b09iamVjdCgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdERhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXF1ZXN0RGF0YSk7XG4gICAgICAgIHJlcXVlc3REYXRhLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXF1ZXN0RGF0YS5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlcXVlc3REYXRhLmJvZHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3REYXRhLmJvZHkgPSByZXF1ZXN0RGF0YS5ib2R5LnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXF1ZXN0RGF0YTtcbiAgICB9XG4gICAgdG9SZXF1ZXN0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcy5fcmVxdWVzdERhdGEudXJsLCB0aGlzLl9yZXF1ZXN0RGF0YSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0b3JhYmxlUmVxdWVzdCh0aGlzLnRvT2JqZWN0KCkpO1xuICAgIH1cbn1cblxuY29uc3QgVEFHX1BSRUZJWCA9IFwic2Vyd2lzdC1iYWNrZ3JvdW5kLXN5bmNcIjtcbmNvbnN0IE1BWF9SRVRFTlRJT05fVElNRSQxID0gNjAgKiAyNCAqIDc7XG5jb25zdCBxdWV1ZU5hbWVzID0gbmV3IFNldCgpO1xuY29uc3QgY29udmVydEVudHJ5ID0gKHF1ZXVlU3RvcmVFbnRyeSk9PntcbiAgICBjb25zdCBxdWV1ZUVudHJ5ID0ge1xuICAgICAgICByZXF1ZXN0OiBuZXcgU3RvcmFibGVSZXF1ZXN0KHF1ZXVlU3RvcmVFbnRyeS5yZXF1ZXN0RGF0YSkudG9SZXF1ZXN0KCksXG4gICAgICAgIHRpbWVzdGFtcDogcXVldWVTdG9yZUVudHJ5LnRpbWVzdGFtcFxuICAgIH07XG4gICAgaWYgKHF1ZXVlU3RvcmVFbnRyeS5tZXRhZGF0YSkge1xuICAgICAgICBxdWV1ZUVudHJ5Lm1ldGFkYXRhID0gcXVldWVTdG9yZUVudHJ5Lm1ldGFkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gcXVldWVFbnRyeTtcbn07XG5jbGFzcyBRdWV1ZSB7XG4gICAgX25hbWU7XG4gICAgX29uU3luYztcbiAgICBfbWF4UmV0ZW50aW9uVGltZTtcbiAgICBfcXVldWVTdG9yZTtcbiAgICBfZm9yY2VTeW5jRmFsbGJhY2s7XG4gICAgX3N5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgX3JlcXVlc3RzQWRkZWREdXJpbmdTeW5jID0gZmFsc2U7XG4gICAgY29uc3RydWN0b3IobmFtZSwgeyBmb3JjZVN5bmNGYWxsYmFjaywgb25TeW5jLCBtYXhSZXRlbnRpb25UaW1lIH0gPSB7fSl7XG4gICAgICAgIGlmIChxdWV1ZU5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImR1cGxpY2F0ZS1xdWV1ZS1uYW1lXCIsIHtcbiAgICAgICAgICAgICAgICBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZU5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX29uU3luYyA9IG9uU3luYyB8fCB0aGlzLnJlcGxheVJlcXVlc3RzO1xuICAgICAgICB0aGlzLl9tYXhSZXRlbnRpb25UaW1lID0gbWF4UmV0ZW50aW9uVGltZSB8fCBNQVhfUkVURU5USU9OX1RJTUUkMTtcbiAgICAgICAgdGhpcy5fZm9yY2VTeW5jRmFsbGJhY2sgPSBCb29sZWFuKGZvcmNlU3luY0ZhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5fcXVldWVTdG9yZSA9IG5ldyBRdWV1ZVN0b3JlKHRoaXMuX25hbWUpO1xuICAgICAgICB0aGlzLl9hZGRTeW5jTGlzdGVuZXIoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBhc3luYyBwdXNoUmVxdWVzdChlbnRyeSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKGVudHJ5LCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0L3BsdWdpbnNcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiQmFja2dyb3VuZFN5bmNRdWV1ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcInB1c2hSZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcImVudHJ5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2UoZW50cnkucmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdC9wbHVnaW5zXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJwdXNoUmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeS5yZXF1ZXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMuX2FkZFJlcXVlc3QoZW50cnksIFwicHVzaFwiKTtcbiAgICB9XG4gICAgYXN5bmMgdW5zaGlmdFJlcXVlc3QoZW50cnkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShlbnRyeSwgXCJvYmplY3RcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdC9wbHVnaW5zXCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIkJhY2tncm91bmRTeW5jUXVldWVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJ1bnNoaWZ0UmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJlbnRyeVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZpbmFsQXNzZXJ0RXhwb3J0cy5pc0luc3RhbmNlKGVudHJ5LnJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3QvcGx1Z2luc1wiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJCYWNrZ3JvdW5kU3luY1F1ZXVlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwidW5zaGlmdFJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cnkucmVxdWVzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLl9hZGRSZXF1ZXN0KGVudHJ5LCBcInVuc2hpZnRcIik7XG4gICAgfVxuICAgIGFzeW5jIHBvcFJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVSZXF1ZXN0KFwicG9wXCIpO1xuICAgIH1cbiAgICBhc3luYyBzaGlmdFJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVSZXF1ZXN0KFwic2hpZnRcIik7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbCgpIHtcbiAgICAgICAgY29uc3QgYWxsRW50cmllcyA9IGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUuZ2V0QWxsKCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IHVuZXhwaXJlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBhbGxFbnRyaWVzKXtcbiAgICAgICAgICAgIGNvbnN0IG1heFJldGVudGlvblRpbWVJbk1zID0gdGhpcy5fbWF4UmV0ZW50aW9uVGltZSAqIDYwICogMTAwMDtcbiAgICAgICAgICAgIGlmIChub3cgLSBlbnRyeS50aW1lc3RhbXAgPiBtYXhSZXRlbnRpb25UaW1lSW5Ncykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUuZGVsZXRlRW50cnkoZW50cnkuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1bmV4cGlyZWRFbnRyaWVzLnB1c2goY29udmVydEVudHJ5KGVudHJ5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZXhwaXJlZEVudHJpZXM7XG4gICAgfVxuICAgIGFzeW5jIHNpemUoKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLnNpemUoKTtcbiAgICB9XG4gICAgYXN5bmMgX2FkZFJlcXVlc3QoeyByZXF1ZXN0LCBtZXRhZGF0YSwgdGltZXN0YW1wID0gRGF0ZS5ub3coKSB9LCBvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgc3RvcmFibGVSZXF1ZXN0ID0gYXdhaXQgU3RvcmFibGVSZXF1ZXN0LmZyb21SZXF1ZXN0KHJlcXVlc3QuY2xvbmUoKSk7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgcmVxdWVzdERhdGE6IHN0b3JhYmxlUmVxdWVzdC50b09iamVjdCgpLFxuICAgICAgICAgICAgdGltZXN0YW1wXG4gICAgICAgIH07XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgZW50cnkubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2gob3BlcmF0aW9uKXtcbiAgICAgICAgICAgIGNhc2UgXCJwdXNoXCI6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcXVldWVTdG9yZS5wdXNoRW50cnkoZW50cnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVuc2hpZnRcIjpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9xdWV1ZVN0b3JlLnVuc2hpZnRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfScgaGFzIGAgKyBgYmVlbiBhZGRlZCB0byBiYWNrZ3JvdW5kIHN5bmMgcXVldWUgJyR7dGhpcy5fbmFtZX0nLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zeW5jSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZWdpc3RlclN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfcmVtb3ZlUmVxdWVzdChvcGVyYXRpb24pIHtcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IGVudHJ5O1xuICAgICAgICBzd2l0Y2gob3BlcmF0aW9uKXtcbiAgICAgICAgICAgIGNhc2UgXCJwb3BcIjpcbiAgICAgICAgICAgICAgICBlbnRyeSA9IGF3YWl0IHRoaXMuX3F1ZXVlU3RvcmUucG9wRW50cnkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzaGlmdFwiOlxuICAgICAgICAgICAgICAgIGVudHJ5ID0gYXdhaXQgdGhpcy5fcXVldWVTdG9yZS5zaGlmdEVudHJ5KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBtYXhSZXRlbnRpb25UaW1lSW5NcyA9IHRoaXMuX21heFJldGVudGlvblRpbWUgKiA2MCAqIDEwMDA7XG4gICAgICAgICAgICBpZiAobm93IC0gZW50cnkudGltZXN0YW1wID4gbWF4UmV0ZW50aW9uVGltZUluTXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVtb3ZlUmVxdWVzdChvcGVyYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRFbnRyeShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGF5UmVxdWVzdHMoKSB7XG4gICAgICAgIGxldCBlbnRyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd2hpbGUoZW50cnkgPSBhd2FpdCB0aGlzLnNoaWZ0UmVxdWVzdCgpKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2goZW50cnkucmVxdWVzdC5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKGVudHJ5LnJlcXVlc3QudXJsKX0nIGAgKyBgaGFzIGJlZW4gcmVwbGF5ZWQgaW4gcXVldWUgJyR7dGhpcy5fbmFtZX0nYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVuc2hpZnRSZXF1ZXN0KGVudHJ5KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKGVudHJ5LnJlcXVlc3QudXJsKX0nIGAgKyBgZmFpbGVkIHRvIHJlcGxheSwgcHV0dGluZyBpdCBiYWNrIGluIHF1ZXVlICcke3RoaXMuX25hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwicXVldWUtcmVwbGF5LWZhaWxlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuX25hbWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBBbGwgcmVxdWVzdHMgaW4gcXVldWUgJyR7dGhpcy5uYW1lfScgaGF2ZSBzdWNjZXNzZnVsbHkgcmVwbGF5ZWQ7IHRoZSBxdWV1ZSBpcyBub3cgZW1wdHkhYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVnaXN0ZXJTeW5jKCkge1xuICAgICAgICBpZiAoXCJzeW5jXCIgaW4gc2VsZi5yZWdpc3RyYXRpb24gJiYgIXRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHNlbGYucmVnaXN0cmF0aW9uLnN5bmMucmVnaXN0ZXIoYCR7VEFHX1BSRUZJWH06JHt0aGlzLl9uYW1lfWApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgVW5hYmxlIHRvIHJlZ2lzdGVyIHN5bmMgZXZlbnQgZm9yICcke3RoaXMuX25hbWV9Jy5gLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfYWRkU3luY0xpc3RlbmVyKCkge1xuICAgICAgICBpZiAoXCJzeW5jXCIgaW4gc2VsZi5yZWdpc3RyYXRpb24gJiYgIXRoaXMuX2ZvcmNlU3luY0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJzeW5jXCIsIChldmVudCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudGFnID09PSBgJHtUQUdfUFJFRklYfToke3RoaXMuX25hbWV9YCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIubG9nKGBCYWNrZ3JvdW5kIHN5bmMgZm9yIHRhZyAnJHtldmVudC50YWd9JyBoYXMgYmVlbiByZWNlaXZlZGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNDb21wbGV0ZSA9IGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zeW5jSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3luY0Vycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9vblN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZTogdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW5jRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgc3luY0Vycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZmluYWxseXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgJiYgIShzeW5jRXJyb3IgJiYgIWV2ZW50Lmxhc3RDaGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVnaXN0ZXJTeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNBZGRlZER1cmluZ1N5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHN5bmNDb21wbGV0ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIubG9nKFwiQmFja2dyb3VuZCBzeW5jIHJlcGxheWluZyB3aXRob3V0IGJhY2tncm91bmQgc3luYyBldmVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZvaWQgdGhpcy5fb25TeW5jKHtcbiAgICAgICAgICAgICAgICBxdWV1ZTogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdldCBfcXVldWVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHF1ZXVlTmFtZXM7XG4gICAgfVxufVxuXG5jbGFzcyBCYWNrZ3JvdW5kU3luY1BsdWdpbiB7XG4gICAgX3F1ZXVlO1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG9wdGlvbnMpe1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBRdWV1ZShuYW1lLCBvcHRpb25zKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hEaWRGYWlsKHsgcmVxdWVzdCB9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuX3F1ZXVlLnB1c2hSZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBRVUVVRV9OQU1FID0gXCJzZXJ3aXN0LWdvb2dsZS1hbmFseXRpY3NcIjtcbmNvbnN0IE1BWF9SRVRFTlRJT05fVElNRSA9IDYwICogNDg7XG5jb25zdCBHT09HTEVfQU5BTFlUSUNTX0hPU1QgPSBcInd3dy5nb29nbGUtYW5hbHl0aWNzLmNvbVwiO1xuY29uc3QgR1RNX0hPU1QgPSBcInd3dy5nb29nbGV0YWdtYW5hZ2VyLmNvbVwiO1xuY29uc3QgQU5BTFlUSUNTX0pTX1BBVEggPSBcIi9hbmFseXRpY3MuanNcIjtcbmNvbnN0IEdUQUdfSlNfUEFUSCA9IFwiL2d0YWcvanNcIjtcbmNvbnN0IEdUTV9KU19QQVRIID0gXCIvZ3RtLmpzXCI7XG5jb25zdCBDT0xMRUNUX1BBVEhTX1JFR0VYID0gL15cXC8oXFx3K1xcLyk/Y29sbGVjdC87XG5cbmNvbnN0IGNyZWF0ZU9uU3luY0NhbGxiYWNrID0gKGNvbmZpZyk9PntcbiAgICByZXR1cm4gYXN5bmMgKHsgcXVldWUgfSk9PntcbiAgICAgICAgbGV0IGVudHJ5ID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZShlbnRyeSA9IGF3YWl0IHF1ZXVlLnNoaWZ0UmVxdWVzdCgpKXtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWVzdCwgdGltZXN0YW1wIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSByZXF1ZXN0Lm1ldGhvZCA9PT0gXCJQT1NUXCIgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKGF3YWl0IHJlcXVlc3QuY2xvbmUoKS50ZXh0KCkpIDogdXJsLnNlYXJjaFBhcmFtcztcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhpdFRpbWUgPSB0aW1lc3RhbXAgLSAoTnVtYmVyKHBhcmFtcy5nZXQoXCJxdFwiKSkgfHwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVldWVUaW1lID0gRGF0ZS5ub3coKSAtIG9yaWdpbmFsSGl0VGltZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KFwicXRcIiwgU3RyaW5nKHF1ZXVlVGltZSkpO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcucGFyYW1ldGVyT3ZlcnJpZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgT2JqZWN0LmtleXMoY29uZmlnLnBhcmFtZXRlck92ZXJyaWRlcykpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWcucGFyYW1ldGVyT3ZlcnJpZGVzW3BhcmFtXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5zZXQocGFyYW0sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5oaXRGaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuaGl0RmlsdGVyLmNhbGwobnVsbCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgZmV0Y2gobmV3IFJlcXVlc3QodXJsLm9yaWdpbiArIHVybC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgbW9kZTogXCJjb3JzXCIsXG4gICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcIm9taXRcIixcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYFJlcXVlc3QgZm9yICcke2dldEZyaWVuZGx5VVJMKHVybC5ocmVmKX0nIGhhcyBiZWVuIHJlcGxheWVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgcXVldWUudW5zaGlmdFJlcXVlc3QoZW50cnkpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgUmVxdWVzdCBmb3IgJyR7Z2V0RnJpZW5kbHlVUkwodXJsLmhyZWYpfScgZmFpbGVkIHRvIHJlcGxheSwgcHV0dGluZyBpdCBiYWNrIGluIHRoZSBxdWV1ZS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJBbGwgR29vZ2xlIEFuYWx5dGljcyByZXF1ZXN0IHN1Y2Nlc3NmdWxseSByZXBsYXllZDsgXCIgKyBcInRoZSBxdWV1ZSBpcyBub3cgZW1wdHkhXCIpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5jb25zdCBjcmVhdGVDb2xsZWN0Um91dGVzID0gKGJnU3luY1BsdWdpbik9PntcbiAgICBjb25zdCBtYXRjaCA9ICh7IHVybCB9KT0+dXJsLmhvc3RuYW1lID09PSBHT09HTEVfQU5BTFlUSUNTX0hPU1QgJiYgQ09MTEVDVF9QQVRIU19SRUdFWC50ZXN0KHVybC5wYXRobmFtZSk7XG4gICAgY29uc3QgaGFuZGxlciA9IG5ldyBOZXR3b3JrT25seSh7XG4gICAgICAgIHBsdWdpbnM6IFtcbiAgICAgICAgICAgIGJnU3luY1BsdWdpblxuICAgICAgICBdXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFJvdXRlKG1hdGNoLCBoYW5kbGVyLCBcIkdFVFwiKSxcbiAgICAgICAgbmV3IFJvdXRlKG1hdGNoLCBoYW5kbGVyLCBcIlBPU1RcIilcbiAgICBdO1xufTtcbmNvbnN0IGNyZWF0ZUFuYWx5dGljc0pzUm91dGUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIGNvbnN0IG1hdGNoID0gKHsgdXJsIH0pPT51cmwuaG9zdG5hbWUgPT09IEdPT0dMRV9BTkFMWVRJQ1NfSE9TVCAmJiB1cmwucGF0aG5hbWUgPT09IEFOQUxZVElDU19KU19QQVRIO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgY2FjaGVOYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaCwgaGFuZGxlciwgXCJHRVRcIik7XG59O1xuY29uc3QgY3JlYXRlR3RhZ0pzUm91dGUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIGNvbnN0IG1hdGNoID0gKHsgdXJsIH0pPT51cmwuaG9zdG5hbWUgPT09IEdUTV9IT1NUICYmIHVybC5wYXRobmFtZSA9PT0gR1RBR19KU19QQVRIO1xuICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgTmV0d29ya0ZpcnN0KHtcbiAgICAgICAgY2FjaGVOYW1lXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSb3V0ZShtYXRjaCwgaGFuZGxlciwgXCJHRVRcIik7XG59O1xuY29uc3QgY3JlYXRlR3RtSnNSb3V0ZSA9IChjYWNoZU5hbWUpPT57XG4gICAgY29uc3QgbWF0Y2ggPSAoeyB1cmwgfSk9PnVybC5ob3N0bmFtZSA9PT0gR1RNX0hPU1QgJiYgdXJsLnBhdGhuYW1lID09PSBHVE1fSlNfUEFUSDtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IE5ldHdvcmtGaXJzdCh7XG4gICAgICAgIGNhY2hlTmFtZVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUm91dGUobWF0Y2gsIGhhbmRsZXIsIFwiR0VUXCIpO1xufTtcbmNvbnN0IGluaXRpYWxpemUgPSAoeyBzZXJ3aXN0LCBjYWNoZU5hbWUsIC4uLm9wdGlvbnMgfSk9PntcbiAgICBjb25zdCByZXNvbHZlZENhY2hlTmFtZSA9IGNhY2hlTmFtZXMuZ2V0R29vZ2xlQW5hbHl0aWNzTmFtZShjYWNoZU5hbWUpO1xuICAgIGNvbnN0IGJnU3luY1BsdWdpbiA9IG5ldyBCYWNrZ3JvdW5kU3luY1BsdWdpbihRVUVVRV9OQU1FLCB7XG4gICAgICAgIG1heFJldGVudGlvblRpbWU6IE1BWF9SRVRFTlRJT05fVElNRSxcbiAgICAgICAgb25TeW5jOiBjcmVhdGVPblN5bmNDYWxsYmFjayhvcHRpb25zKVxuICAgIH0pO1xuICAgIGNvbnN0IHJvdXRlcyA9IFtcbiAgICAgICAgY3JlYXRlR3RtSnNSb3V0ZShyZXNvbHZlZENhY2hlTmFtZSksXG4gICAgICAgIGNyZWF0ZUFuYWx5dGljc0pzUm91dGUocmVzb2x2ZWRDYWNoZU5hbWUpLFxuICAgICAgICBjcmVhdGVHdGFnSnNSb3V0ZShyZXNvbHZlZENhY2hlTmFtZSksXG4gICAgICAgIC4uLmNyZWF0ZUNvbGxlY3RSb3V0ZXMoYmdTeW5jUGx1Z2luKVxuICAgIF07XG4gICAgZm9yIChjb25zdCByb3V0ZSBvZiByb3V0ZXMpe1xuICAgICAgICBzZXJ3aXN0LnJlZ2lzdGVyUm91dGUocm91dGUpO1xuICAgIH1cbn07XG5cbmNsYXNzIFByZWNhY2hlRmFsbGJhY2tQbHVnaW4ge1xuICAgIF9mYWxsYmFja1VybHM7XG4gICAgX3Nlcndpc3Q7XG4gICAgY29uc3RydWN0b3IoeyBmYWxsYmFja1VybHMsIHNlcndpc3QgfSl7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrVXJscyA9IGZhbGxiYWNrVXJscztcbiAgICAgICAgdGhpcy5fc2Vyd2lzdCA9IHNlcndpc3Q7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZXJEaWRFcnJvcihwYXJhbSkge1xuICAgICAgICBmb3IgKGNvbnN0IGZhbGxiYWNrIG9mIHRoaXMuX2ZhbGxiYWNrVXJscyl7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZhbGxiYWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Nlcndpc3QubWF0Y2hQcmVjYWNoZShmYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGZhbGxiYWNrUmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2tSZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZhbGxiYWNrLm1hdGNoZXIocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tSZXNwb25zZSA9IGF3YWl0IHRoaXMuX3Nlcndpc3QubWF0Y2hQcmVjYWNoZShmYWxsYmFjay51cmwpO1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1Jlc3BvbnNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kU3luY1BsdWdpbiBhcyBCLCBQcmVjYWNoZUZhbGxiYWNrUGx1Z2luIGFzIFAsIFF1ZXVlIGFzIFEsIFJvdXRlIGFzIFIsIFN0b3JhYmxlUmVxdWVzdCBhcyBTLCBRdWV1ZVN0b3JlIGFzIGEsIGRlZmF1bHRNZXRob2QgYXMgZCwgaW5pdGlhbGl6ZSBhcyBpLCBub3JtYWxpemVIYW5kbGVyIGFzIG4gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/PrecacheFallbackPlugin.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/Serwist.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/Serwist.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   N: function() { return /* binding */ NavigationRoute; },\n/* harmony export */   P: function() { return /* binding */ PrecacheRoute; },\n/* harmony export */   R: function() { return /* binding */ RegExpRoute; },\n/* harmony export */   S: function() { return /* binding */ Serwist; },\n/* harmony export */   a: function() { return /* binding */ clientsClaim; },\n/* harmony export */   b: function() { return /* binding */ copyResponse; },\n/* harmony export */   c: function() { return /* binding */ cleanupOutdatedCaches; },\n/* harmony export */   d: function() { return /* binding */ disableDevLogs; },\n/* harmony export */   e: function() { return /* binding */ disableNavigationPreload; },\n/* harmony export */   f: function() { return /* binding */ enableNavigationPreload; },\n/* harmony export */   g: function() { return /* binding */ PrecacheStrategy; },\n/* harmony export */   h: function() { return /* binding */ createCacheKey; },\n/* harmony export */   i: function() { return /* binding */ isNavigationPreloadSupported; },\n/* harmony export */   j: function() { return /* binding */ parallel; },\n/* harmony export */   k: function() { return /* binding */ printInstallDetails; },\n/* harmony export */   l: function() { return /* binding */ printCleanupDetails; },\n/* harmony export */   m: function() { return /* binding */ PrecacheInstallReportPlugin; },\n/* harmony export */   n: function() { return /* binding */ generateURLVariations; },\n/* harmony export */   p: function() { return /* binding */ parseRoute; },\n/* harmony export */   s: function() { return /* binding */ setCacheNameDetails; }\n/* harmony export */ });\n/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timeout.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js\");\n/* harmony import */ var _waitUntil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./waitUntil.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/waitUntil.js\");\n/* harmony import */ var _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PrecacheFallbackPlugin.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/PrecacheFallbackPlugin.js\");\n/* harmony import */ var _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NetworkOnly.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/NetworkOnly.js\");\n\n\n\n\n\nconst SUBSTRING_TO_FIND = \"-precache-\";\nconst deleteOutdatedCaches = async (currentPrecacheName, substringToFind = SUBSTRING_TO_FIND)=>{\n    const cacheNames = await self.caches.keys();\n    const cacheNamesToDelete = cacheNames.filter((cacheName)=>{\n        return cacheName.includes(substringToFind) && cacheName.includes(self.registration.scope) && cacheName !== currentPrecacheName;\n    });\n    await Promise.all(cacheNamesToDelete.map((cacheName)=>self.caches.delete(cacheName)));\n    return cacheNamesToDelete;\n};\n\nconst cleanupOutdatedCaches = (cacheName)=>{\n    self.addEventListener(\"activate\", (event)=>{\n        event.waitUntil(deleteOutdatedCaches(_timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrecacheName(cacheName)).then((cachesDeleted)=>{\n            if (true) {\n                if (cachesDeleted.length > 0) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"The following out-of-date precaches were cleaned up automatically:\", cachesDeleted);\n                }\n            }\n        }));\n    });\n};\n\nconst clientsClaim = ()=>{\n    self.addEventListener(\"activate\", ()=>self.clients.claim());\n};\n\nconst copyResponse = async (response, modifier)=>{\n    let origin = null;\n    if (response.url) {\n        const responseURL = new URL(response.url);\n        origin = responseURL.origin;\n    }\n    if (origin !== self.location.origin) {\n        throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"cross-origin-copy-response\", {\n            origin\n        });\n    }\n    const clonedResponse = response.clone();\n    const responseInit = {\n        headers: new Headers(clonedResponse.headers),\n        status: clonedResponse.status,\n        statusText: clonedResponse.statusText\n    };\n    const modifiedResponseInit = modifier ? modifier(responseInit) : responseInit;\n    const body = (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.c)() ? clonedResponse.body : await clonedResponse.blob();\n    return new Response(body, modifiedResponseInit);\n};\n\nconst disableDevLogs = ()=>{\n    self.__WB_DISABLE_DEV_LOGS = true;\n};\n\nconst isNavigationPreloadSupported = ()=>{\n    return Boolean(self.registration?.navigationPreload);\n};\nconst enableNavigationPreload = (headerValue)=>{\n    if (isNavigationPreloadSupported()) {\n        self.addEventListener(\"activate\", (event)=>{\n            event.waitUntil(self.registration.navigationPreload.enable().then(()=>{\n                if (headerValue) {\n                    void self.registration.navigationPreload.setHeaderValue(headerValue);\n                }\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is enabled.\");\n                }\n            }));\n        });\n    } else {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is not supported in this browser.\");\n        }\n    }\n};\nconst disableNavigationPreload = ()=>{\n    if (isNavigationPreloadSupported()) {\n        self.addEventListener(\"activate\", (event)=>{\n            event.waitUntil(self.registration.navigationPreload.disable().then(()=>{\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is disabled.\");\n                }\n            }));\n        });\n    } else {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Navigation preloading is not supported in this browser.\");\n        }\n    }\n};\n\nclass NavigationRoute extends _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.R {\n    _allowlist;\n    _denylist;\n    constructor(handler, { allowlist = [\n        /./\n    ], denylist = [] } = {}){\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isArrayOfClass(allowlist, RegExp, {\n                moduleName: \"serwist\",\n                className: \"NavigationRoute\",\n                funcName: \"constructor\",\n                paramName: \"options.allowlist\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isArrayOfClass(denylist, RegExp, {\n                moduleName: \"serwist\",\n                className: \"NavigationRoute\",\n                funcName: \"constructor\",\n                paramName: \"options.denylist\"\n            });\n        }\n        super((options)=>this._match(options), handler);\n        this._allowlist = allowlist;\n        this._denylist = denylist;\n    }\n    _match({ url, request }) {\n        if (request && request.mode !== \"navigate\") {\n            return false;\n        }\n        const pathnameAndSearch = url.pathname + url.search;\n        for (const regExp of this._denylist){\n            if (regExp.test(pathnameAndSearch)) {\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`The navigation route ${pathnameAndSearch} is not being used, since the URL matches this denylist pattern: ${regExp.toString()}`);\n                }\n                return false;\n            }\n        }\n        if (this._allowlist.some((regExp)=>regExp.test(pathnameAndSearch))) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The navigation route ${pathnameAndSearch} is being used.`);\n            }\n            return true;\n        }\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`The navigation route ${pathnameAndSearch} is not being used, since the URL being navigated to doesn't match the allowlist.`);\n        }\n        return false;\n    }\n}\n\nclass RegExpRoute extends _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.R {\n    constructor(regExp, handler, method){\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(regExp, RegExp, {\n                moduleName: \"serwist\",\n                className: \"RegExpRoute\",\n                funcName: \"constructor\",\n                paramName: \"pattern\"\n            });\n        }\n        const match = ({ url })=>{\n            const result = regExp.exec(url.href);\n            if (!result) {\n                return;\n            }\n            if (url.origin !== location.origin && result.index !== 0) {\n                if (true) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The regular expression '${regExp.toString()}' only partially matched against the cross-origin URL '${url.toString()}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`);\n                }\n                return;\n            }\n            return result.slice(1);\n        };\n        super(match, handler, method);\n    }\n}\n\nconst parseRoute = (capture, handler, method)=>{\n    let route;\n    if (typeof capture === \"string\") {\n        const captureUrl = new URL(capture, location.href);\n        if (true) {\n            if (!(capture.startsWith(\"/\") || capture.startsWith(\"http\"))) {\n                throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-string\", {\n                    moduleName: \"serwist\",\n                    funcName: \"parseRoute\",\n                    paramName: \"capture\"\n                });\n            }\n            const valueToCheck = capture.startsWith(\"http\") ? captureUrl.pathname : capture;\n            const wildcards = \"[*:?+]\";\n            if (new RegExp(`${wildcards}`).exec(valueToCheck)) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`The '$capture' parameter contains an Express-style wildcard character (${wildcards}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`);\n            }\n        }\n        const matchCallback = ({ url })=>{\n            if (true) {\n                if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`${capture} only partially matches the cross-origin URL ${url.toString()}. This route will only handle cross-origin requests if they match the entire URL.`);\n                }\n            }\n            return url.href === captureUrl.href;\n        };\n        route = new _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.R(matchCallback, handler, method);\n    } else if (capture instanceof RegExp) {\n        route = new RegExpRoute(capture, handler, method);\n    } else if (typeof capture === \"function\") {\n        route = new _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.R(capture, handler, method);\n    } else if (capture instanceof _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.R) {\n        route = capture;\n    } else {\n        throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"unsupported-route-type\", {\n            moduleName: \"serwist\",\n            funcName: \"parseRoute\",\n            paramName: \"capture\"\n        });\n    }\n    return route;\n};\n\nconst removeIgnoredSearchParams = (urlObject, ignoreURLParametersMatching = [])=>{\n    for (const paramName of [\n        ...urlObject.searchParams.keys()\n    ]){\n        if (ignoreURLParametersMatching.some((regExp)=>regExp.test(paramName))) {\n            urlObject.searchParams.delete(paramName);\n        }\n    }\n    return urlObject;\n};\n\nfunction* generateURLVariations(url, { directoryIndex = \"index.html\", ignoreURLParametersMatching = [\n    /^utm_/,\n    /^fbclid$/\n], cleanURLs = true, urlManipulation } = {}) {\n    const urlObject = new URL(url, location.href);\n    urlObject.hash = \"\";\n    yield urlObject.href;\n    const urlWithoutIgnoredParams = removeIgnoredSearchParams(urlObject, ignoreURLParametersMatching);\n    yield urlWithoutIgnoredParams.href;\n    if (directoryIndex && urlWithoutIgnoredParams.pathname.endsWith(\"/\")) {\n        const directoryURL = new URL(urlWithoutIgnoredParams.href);\n        directoryURL.pathname += directoryIndex;\n        yield directoryURL.href;\n    }\n    if (cleanURLs) {\n        const cleanURL = new URL(urlWithoutIgnoredParams.href);\n        cleanURL.pathname += \".html\";\n        yield cleanURL.href;\n    }\n    if (urlManipulation) {\n        const additionalURLs = urlManipulation({\n            url: urlObject\n        });\n        for (const urlToAttempt of additionalURLs){\n            yield urlToAttempt.href;\n        }\n    }\n}\n\nclass PrecacheRoute extends _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.R {\n    constructor(serwist, options){\n        const match = ({ request })=>{\n            const urlsToCacheKeys = serwist.getUrlsToPrecacheKeys();\n            for (const possibleURL of generateURLVariations(request.url, options)){\n                const cacheKey = urlsToCacheKeys.get(possibleURL);\n                if (cacheKey) {\n                    const integrity = serwist.getIntegrityForPrecacheKey(cacheKey);\n                    return {\n                        cacheKey,\n                        integrity\n                    };\n                }\n            }\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`Precaching did not find a match for ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}.`);\n            }\n            return;\n        };\n        super(match, serwist.precacheStrategy);\n    }\n}\n\nclass PrecacheStrategy extends _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_3__.S {\n    _fallbackToNetwork;\n    static defaultPrecacheCacheabilityPlugin = {\n        async cacheWillUpdate ({ response }) {\n            if (!response || response.status >= 400) {\n                return null;\n            }\n            return response;\n        }\n    };\n    static copyRedirectedCacheableResponsesPlugin = {\n        async cacheWillUpdate ({ response }) {\n            return response.redirected ? await copyResponse(response) : response;\n        }\n    };\n    constructor(options = {}){\n        options.cacheName = _timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrecacheName(options.cacheName);\n        super(options);\n        this._fallbackToNetwork = options.fallbackToNetwork === false ? false : true;\n        this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin);\n    }\n    async _handle(request, handler) {\n        const response = await handler.cacheMatch(request);\n        if (response) {\n            return response;\n        }\n        if (handler.event && handler.event.type === \"install\") {\n            return await this._handleInstall(request, handler);\n        }\n        return await this._handleFetch(request, handler);\n    }\n    async _handleFetch(request, handler) {\n        let response = undefined;\n        const params = handler.params || {};\n        if (this._fallbackToNetwork) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`The precached response for ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)} in ${this.cacheName} was not found. Falling back to the network.`);\n            }\n            const integrityInManifest = params.integrity;\n            const integrityInRequest = request.integrity;\n            const noIntegrityConflict = !integrityInRequest || integrityInRequest === integrityInManifest;\n            response = await handler.fetch(new Request(request, {\n                integrity: request.mode !== \"no-cors\" ? integrityInRequest || integrityInManifest : undefined\n            }));\n            if (integrityInManifest && noIntegrityConflict && request.mode !== \"no-cors\") {\n                this._useDefaultCacheabilityPluginIfNeeded();\n                const wasCached = await handler.cachePut(request, response.clone());\n                if (true) {\n                    if (wasCached) {\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`A response for ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)} was used to \"repair\" the precache.`);\n                    }\n                }\n            }\n        } else {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"missing-precache-entry\", {\n                cacheName: this.cacheName,\n                url: request.url\n            });\n        }\n        if (true) {\n            const cacheKey = params.cacheKey || await handler.getCacheKey(request, \"read\");\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`Precaching is responding to: ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(request.url)}`);\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(`Serving the precached url: ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(cacheKey instanceof Request ? cacheKey.url : cacheKey)}`);\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(\"View request details here.\");\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(request);\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(\"View response details here.\");\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(response);\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        return response;\n    }\n    async _handleInstall(request, handler) {\n        this._useDefaultCacheabilityPluginIfNeeded();\n        const response = await handler.fetch(request);\n        const wasCached = await handler.cachePut(request, response.clone());\n        if (!wasCached) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"bad-precaching-response\", {\n                url: request.url,\n                status: response.status\n            });\n        }\n        return response;\n    }\n    _useDefaultCacheabilityPluginIfNeeded() {\n        let defaultPluginIndex = null;\n        let cacheWillUpdatePluginCount = 0;\n        for (const [index, plugin] of this.plugins.entries()){\n            if (plugin === PrecacheStrategy.copyRedirectedCacheableResponsesPlugin) {\n                continue;\n            }\n            if (plugin === PrecacheStrategy.defaultPrecacheCacheabilityPlugin) {\n                defaultPluginIndex = index;\n            }\n            if (plugin.cacheWillUpdate) {\n                cacheWillUpdatePluginCount++;\n            }\n        }\n        if (cacheWillUpdatePluginCount === 0) {\n            this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin);\n        } else if (cacheWillUpdatePluginCount > 1 && defaultPluginIndex !== null) {\n            this.plugins.splice(defaultPluginIndex, 1);\n        }\n    }\n}\n\nconst setCacheNameDetails = (details)=>{\n    if (true) {\n        for (const key of Object.keys(details)){\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(details[key], \"string\", {\n                moduleName: \"@serwist/core\",\n                funcName: \"setCacheNameDetails\",\n                paramName: `details.${key}`\n            });\n        }\n        if (details.precache?.length === 0) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"precache\",\n                value: details.precache\n            });\n        }\n        if (details.runtime?.length === 0) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"runtime\",\n                value: details.runtime\n            });\n        }\n        if (details.googleAnalytics?.length === 0) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"invalid-cache-name\", {\n                cacheNameId: \"googleAnalytics\",\n                value: details.googleAnalytics\n            });\n        }\n    }\n    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.updateDetails(details);\n};\n\nconst parallel = async (limit, array, func)=>{\n    const work = array.map((item, index)=>({\n            index,\n            item\n        }));\n    const processor = async (res)=>{\n        const results = [];\n        while(true){\n            const next = work.pop();\n            if (!next) {\n                return res(results);\n            }\n            const result = await func(next.item);\n            results.push({\n                result: result,\n                index: next.index\n            });\n        }\n    };\n    const queues = Array.from({\n        length: limit\n    }, ()=>new Promise(processor));\n    const results = (await Promise.all(queues)).flat().sort((a, b)=>a.index < b.index ? -1 : 1).map((res)=>res.result);\n    return results;\n};\n\nclass PrecacheCacheKeyPlugin {\n    _precacheController;\n    constructor({ precacheController }){\n        this._precacheController = precacheController;\n    }\n    cacheKeyWillBeUsed = async ({ request, params })=>{\n        const cacheKey = params?.cacheKey || this._precacheController.getPrecacheKeyForUrl(request.url);\n        return cacheKey ? new Request(cacheKey, {\n            headers: request.headers\n        }) : request;\n    };\n}\n\nclass PrecacheInstallReportPlugin {\n    updatedURLs = [];\n    notUpdatedURLs = [];\n    handlerWillStart = async ({ request, state })=>{\n        if (state) {\n            state.originalRequest = request;\n        }\n    };\n    cachedResponseWillBeUsed = async ({ event, state, cachedResponse })=>{\n        if (event.type === \"install\") {\n            if (state?.originalRequest && state.originalRequest instanceof Request) {\n                const url = state.originalRequest.url;\n                if (cachedResponse) {\n                    this.notUpdatedURLs.push(url);\n                } else {\n                    this.updatedURLs.push(url);\n                }\n            }\n        }\n        return cachedResponse;\n    };\n}\n\nconst REVISION_SEARCH_PARAM = \"__WB_REVISION__\";\nconst createCacheKey = (entry)=>{\n    if (!entry) {\n        throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (typeof entry === \"string\") {\n        const urlObject = new URL(entry, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const { revision, url } = entry;\n    if (!url) {\n        throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"add-to-cache-list-unexpected-type\", {\n            entry\n        });\n    }\n    if (!revision) {\n        const urlObject = new URL(url, location.href);\n        return {\n            cacheKey: urlObject.href,\n            url: urlObject.href\n        };\n    }\n    const cacheKeyURL = new URL(url, location.href);\n    const originalURL = new URL(url, location.href);\n    cacheKeyURL.searchParams.set(REVISION_SEARCH_PARAM, revision);\n    return {\n        cacheKey: cacheKeyURL.href,\n        url: originalURL.href\n    };\n};\n\nconst logGroup = (groupTitle, deletedURLs)=>{\n    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(groupTitle);\n    for (const url of deletedURLs){\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(url);\n    }\n    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n};\nconst printCleanupDetails = (deletedURLs)=>{\n    const deletionCount = deletedURLs.length;\n    if (deletionCount > 0) {\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`During precaching cleanup, ${deletionCount} cached request${deletionCount === 1 ? \" was\" : \"s were\"} deleted.`);\n        logGroup(\"Deleted Cache Requests\", deletedURLs);\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n    }\n};\n\nfunction _nestedGroup(groupTitle, urls) {\n    if (urls.length === 0) {\n        return;\n    }\n    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(groupTitle);\n    for (const url of urls){\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(url);\n    }\n    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n}\nconst printInstallDetails = (urlsToPrecache, urlsAlreadyPrecached)=>{\n    const precachedCount = urlsToPrecache.length;\n    const alreadyPrecachedCount = urlsAlreadyPrecached.length;\n    if (precachedCount || alreadyPrecachedCount) {\n        let message = `Precaching ${precachedCount} file${precachedCount === 1 ? \"\" : \"s\"}.`;\n        if (alreadyPrecachedCount > 0) {\n            message += ` ${alreadyPrecachedCount} ` + `file${alreadyPrecachedCount === 1 ? \" is\" : \"s are\"} already cached.`;\n        }\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(message);\n        _nestedGroup(\"View newly precached URLs.\", urlsToPrecache);\n        _nestedGroup(\"View previously precached URLs.\", urlsAlreadyPrecached);\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n    }\n};\n\nclass Serwist {\n    _urlsToCacheKeys = new Map();\n    _urlsToCacheModes = new Map();\n    _cacheKeysToIntegrities = new Map();\n    _concurrentPrecaching;\n    _precacheStrategy;\n    _routes;\n    _defaultHandlerMap;\n    _catchHandler;\n    constructor({ precacheEntries, precacheOptions, cleanupOutdatedCaches: cleanupOutdatedCaches$1, navigateFallback, navigateFallbackAllowlist, navigateFallbackDenylist, plugins = [], fallbackToNetwork = true, concurrentPrecaching = 1, skipWaiting = false, importScripts, navigationPreload = false, cacheId, clientsClaim: clientsClaim$1 = false, runtimeCaching, offlineAnalyticsConfig, disableDevLogs: disableDevLogs$1 = false, fallbacks } = {}){\n        this._concurrentPrecaching = concurrentPrecaching;\n        this._precacheStrategy = new PrecacheStrategy({\n            cacheName: _timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrecacheName(precacheOptions?.cacheName),\n            plugins: [\n                ...plugins,\n                new PrecacheCacheKeyPlugin({\n                    precacheController: this\n                })\n            ],\n            fallbackToNetwork\n        });\n        this._routes = new Map();\n        this._defaultHandlerMap = new Map();\n        this.handleInstall = this.handleInstall.bind(this);\n        this.handleActivate = this.handleActivate.bind(this);\n        this.handleFetch = this.handleFetch.bind(this);\n        this.handleCache = this.handleCache.bind(this);\n        if (!!importScripts && importScripts.length > 0) self.importScripts(...importScripts);\n        if (navigationPreload) enableNavigationPreload();\n        if (cacheId !== undefined) {\n            setCacheNameDetails({\n                prefix: cacheId\n            });\n        }\n        if (skipWaiting) {\n            self.skipWaiting();\n        } else {\n            self.addEventListener(\"message\", (event)=>{\n                if (event.data && event.data.type === \"SKIP_WAITING\") {\n                    self.skipWaiting();\n                }\n            });\n        }\n        if (clientsClaim$1) clientsClaim();\n        this.registerRoute(new PrecacheRoute(this, precacheOptions));\n        if (!!precacheEntries && precacheEntries.length > 0) {\n            this.addToPrecacheList(precacheEntries);\n        }\n        if (cleanupOutdatedCaches$1) {\n            cleanupOutdatedCaches(precacheOptions?.cacheName);\n        }\n        if (navigateFallback) {\n            this.registerRoute(new NavigationRoute(this.createHandlerBoundToUrl(navigateFallback), {\n                allowlist: navigateFallbackAllowlist,\n                denylist: navigateFallbackDenylist\n            }));\n        }\n        if (offlineAnalyticsConfig !== undefined) {\n            if (typeof offlineAnalyticsConfig === \"boolean\") {\n                offlineAnalyticsConfig && (0,_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n                    serwist: this\n                });\n            } else {\n                (0,_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.i)({\n                    ...offlineAnalyticsConfig,\n                    serwist: this\n                });\n            }\n        }\n        if (runtimeCaching !== undefined) {\n            if (fallbacks !== undefined) {\n                const fallbackPlugin = new _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.P({\n                    fallbackUrls: fallbacks.entries,\n                    serwist: this\n                });\n                runtimeCaching.forEach((cacheEntry)=>{\n                    if (cacheEntry.handler instanceof _NetworkOnly_js__WEBPACK_IMPORTED_MODULE_3__.S && !cacheEntry.handler.plugins.some((plugin)=>\"handlerDidError\" in plugin)) {\n                        cacheEntry.handler.plugins.push(fallbackPlugin);\n                    }\n                });\n            }\n            for (const entry of runtimeCaching){\n                this.registerCapture(entry.matcher, entry.handler, entry.method);\n            }\n        }\n        if (disableDevLogs$1) disableDevLogs();\n    }\n    get precacheStrategy() {\n        return this._precacheStrategy;\n    }\n    get routes() {\n        return this._routes;\n    }\n    addEventListeners() {\n        self.addEventListener(\"install\", this.handleInstall);\n        self.addEventListener(\"activate\", this.handleActivate);\n        self.addEventListener(\"fetch\", this.handleFetch);\n        self.addEventListener(\"message\", this.handleCache);\n    }\n    addToPrecacheList(entries) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isArray(entries, {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"addToCacheList\",\n                paramName: \"entries\"\n            });\n        }\n        const urlsToWarnAbout = [];\n        for (const entry of entries){\n            if (typeof entry === \"string\") {\n                urlsToWarnAbout.push(entry);\n            } else if (entry && !entry.integrity && entry.revision === undefined) {\n                urlsToWarnAbout.push(entry.url);\n            }\n            const { cacheKey, url } = createCacheKey(entry);\n            const cacheMode = typeof entry !== \"string\" && entry.revision ? \"reload\" : \"default\";\n            if (this._urlsToCacheKeys.has(url) && this._urlsToCacheKeys.get(url) !== cacheKey) {\n                throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"add-to-cache-list-conflicting-entries\", {\n                    firstEntry: this._urlsToCacheKeys.get(url),\n                    secondEntry: cacheKey\n                });\n            }\n            if (typeof entry !== \"string\" && entry.integrity) {\n                if (this._cacheKeysToIntegrities.has(cacheKey) && this._cacheKeysToIntegrities.get(cacheKey) !== entry.integrity) {\n                    throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"add-to-cache-list-conflicting-integrities\", {\n                        url\n                    });\n                }\n                this._cacheKeysToIntegrities.set(cacheKey, entry.integrity);\n            }\n            this._urlsToCacheKeys.set(url, cacheKey);\n            this._urlsToCacheModes.set(url, cacheMode);\n            if (urlsToWarnAbout.length > 0) {\n                const warningMessage = `Serwist is precaching URLs without revision info: ${urlsToWarnAbout.join(\", \")}\\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;\n                if (false) {} else {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(warningMessage);\n                }\n            }\n        }\n    }\n    handleInstall(event) {\n        return (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.w)(event, async ()=>{\n            const installReportPlugin = new PrecacheInstallReportPlugin();\n            this.precacheStrategy.plugins.push(installReportPlugin);\n            await parallel(this._concurrentPrecaching, Array.from(this._urlsToCacheKeys.entries()), async ([url, cacheKey])=>{\n                const integrity = this._cacheKeysToIntegrities.get(cacheKey);\n                const cacheMode = this._urlsToCacheModes.get(url);\n                const request = new Request(url, {\n                    integrity,\n                    cache: cacheMode,\n                    credentials: \"same-origin\"\n                });\n                await Promise.all(this.precacheStrategy.handleAll({\n                    event,\n                    request,\n                    url: new URL(request.url),\n                    params: {\n                        cacheKey\n                    }\n                }));\n            });\n            const { updatedURLs, notUpdatedURLs } = installReportPlugin;\n            if (true) {\n                printInstallDetails(updatedURLs, notUpdatedURLs);\n            }\n            return {\n                updatedURLs,\n                notUpdatedURLs\n            };\n        });\n    }\n    handleActivate(event) {\n        return (0,_waitUntil_js__WEBPACK_IMPORTED_MODULE_1__.w)(event, async ()=>{\n            const cache = await self.caches.open(this.precacheStrategy.cacheName);\n            const currentlyCachedRequests = await cache.keys();\n            const expectedCacheKeys = new Set(this._urlsToCacheKeys.values());\n            const deletedCacheRequests = [];\n            for (const request of currentlyCachedRequests){\n                if (!expectedCacheKeys.has(request.url)) {\n                    await cache.delete(request);\n                    deletedCacheRequests.push(request.url);\n                }\n            }\n            if (true) {\n                printCleanupDetails(deletedCacheRequests);\n            }\n            return {\n                deletedCacheRequests\n            };\n        });\n    }\n    handleFetch(event) {\n        const { request } = event;\n        const responsePromise = this.handleRequest({\n            request,\n            event\n        });\n        if (responsePromise) {\n            event.respondWith(responsePromise);\n        }\n    }\n    handleCache(event) {\n        if (event.data && event.data.type === \"CACHE_URLS\") {\n            const { payload } = event.data;\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(\"Caching URLs from the window\", payload.urlsToCache);\n            }\n            const requestPromises = Promise.all(payload.urlsToCache.map((entry)=>{\n                let request;\n                if (typeof entry === \"string\") {\n                    request = new Request(entry);\n                } else {\n                    request = new Request(...entry);\n                }\n                return this.handleRequest({\n                    request,\n                    event\n                });\n            }));\n            event.waitUntil(requestPromises);\n            if (event.ports?.[0]) {\n                void requestPromises.then(()=>event.ports[0].postMessage(true));\n            }\n        }\n    }\n    setDefaultHandler(handler, method = _PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.d) {\n        this._defaultHandlerMap.set(method, (0,_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.n)(handler));\n    }\n    setCatchHandler(handler) {\n        this._catchHandler = (0,_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_2__.n)(handler);\n    }\n    registerCapture(capture, handler, method) {\n        const route = parseRoute(capture, handler, method);\n        this.registerRoute(route);\n        return route;\n    }\n    registerRoute(route) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(route, \"object\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.hasMethod(route, \"match\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(route.handler, \"object\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.hasMethod(route.handler, \"handle\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route.handler\"\n            });\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(route.method, \"string\", {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"registerRoute\",\n                paramName: \"route.method\"\n            });\n        }\n        if (!this._routes.has(route.method)) {\n            this._routes.set(route.method, []);\n        }\n        this._routes.get(route.method).push(route);\n    }\n    unregisterRoute(route) {\n        if (!this._routes.has(route.method)) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"unregister-route-but-not-found-with-method\", {\n                method: route.method\n            });\n        }\n        const routeIndex = this._routes.get(route.method).indexOf(route);\n        if (routeIndex > -1) {\n            this._routes.get(route.method).splice(routeIndex, 1);\n        } else {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"unregister-route-route-not-registered\");\n        }\n    }\n    getUrlsToPrecacheKeys() {\n        return this._urlsToCacheKeys;\n    }\n    getPrecachedUrls() {\n        return [\n            ...this._urlsToCacheKeys.keys()\n        ];\n    }\n    getPrecacheKeyForUrl(url) {\n        const urlObject = new URL(url, location.href);\n        return this._urlsToCacheKeys.get(urlObject.href);\n    }\n    getIntegrityForPrecacheKey(cacheKey) {\n        return this._cacheKeysToIntegrities.get(cacheKey);\n    }\n    async matchPrecache(request) {\n        const url = request instanceof Request ? request.url : request;\n        const cacheKey = this.getPrecacheKeyForUrl(url);\n        if (cacheKey) {\n            const cache = await self.caches.open(this.precacheStrategy.cacheName);\n            return cache.match(cacheKey);\n        }\n        return undefined;\n    }\n    createHandlerBoundToUrl(url) {\n        const cacheKey = this.getPrecacheKeyForUrl(url);\n        if (!cacheKey) {\n            throw new _timeout_js__WEBPACK_IMPORTED_MODULE_0__.S(\"non-precached-url\", {\n                url\n            });\n        }\n        return (options)=>{\n            options.request = new Request(url);\n            options.params = {\n                cacheKey,\n                ...options.params\n            };\n            return this.precacheStrategy.handle(options);\n        };\n    }\n    handleRequest({ request, event }) {\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isInstance(request, Request, {\n                moduleName: \"serwist\",\n                className: \"Serwist\",\n                funcName: \"handleRequest\",\n                paramName: \"options.request\"\n            });\n        }\n        const url = new URL(request.url, location.href);\n        if (!url.protocol.startsWith(\"http\")) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(\"Router only supports URLs that start with 'http'.\");\n            }\n            return;\n        }\n        const sameOrigin = url.origin === location.origin;\n        const { params, route } = this.findMatchingRoute({\n            event,\n            request,\n            sameOrigin,\n            url\n        });\n        let handler = route?.handler;\n        const debugMessages = [];\n        if (true) {\n            if (handler) {\n                debugMessages.push([\n                    \"Found a route to handle this request:\",\n                    route\n                ]);\n                if (params) {\n                    debugMessages.push([\n                        `Passing the following params to the route's handler:`,\n                        params\n                    ]);\n                }\n            }\n        }\n        const method = request.method;\n        if (!handler && this._defaultHandlerMap.has(method)) {\n            if (true) {\n                debugMessages.push(`Failed to find a matching route. Falling back to the default handler for ${method}.`);\n            }\n            handler = this._defaultHandlerMap.get(method);\n        }\n        if (!handler) {\n            if (true) {\n                _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.debug(`No route found for: ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url)}`);\n            }\n            return;\n        }\n        if (true) {\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`Router is responding to: ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url)}`);\n            for (const msg of debugMessages){\n                if (Array.isArray(msg)) {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(...msg);\n                } else {\n                    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(msg);\n                }\n            }\n            _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n        }\n        let responsePromise;\n        try {\n            responsePromise = handler.handle({\n                url,\n                request,\n                event,\n                params\n            });\n        } catch (err) {\n            responsePromise = Promise.reject(err);\n        }\n        const catchHandler = route?.catchHandler;\n        if (responsePromise instanceof Promise && (this._catchHandler || catchHandler)) {\n            responsePromise = responsePromise.catch(async (err)=>{\n                if (catchHandler) {\n                    if (true) {\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`Error thrown when responding to:  ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url)}. Falling back to route's Catch Handler.`);\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.error(\"Error thrown by:\", route);\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.error(err);\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n                    }\n                    try {\n                        return await catchHandler.handle({\n                            url,\n                            request,\n                            event,\n                            params\n                        });\n                    } catch (catchErr) {\n                        if (catchErr instanceof Error) {\n                            err = catchErr;\n                        }\n                    }\n                }\n                if (this._catchHandler) {\n                    if (true) {\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupCollapsed(`Error thrown when responding to:  ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url)}. Falling back to global Catch Handler.`);\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.error(\"Error thrown by:\", route);\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.error(err);\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.groupEnd();\n                    }\n                    return this._catchHandler.handle({\n                        url,\n                        request,\n                        event\n                    });\n                }\n                throw err;\n            });\n        }\n        return responsePromise;\n    }\n    findMatchingRoute({ url, sameOrigin, request, event }) {\n        const routes = this._routes.get(request.method) || [];\n        for (const route of routes){\n            let params;\n            const matchResult = route.match({\n                url,\n                sameOrigin,\n                request,\n                event\n            });\n            if (matchResult) {\n                if (true) {\n                    if (matchResult instanceof Promise) {\n                        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.warn(`While routing ${(0,_timeout_js__WEBPACK_IMPORTED_MODULE_0__.g)(url)}, an async matchCallback function was used. Please convert the following route to use a synchronous matchCallback function:`, route);\n                    }\n                }\n                params = matchResult;\n                if (Array.isArray(params) && params.length === 0) {\n                    params = undefined;\n                } else if (matchResult.constructor === Object && Object.keys(matchResult).length === 0) {\n                    params = undefined;\n                } else if (typeof matchResult === \"boolean\") {\n                    params = undefined;\n                }\n                return {\n                    route,\n                    params\n                };\n            }\n        }\n        return {};\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvU2Vyd2lzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkg7QUFDcEM7QUFDeUQ7QUFDakc7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsMENBQVU7QUFDdkQsZ0JBQWdCLElBQXFDO0FBQ3JEO0FBQ0Esb0JBQW9CLDBDQUFNO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQ0FBWTtBQUM5QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFrQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFxQztBQUN6RCxvQkFBb0IsMENBQU07QUFDMUI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULE1BQU07QUFDTixZQUFZLElBQXFDO0FBQ2pELFlBQVksMENBQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsSUFBcUM7QUFDekQsb0JBQW9CLDBDQUFNO0FBQzFCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxNQUFNO0FBQ04sWUFBWSxJQUFxQztBQUNqRCxZQUFZLDBDQUFNO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIseURBQUs7QUFDbkM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVCQUF1QixJ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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvU2Vyd2lzdC5qcz82NDY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY2FjaGVOYW1lcywgbCBhcyBsb2dnZXIsIFMgYXMgU2Vyd2lzdEVycm9yLCBmIGFzIGZpbmFsQXNzZXJ0RXhwb3J0cywgZyBhcyBnZXRGcmllbmRseVVSTCB9IGZyb20gJy4vdGltZW91dC5qcyc7XG5pbXBvcnQgeyBjIGFzIGNhbkNvbnN0cnVjdFJlc3BvbnNlRnJvbUJvZHlTdHJlYW0sIHcgYXMgd2FpdFVudGlsIH0gZnJvbSAnLi93YWl0VW50aWwuanMnO1xuaW1wb3J0IHsgUiBhcyBSb3V0ZSwgaSBhcyBpbml0aWFsaXplLCBQIGFzIFByZWNhY2hlRmFsbGJhY2tQbHVnaW4sIG4gYXMgbm9ybWFsaXplSGFuZGxlciwgZCBhcyBkZWZhdWx0TWV0aG9kIH0gZnJvbSAnLi9QcmVjYWNoZUZhbGxiYWNrUGx1Z2luLmpzJztcbmltcG9ydCB7IFMgYXMgU3RyYXRlZ3kgfSBmcm9tICcuL05ldHdvcmtPbmx5LmpzJztcblxuY29uc3QgU1VCU1RSSU5HX1RPX0ZJTkQgPSBcIi1wcmVjYWNoZS1cIjtcbmNvbnN0IGRlbGV0ZU91dGRhdGVkQ2FjaGVzID0gYXN5bmMgKGN1cnJlbnRQcmVjYWNoZU5hbWUsIHN1YnN0cmluZ1RvRmluZCA9IFNVQlNUUklOR19UT19GSU5EKT0+e1xuICAgIGNvbnN0IGNhY2hlTmFtZXMgPSBhd2FpdCBzZWxmLmNhY2hlcy5rZXlzKCk7XG4gICAgY29uc3QgY2FjaGVOYW1lc1RvRGVsZXRlID0gY2FjaGVOYW1lcy5maWx0ZXIoKGNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZS5pbmNsdWRlcyhzdWJzdHJpbmdUb0ZpbmQpICYmIGNhY2hlTmFtZS5pbmNsdWRlcyhzZWxmLnJlZ2lzdHJhdGlvbi5zY29wZSkgJiYgY2FjaGVOYW1lICE9PSBjdXJyZW50UHJlY2FjaGVOYW1lO1xuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKGNhY2hlTmFtZXNUb0RlbGV0ZS5tYXAoKGNhY2hlTmFtZSk9PnNlbGYuY2FjaGVzLmRlbGV0ZShjYWNoZU5hbWUpKSk7XG4gICAgcmV0dXJuIGNhY2hlTmFtZXNUb0RlbGV0ZTtcbn07XG5cbmNvbnN0IGNsZWFudXBPdXRkYXRlZENhY2hlcyA9IChjYWNoZU5hbWUpPT57XG4gICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiYWN0aXZhdGVcIiwgKGV2ZW50KT0+e1xuICAgICAgICBldmVudC53YWl0VW50aWwoZGVsZXRlT3V0ZGF0ZWRDYWNoZXMoY2FjaGVOYW1lcy5nZXRQcmVjYWNoZU5hbWUoY2FjaGVOYW1lKSkudGhlbigoY2FjaGVzRGVsZXRlZCk9PntcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVzRGVsZXRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJUaGUgZm9sbG93aW5nIG91dC1vZi1kYXRlIHByZWNhY2hlcyB3ZXJlIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseTpcIiwgY2FjaGVzRGVsZXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSk7XG59O1xuXG5jb25zdCBjbGllbnRzQ2xhaW0gPSAoKT0+e1xuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcImFjdGl2YXRlXCIsICgpPT5zZWxmLmNsaWVudHMuY2xhaW0oKSk7XG59O1xuXG5jb25zdCBjb3B5UmVzcG9uc2UgPSBhc3luYyAocmVzcG9uc2UsIG1vZGlmaWVyKT0+e1xuICAgIGxldCBvcmlnaW4gPSBudWxsO1xuICAgIGlmIChyZXNwb25zZS51cmwpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VVUkwgPSBuZXcgVVJMKHJlc3BvbnNlLnVybCk7XG4gICAgICAgIG9yaWdpbiA9IHJlc3BvbnNlVVJMLm9yaWdpbjtcbiAgICB9XG4gICAgaWYgKG9yaWdpbiAhPT0gc2VsZi5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImNyb3NzLW9yaWdpbi1jb3B5LXJlc3BvbnNlXCIsIHtcbiAgICAgICAgICAgIG9yaWdpblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVkUmVzcG9uc2UgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoY2xvbmVkUmVzcG9uc2UuaGVhZGVycyksXG4gICAgICAgIHN0YXR1czogY2xvbmVkUmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBjbG9uZWRSZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgfTtcbiAgICBjb25zdCBtb2RpZmllZFJlc3BvbnNlSW5pdCA9IG1vZGlmaWVyID8gbW9kaWZpZXIocmVzcG9uc2VJbml0KSA6IHJlc3BvbnNlSW5pdDtcbiAgICBjb25zdCBib2R5ID0gY2FuQ29uc3RydWN0UmVzcG9uc2VGcm9tQm9keVN0cmVhbSgpID8gY2xvbmVkUmVzcG9uc2UuYm9keSA6IGF3YWl0IGNsb25lZFJlc3BvbnNlLmJsb2IoKTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIG1vZGlmaWVkUmVzcG9uc2VJbml0KTtcbn07XG5cbmNvbnN0IGRpc2FibGVEZXZMb2dzID0gKCk9PntcbiAgICBzZWxmLl9fV0JfRElTQUJMRV9ERVZfTE9HUyA9IHRydWU7XG59O1xuXG5jb25zdCBpc05hdmlnYXRpb25QcmVsb2FkU3VwcG9ydGVkID0gKCk9PntcbiAgICByZXR1cm4gQm9vbGVhbihzZWxmLnJlZ2lzdHJhdGlvbj8ubmF2aWdhdGlvblByZWxvYWQpO1xufTtcbmNvbnN0IGVuYWJsZU5hdmlnYXRpb25QcmVsb2FkID0gKGhlYWRlclZhbHVlKT0+e1xuICAgIGlmIChpc05hdmlnYXRpb25QcmVsb2FkU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiYWN0aXZhdGVcIiwgKGV2ZW50KT0+e1xuICAgICAgICAgICAgZXZlbnQud2FpdFVudGlsKHNlbGYucmVnaXN0cmF0aW9uLm5hdmlnYXRpb25QcmVsb2FkLmVuYWJsZSgpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICBpZiAoaGVhZGVyVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdm9pZCBzZWxmLnJlZ2lzdHJhdGlvbi5uYXZpZ2F0aW9uUHJlbG9hZC5zZXRIZWFkZXJWYWx1ZShoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIk5hdmlnYXRpb24gcHJlbG9hZGluZyBpcyBlbmFibGVkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5sb2coXCJOYXZpZ2F0aW9uIHByZWxvYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuXCIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IGRpc2FibGVOYXZpZ2F0aW9uUHJlbG9hZCA9ICgpPT57XG4gICAgaWYgKGlzTmF2aWdhdGlvblByZWxvYWRTdXBwb3J0ZWQoKSkge1xuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCAoZXZlbnQpPT57XG4gICAgICAgICAgICBldmVudC53YWl0VW50aWwoc2VsZi5yZWdpc3RyYXRpb24ubmF2aWdhdGlvblByZWxvYWQuZGlzYWJsZSgpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coXCJOYXZpZ2F0aW9uIHByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhcIk5hdmlnYXRpb24gcHJlbG9hZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci5cIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5jbGFzcyBOYXZpZ2F0aW9uUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgX2FsbG93bGlzdDtcbiAgICBfZGVueWxpc3Q7XG4gICAgY29uc3RydWN0b3IoaGFuZGxlciwgeyBhbGxvd2xpc3QgPSBbXG4gICAgICAgIC8uL1xuICAgIF0sIGRlbnlsaXN0ID0gW10gfSA9IHt9KXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzQXJyYXlPZkNsYXNzKGFsbG93bGlzdCwgUmVnRXhwLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIk5hdmlnYXRpb25Sb3V0ZVwiLFxuICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcIm9wdGlvbnMuYWxsb3dsaXN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzQXJyYXlPZkNsYXNzKGRlbnlsaXN0LCBSZWdFeHAsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiTmF2aWdhdGlvblJvdXRlXCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwib3B0aW9ucy5kZW55bGlzdFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigob3B0aW9ucyk9PnRoaXMuX21hdGNoKG9wdGlvbnMpLCBoYW5kbGVyKTtcbiAgICAgICAgdGhpcy5fYWxsb3dsaXN0ID0gYWxsb3dsaXN0O1xuICAgICAgICB0aGlzLl9kZW55bGlzdCA9IGRlbnlsaXN0O1xuICAgIH1cbiAgICBfbWF0Y2goeyB1cmwsIHJlcXVlc3QgfSkge1xuICAgICAgICBpZiAocmVxdWVzdCAmJiByZXF1ZXN0Lm1vZGUgIT09IFwibmF2aWdhdGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lQW5kU2VhcmNoID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgZm9yIChjb25zdCByZWdFeHAgb2YgdGhpcy5fZGVueWxpc3Qpe1xuICAgICAgICAgICAgaWYgKHJlZ0V4cC50ZXN0KHBhdGhuYW1lQW5kU2VhcmNoKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyhgVGhlIG5hdmlnYXRpb24gcm91dGUgJHtwYXRobmFtZUFuZFNlYXJjaH0gaXMgbm90IGJlaW5nIHVzZWQsIHNpbmNlIHRoZSBVUkwgbWF0Y2hlcyB0aGlzIGRlbnlsaXN0IHBhdHRlcm46ICR7cmVnRXhwLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYWxsb3dsaXN0LnNvbWUoKHJlZ0V4cCk9PnJlZ0V4cC50ZXN0KHBhdGhuYW1lQW5kU2VhcmNoKSkpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSBuYXZpZ2F0aW9uIHJvdXRlICR7cGF0aG5hbWVBbmRTZWFyY2h9IGlzIGJlaW5nIHVzZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBsb2dnZXIubG9nKGBUaGUgbmF2aWdhdGlvbiByb3V0ZSAke3BhdGhuYW1lQW5kU2VhcmNofSBpcyBub3QgYmVpbmcgdXNlZCwgc2luY2UgdGhlIFVSTCBiZWluZyBuYXZpZ2F0ZWQgdG8gZG9lc24ndCBtYXRjaCB0aGUgYWxsb3dsaXN0LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIFJlZ0V4cFJvdXRlIGV4dGVuZHMgUm91dGUge1xuICAgIGNvbnN0cnVjdG9yKHJlZ0V4cCwgaGFuZGxlciwgbWV0aG9kKXtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2UocmVnRXhwLCBSZWdFeHAsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiUmVnRXhwUm91dGVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJjb25zdHJ1Y3RvclwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJwYXR0ZXJuXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoID0gKHsgdXJsIH0pPT57XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWdFeHAuZXhlYyh1cmwuaHJlZik7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwub3JpZ2luICE9PSBsb2NhdGlvbi5vcmlnaW4gJiYgcmVzdWx0LmluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFRoZSByZWd1bGFyIGV4cHJlc3Npb24gJyR7cmVnRXhwLnRvU3RyaW5nKCl9JyBvbmx5IHBhcnRpYWxseSBtYXRjaGVkIGFnYWluc3QgdGhlIGNyb3NzLW9yaWdpbiBVUkwgJyR7dXJsLnRvU3RyaW5nKCl9Jy4gUmVnRXhwUm91dGUncyB3aWxsIG9ubHkgaGFuZGxlIGNyb3NzLW9yaWdpbiByZXF1ZXN0cyBpZiB0aGV5IG1hdGNoIHRoZSBlbnRpcmUgVVJMLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpO1xuICAgICAgICB9O1xuICAgICAgICBzdXBlcihtYXRjaCwgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9XG59XG5cbmNvbnN0IHBhcnNlUm91dGUgPSAoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKT0+e1xuICAgIGxldCByb3V0ZTtcbiAgICBpZiAodHlwZW9mIGNhcHR1cmUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgY2FwdHVyZVVybCA9IG5ldyBVUkwoY2FwdHVyZSwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKGNhcHR1cmUuc3RhcnRzV2l0aChcIi9cIikgfHwgY2FwdHVyZS5zdGFydHNXaXRoKFwiaHR0cFwiKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC1zdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcInNlcndpc3RcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IFwicGFyc2VSb3V0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiY2FwdHVyZVwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVRvQ2hlY2sgPSBjYXB0dXJlLnN0YXJ0c1dpdGgoXCJodHRwXCIpID8gY2FwdHVyZVVybC5wYXRobmFtZSA6IGNhcHR1cmU7XG4gICAgICAgICAgICBjb25zdCB3aWxkY2FyZHMgPSBcIlsqOj8rXVwiO1xuICAgICAgICAgICAgaWYgKG5ldyBSZWdFeHAoYCR7d2lsZGNhcmRzfWApLmV4ZWModmFsdWVUb0NoZWNrKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlICckY2FwdHVyZScgcGFyYW1ldGVyIGNvbnRhaW5zIGFuIEV4cHJlc3Mtc3R5bGUgd2lsZGNhcmQgY2hhcmFjdGVyICgke3dpbGRjYXJkc30pLiBTdHJpbmdzIGFyZSBub3cgYWx3YXlzIGludGVycHJldGVkIGFzIGV4YWN0IG1hdGNoZXM7IHVzZSBhIFJlZ0V4cCBmb3IgcGFydGlhbCBvciB3aWxkY2FyZCBtYXRjaGVzLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoQ2FsbGJhY2sgPSAoeyB1cmwgfSk9PntcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodXJsLnBhdGhuYW1lID09PSBjYXB0dXJlVXJsLnBhdGhuYW1lICYmIHVybC5vcmlnaW4gIT09IGNhcHR1cmVVcmwub3JpZ2luKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgJHtjYXB0dXJlfSBvbmx5IHBhcnRpYWxseSBtYXRjaGVzIHRoZSBjcm9zcy1vcmlnaW4gVVJMICR7dXJsLnRvU3RyaW5nKCl9LiBUaGlzIHJvdXRlIHdpbGwgb25seSBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGlmIHRoZXkgbWF0Y2ggdGhlIGVudGlyZSBVUkwuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVybC5ocmVmID09PSBjYXB0dXJlVXJsLmhyZWY7XG4gICAgICAgIH07XG4gICAgICAgIHJvdXRlID0gbmV3IFJvdXRlKG1hdGNoQ2FsbGJhY2ssIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfSBlbHNlIGlmIChjYXB0dXJlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJvdXRlID0gbmV3IFJlZ0V4cFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJvdXRlID0gbmV3IFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfSBlbHNlIGlmIChjYXB0dXJlIGluc3RhbmNlb2YgUm91dGUpIHtcbiAgICAgICAgcm91dGUgPSBjYXB0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJ1bnN1cHBvcnRlZC1yb3V0ZS10eXBlXCIsIHtcbiAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgZnVuY05hbWU6IFwicGFyc2VSb3V0ZVwiLFxuICAgICAgICAgICAgcGFyYW1OYW1lOiBcImNhcHR1cmVcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdXRlO1xufTtcblxuY29uc3QgcmVtb3ZlSWdub3JlZFNlYXJjaFBhcmFtcyA9ICh1cmxPYmplY3QsIGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZyA9IFtdKT0+e1xuICAgIGZvciAoY29uc3QgcGFyYW1OYW1lIG9mIFtcbiAgICAgICAgLi4udXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5rZXlzKClcbiAgICBdKXtcbiAgICAgICAgaWYgKGlnbm9yZVVSTFBhcmFtZXRlcnNNYXRjaGluZy5zb21lKChyZWdFeHApPT5yZWdFeHAudGVzdChwYXJhbU5hbWUpKSkge1xuICAgICAgICAgICAgdXJsT2JqZWN0LnNlYXJjaFBhcmFtcy5kZWxldGUocGFyYW1OYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsT2JqZWN0O1xufTtcblxuZnVuY3Rpb24qIGdlbmVyYXRlVVJMVmFyaWF0aW9ucyh1cmwsIHsgZGlyZWN0b3J5SW5kZXggPSBcImluZGV4Lmh0bWxcIiwgaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nID0gW1xuICAgIC9edXRtXy8sXG4gICAgL15mYmNsaWQkL1xuXSwgY2xlYW5VUkxzID0gdHJ1ZSwgdXJsTWFuaXB1bGF0aW9uIH0gPSB7fSkge1xuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICB1cmxPYmplY3QuaGFzaCA9IFwiXCI7XG4gICAgeWllbGQgdXJsT2JqZWN0LmhyZWY7XG4gICAgY29uc3QgdXJsV2l0aG91dElnbm9yZWRQYXJhbXMgPSByZW1vdmVJZ25vcmVkU2VhcmNoUGFyYW1zKHVybE9iamVjdCwgaWdub3JlVVJMUGFyYW1ldGVyc01hdGNoaW5nKTtcbiAgICB5aWVsZCB1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5ocmVmO1xuICAgIGlmIChkaXJlY3RvcnlJbmRleCAmJiB1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgY29uc3QgZGlyZWN0b3J5VVJMID0gbmV3IFVSTCh1cmxXaXRob3V0SWdub3JlZFBhcmFtcy5ocmVmKTtcbiAgICAgICAgZGlyZWN0b3J5VVJMLnBhdGhuYW1lICs9IGRpcmVjdG9yeUluZGV4O1xuICAgICAgICB5aWVsZCBkaXJlY3RvcnlVUkwuaHJlZjtcbiAgICB9XG4gICAgaWYgKGNsZWFuVVJMcykge1xuICAgICAgICBjb25zdCBjbGVhblVSTCA9IG5ldyBVUkwodXJsV2l0aG91dElnbm9yZWRQYXJhbXMuaHJlZik7XG4gICAgICAgIGNsZWFuVVJMLnBhdGhuYW1lICs9IFwiLmh0bWxcIjtcbiAgICAgICAgeWllbGQgY2xlYW5VUkwuaHJlZjtcbiAgICB9XG4gICAgaWYgKHVybE1hbmlwdWxhdGlvbikge1xuICAgICAgICBjb25zdCBhZGRpdGlvbmFsVVJMcyA9IHVybE1hbmlwdWxhdGlvbih7XG4gICAgICAgICAgICB1cmw6IHVybE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCB1cmxUb0F0dGVtcHQgb2YgYWRkaXRpb25hbFVSTHMpe1xuICAgICAgICAgICAgeWllbGQgdXJsVG9BdHRlbXB0LmhyZWY7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIFByZWNhY2hlUm91dGUgZXh0ZW5kcyBSb3V0ZSB7XG4gICAgY29uc3RydWN0b3Ioc2Vyd2lzdCwgb3B0aW9ucyl7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gKHsgcmVxdWVzdCB9KT0+e1xuICAgICAgICAgICAgY29uc3QgdXJsc1RvQ2FjaGVLZXlzID0gc2Vyd2lzdC5nZXRVcmxzVG9QcmVjYWNoZUtleXMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zc2libGVVUkwgb2YgZ2VuZXJhdGVVUkxWYXJpYXRpb25zKHJlcXVlc3QudXJsLCBvcHRpb25zKSl7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB1cmxzVG9DYWNoZUtleXMuZ2V0KHBvc3NpYmxlVVJMKTtcbiAgICAgICAgICAgICAgICBpZiAoY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZWdyaXR5ID0gc2Vyd2lzdC5nZXRJbnRlZ3JpdHlGb3JQcmVjYWNoZUtleShjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVncml0eVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYFByZWNhY2hpbmcgZGlkIG5vdCBmaW5kIGEgbWF0Y2ggZm9yICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIobWF0Y2gsIHNlcndpc3QucHJlY2FjaGVTdHJhdGVneSk7XG4gICAgfVxufVxuXG5jbGFzcyBQcmVjYWNoZVN0cmF0ZWd5IGV4dGVuZHMgU3RyYXRlZ3kge1xuICAgIF9mYWxsYmFja1RvTmV0d29yaztcbiAgICBzdGF0aWMgZGVmYXVsdFByZWNhY2hlQ2FjaGVhYmlsaXR5UGx1Z2luID0ge1xuICAgICAgICBhc3luYyBjYWNoZVdpbGxVcGRhdGUgKHsgcmVzcG9uc2UgfSkge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCByZXNwb25zZS5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0YXRpYyBjb3B5UmVkaXJlY3RlZENhY2hlYWJsZVJlc3BvbnNlc1BsdWdpbiA9IHtcbiAgICAgICAgYXN5bmMgY2FjaGVXaWxsVXBkYXRlICh7IHJlc3BvbnNlIH0pIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5yZWRpcmVjdGVkID8gYXdhaXQgY29weVJlc3BvbnNlKHJlc3BvbnNlKSA6IHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pe1xuICAgICAgICBvcHRpb25zLmNhY2hlTmFtZSA9IGNhY2hlTmFtZXMuZ2V0UHJlY2FjaGVOYW1lKG9wdGlvbnMuY2FjaGVOYW1lKTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2ZhbGxiYWNrVG9OZXR3b3JrID0gb3B0aW9ucy5mYWxsYmFja1RvTmV0d29yayA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG4gICAgICAgIHRoaXMucGx1Z2lucy5wdXNoKFByZWNhY2hlU3RyYXRlZ3kuY29weVJlZGlyZWN0ZWRDYWNoZWFibGVSZXNwb25zZXNQbHVnaW4pO1xuICAgIH1cbiAgICBhc3luYyBfaGFuZGxlKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmNhY2hlTWF0Y2gocmVxdWVzdCk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyLmV2ZW50ICYmIGhhbmRsZXIuZXZlbnQudHlwZSA9PT0gXCJpbnN0YWxsXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9oYW5kbGVGZXRjaChyZXF1ZXN0LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgYXN5bmMgX2hhbmRsZUZldGNoKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBoYW5kbGVyLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgaWYgKHRoaXMuX2ZhbGxiYWNrVG9OZXR3b3JrKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBwcmVjYWNoZWQgcmVzcG9uc2UgZm9yICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSBpbiAke3RoaXMuY2FjaGVOYW1lfSB3YXMgbm90IGZvdW5kLiBGYWxsaW5nIGJhY2sgdG8gdGhlIG5ldHdvcmsuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHlJbk1hbmlmZXN0ID0gcGFyYW1zLmludGVncml0eTtcbiAgICAgICAgICAgIGNvbnN0IGludGVncml0eUluUmVxdWVzdCA9IHJlcXVlc3QuaW50ZWdyaXR5O1xuICAgICAgICAgICAgY29uc3Qgbm9JbnRlZ3JpdHlDb25mbGljdCA9ICFpbnRlZ3JpdHlJblJlcXVlc3QgfHwgaW50ZWdyaXR5SW5SZXF1ZXN0ID09PSBpbnRlZ3JpdHlJbk1hbmlmZXN0O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyLmZldGNoKG5ldyBSZXF1ZXN0KHJlcXVlc3QsIHtcbiAgICAgICAgICAgICAgICBpbnRlZ3JpdHk6IHJlcXVlc3QubW9kZSAhPT0gXCJuby1jb3JzXCIgPyBpbnRlZ3JpdHlJblJlcXVlc3QgfHwgaW50ZWdyaXR5SW5NYW5pZmVzdCA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGludGVncml0eUluTWFuaWZlc3QgJiYgbm9JbnRlZ3JpdHlDb25mbGljdCAmJiByZXF1ZXN0Lm1vZGUgIT09IFwibm8tY29yc1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXNlRGVmYXVsdENhY2hlYWJpbGl0eVBsdWdpbklmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2FzQ2FjaGVkID0gYXdhaXQgaGFuZGxlci5jYWNoZVB1dChyZXF1ZXN0LCByZXNwb25zZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3YXNDYWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2coYEEgcmVzcG9uc2UgZm9yICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfSB3YXMgdXNlZCB0byBcInJlcGFpclwiIHRoZSBwcmVjYWNoZS5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJtaXNzaW5nLXByZWNhY2hlLWVudHJ5XCIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWU6IHRoaXMuY2FjaGVOYW1lLFxuICAgICAgICAgICAgICAgIHVybDogcmVxdWVzdC51cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGFyYW1zLmNhY2hlS2V5IHx8IGF3YWl0IGhhbmRsZXIuZ2V0Q2FjaGVLZXkocmVxdWVzdCwgXCJyZWFkXCIpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBQcmVjYWNoaW5nIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwocmVxdWVzdC51cmwpfWApO1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhgU2VydmluZyB0aGUgcHJlY2FjaGVkIHVybDogJHtnZXRGcmllbmRseVVSTChjYWNoZUtleSBpbnN0YW5jZW9mIFJlcXVlc3QgPyBjYWNoZUtleS51cmwgOiBjYWNoZUtleSl9YCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoXCJWaWV3IHJlcXVlc3QgZGV0YWlscyBoZXJlLlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVxdWVzdCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChcIlZpZXcgcmVzcG9uc2UgZGV0YWlscyBoZXJlLlwiKTtcbiAgICAgICAgICAgIGxvZ2dlci5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVJbnN0YWxsKHJlcXVlc3QsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fdXNlRGVmYXVsdENhY2hlYWJpbGl0eVBsdWdpbklmTmVlZGVkKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlci5mZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3Qgd2FzQ2FjaGVkID0gYXdhaXQgaGFuZGxlci5jYWNoZVB1dChyZXF1ZXN0LCByZXNwb25zZS5jbG9uZSgpKTtcbiAgICAgICAgaWYgKCF3YXNDYWNoZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJiYWQtcHJlY2FjaGluZy1yZXNwb25zZVwiLCB7XG4gICAgICAgICAgICAgICAgdXJsOiByZXF1ZXN0LnVybCxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICBfdXNlRGVmYXVsdENhY2hlYWJpbGl0eVBsdWdpbklmTmVlZGVkKCkge1xuICAgICAgICBsZXQgZGVmYXVsdFBsdWdpbkluZGV4ID0gbnVsbDtcbiAgICAgICAgbGV0IGNhY2hlV2lsbFVwZGF0ZVBsdWdpbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBbaW5kZXgsIHBsdWdpbl0gb2YgdGhpcy5wbHVnaW5zLmVudHJpZXMoKSl7XG4gICAgICAgICAgICBpZiAocGx1Z2luID09PSBQcmVjYWNoZVN0cmF0ZWd5LmNvcHlSZWRpcmVjdGVkQ2FjaGVhYmxlUmVzcG9uc2VzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGx1Z2luID09PSBQcmVjYWNoZVN0cmF0ZWd5LmRlZmF1bHRQcmVjYWNoZUNhY2hlYWJpbGl0eVBsdWdpbikge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRQbHVnaW5JbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsdWdpbi5jYWNoZVdpbGxVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZVdpbGxVcGRhdGVQbHVnaW5Db3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZVdpbGxVcGRhdGVQbHVnaW5Db3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zLnB1c2goUHJlY2FjaGVTdHJhdGVneS5kZWZhdWx0UHJlY2FjaGVDYWNoZWFiaWxpdHlQbHVnaW4pO1xuICAgICAgICB9IGVsc2UgaWYgKGNhY2hlV2lsbFVwZGF0ZVBsdWdpbkNvdW50ID4gMSAmJiBkZWZhdWx0UGx1Z2luSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2lucy5zcGxpY2UoZGVmYXVsdFBsdWdpbkluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3Qgc2V0Q2FjaGVOYW1lRGV0YWlscyA9IChkZXRhaWxzKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZGV0YWlscykpe1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShkZXRhaWxzW2tleV0sIFwic3RyaW5nXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2NvcmVcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJzZXRDYWNoZU5hbWVEZXRhaWxzXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBgZGV0YWlscy4ke2tleX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5wcmVjYWNoZT8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC1jYWNoZS1uYW1lXCIsIHtcbiAgICAgICAgICAgICAgICBjYWNoZU5hbWVJZDogXCJwcmVjYWNoZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBkZXRhaWxzLnByZWNhY2hlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5ydW50aW1lPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJpbnZhbGlkLWNhY2hlLW5hbWVcIiwge1xuICAgICAgICAgICAgICAgIGNhY2hlTmFtZUlkOiBcInJ1bnRpbWVcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogZGV0YWlscy5ydW50aW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0YWlscy5nb29nbGVBbmFseXRpY3M/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImludmFsaWQtY2FjaGUtbmFtZVwiLCB7XG4gICAgICAgICAgICAgICAgY2FjaGVOYW1lSWQ6IFwiZ29vZ2xlQW5hbHl0aWNzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGRldGFpbHMuZ29vZ2xlQW5hbHl0aWNzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZU5hbWVzLnVwZGF0ZURldGFpbHMoZGV0YWlscyk7XG59O1xuXG5jb25zdCBwYXJhbGxlbCA9IGFzeW5jIChsaW1pdCwgYXJyYXksIGZ1bmMpPT57XG4gICAgY29uc3Qgd29yayA9IGFycmF5Lm1hcCgoaXRlbSwgaW5kZXgpPT4oe1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBpdGVtXG4gICAgICAgIH0pKTtcbiAgICBjb25zdCBwcm9jZXNzb3IgPSBhc3luYyAocmVzKT0+e1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIHdoaWxlKHRydWUpe1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHdvcmsucG9wKCk7XG4gICAgICAgICAgICBpZiAoIW5leHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzKHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZnVuYyhuZXh0Lml0ZW0pO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICBpbmRleDogbmV4dC5pbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHF1ZXVlcyA9IEFycmF5LmZyb20oe1xuICAgICAgICBsZW5ndGg6IGxpbWl0XG4gICAgfSwgKCk9Pm5ldyBQcm9taXNlKHByb2Nlc3NvcikpO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAoYXdhaXQgUHJvbWlzZS5hbGwocXVldWVzKSkuZmxhdCgpLnNvcnQoKGEsIGIpPT5hLmluZGV4IDwgYi5pbmRleCA/IC0xIDogMSkubWFwKChyZXMpPT5yZXMucmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbmNsYXNzIFByZWNhY2hlQ2FjaGVLZXlQbHVnaW4ge1xuICAgIF9wcmVjYWNoZUNvbnRyb2xsZXI7XG4gICAgY29uc3RydWN0b3IoeyBwcmVjYWNoZUNvbnRyb2xsZXIgfSl7XG4gICAgICAgIHRoaXMuX3ByZWNhY2hlQ29udHJvbGxlciA9IHByZWNhY2hlQ29udHJvbGxlcjtcbiAgICB9XG4gICAgY2FjaGVLZXlXaWxsQmVVc2VkID0gYXN5bmMgKHsgcmVxdWVzdCwgcGFyYW1zIH0pPT57XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gcGFyYW1zPy5jYWNoZUtleSB8fCB0aGlzLl9wcmVjYWNoZUNvbnRyb2xsZXIuZ2V0UHJlY2FjaGVLZXlGb3JVcmwocmVxdWVzdC51cmwpO1xuICAgICAgICByZXR1cm4gY2FjaGVLZXkgPyBuZXcgUmVxdWVzdChjYWNoZUtleSwge1xuICAgICAgICAgICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzXG4gICAgICAgIH0pIDogcmVxdWVzdDtcbiAgICB9O1xufVxuXG5jbGFzcyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4ge1xuICAgIHVwZGF0ZWRVUkxzID0gW107XG4gICAgbm90VXBkYXRlZFVSTHMgPSBbXTtcbiAgICBoYW5kbGVyV2lsbFN0YXJ0ID0gYXN5bmMgKHsgcmVxdWVzdCwgc3RhdGUgfSk9PntcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZS5vcmlnaW5hbFJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQgPSBhc3luYyAoeyBldmVudCwgc3RhdGUsIGNhY2hlZFJlc3BvbnNlIH0pPT57XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcImluc3RhbGxcIikge1xuICAgICAgICAgICAgaWYgKHN0YXRlPy5vcmlnaW5hbFJlcXVlc3QgJiYgc3RhdGUub3JpZ2luYWxSZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHN0YXRlLm9yaWdpbmFsUmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90VXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZFVSTHMucHVzaCh1cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gICAgfTtcbn1cblxuY29uc3QgUkVWSVNJT05fU0VBUkNIX1BBUkFNID0gXCJfX1dCX1JFVklTSU9OX19cIjtcbmNvbnN0IGNyZWF0ZUNhY2hlS2V5ID0gKGVudHJ5KT0+e1xuICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImFkZC10by1jYWNoZS1saXN0LXVuZXhwZWN0ZWQtdHlwZVwiLCB7XG4gICAgICAgICAgICBlbnRyeVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB1cmxPYmplY3QgPSBuZXcgVVJMKGVudHJ5LCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhY2hlS2V5OiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgICAgIHVybDogdXJsT2JqZWN0LmhyZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgeyByZXZpc2lvbiwgdXJsIH0gPSBlbnRyeTtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiYWRkLXRvLWNhY2hlLWxpc3QtdW5leHBlY3RlZC10eXBlXCIsIHtcbiAgICAgICAgICAgIGVudHJ5XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXJldmlzaW9uKSB7XG4gICAgICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNhY2hlS2V5OiB1cmxPYmplY3QuaHJlZixcbiAgICAgICAgICAgIHVybDogdXJsT2JqZWN0LmhyZWZcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXlVUkwgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgY29uc3Qgb3JpZ2luYWxVUkwgPSBuZXcgVVJMKHVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgY2FjaGVLZXlVUkwuc2VhcmNoUGFyYW1zLnNldChSRVZJU0lPTl9TRUFSQ0hfUEFSQU0sIHJldmlzaW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWNoZUtleTogY2FjaGVLZXlVUkwuaHJlZixcbiAgICAgICAgdXJsOiBvcmlnaW5hbFVSTC5ocmVmXG4gICAgfTtcbn07XG5cbmNvbnN0IGxvZ0dyb3VwID0gKGdyb3VwVGl0bGUsIGRlbGV0ZWRVUkxzKT0+e1xuICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChncm91cFRpdGxlKTtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiBkZWxldGVkVVJMcyl7XG4gICAgICAgIGxvZ2dlci5sb2codXJsKTtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG59O1xuY29uc3QgcHJpbnRDbGVhbnVwRGV0YWlscyA9IChkZWxldGVkVVJMcyk9PntcbiAgICBjb25zdCBkZWxldGlvbkNvdW50ID0gZGVsZXRlZFVSTHMubGVuZ3RoO1xuICAgIGlmIChkZWxldGlvbkNvdW50ID4gMCkge1xuICAgICAgICBsb2dnZXIuZ3JvdXBDb2xsYXBzZWQoYER1cmluZyBwcmVjYWNoaW5nIGNsZWFudXAsICR7ZGVsZXRpb25Db3VudH0gY2FjaGVkIHJlcXVlc3Qke2RlbGV0aW9uQ291bnQgPT09IDEgPyBcIiB3YXNcIiA6IFwicyB3ZXJlXCJ9IGRlbGV0ZWQuYCk7XG4gICAgICAgIGxvZ0dyb3VwKFwiRGVsZXRlZCBDYWNoZSBSZXF1ZXN0c1wiLCBkZWxldGVkVVJMcyk7XG4gICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIF9uZXN0ZWRHcm91cChncm91cFRpdGxlLCB1cmxzKSB7XG4gICAgaWYgKHVybHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGdyb3VwVGl0bGUpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpe1xuICAgICAgICBsb2dnZXIubG9nKHVybCk7XG4gICAgfVxuICAgIGxvZ2dlci5ncm91cEVuZCgpO1xufVxuY29uc3QgcHJpbnRJbnN0YWxsRGV0YWlscyA9ICh1cmxzVG9QcmVjYWNoZSwgdXJsc0FscmVhZHlQcmVjYWNoZWQpPT57XG4gICAgY29uc3QgcHJlY2FjaGVkQ291bnQgPSB1cmxzVG9QcmVjYWNoZS5sZW5ndGg7XG4gICAgY29uc3QgYWxyZWFkeVByZWNhY2hlZENvdW50ID0gdXJsc0FscmVhZHlQcmVjYWNoZWQubGVuZ3RoO1xuICAgIGlmIChwcmVjYWNoZWRDb3VudCB8fCBhbHJlYWR5UHJlY2FjaGVkQ291bnQpIHtcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgUHJlY2FjaGluZyAke3ByZWNhY2hlZENvdW50fSBmaWxlJHtwcmVjYWNoZWRDb3VudCA9PT0gMSA/IFwiXCIgOiBcInNcIn0uYDtcbiAgICAgICAgaWYgKGFscmVhZHlQcmVjYWNoZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCAke2FscmVhZHlQcmVjYWNoZWRDb3VudH0gYCArIGBmaWxlJHthbHJlYWR5UHJlY2FjaGVkQ291bnQgPT09IDEgPyBcIiBpc1wiIDogXCJzIGFyZVwifSBhbHJlYWR5IGNhY2hlZC5gO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChtZXNzYWdlKTtcbiAgICAgICAgX25lc3RlZEdyb3VwKFwiVmlldyBuZXdseSBwcmVjYWNoZWQgVVJMcy5cIiwgdXJsc1RvUHJlY2FjaGUpO1xuICAgICAgICBfbmVzdGVkR3JvdXAoXCJWaWV3IHByZXZpb3VzbHkgcHJlY2FjaGVkIFVSTHMuXCIsIHVybHNBbHJlYWR5UHJlY2FjaGVkKTtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufTtcblxuY2xhc3MgU2Vyd2lzdCB7XG4gICAgX3VybHNUb0NhY2hlS2V5cyA9IG5ldyBNYXAoKTtcbiAgICBfdXJsc1RvQ2FjaGVNb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBfY2FjaGVLZXlzVG9JbnRlZ3JpdGllcyA9IG5ldyBNYXAoKTtcbiAgICBfY29uY3VycmVudFByZWNhY2hpbmc7XG4gICAgX3ByZWNhY2hlU3RyYXRlZ3k7XG4gICAgX3JvdXRlcztcbiAgICBfZGVmYXVsdEhhbmRsZXJNYXA7XG4gICAgX2NhdGNoSGFuZGxlcjtcbiAgICBjb25zdHJ1Y3Rvcih7IHByZWNhY2hlRW50cmllcywgcHJlY2FjaGVPcHRpb25zLCBjbGVhbnVwT3V0ZGF0ZWRDYWNoZXM6IGNsZWFudXBPdXRkYXRlZENhY2hlcyQxLCBuYXZpZ2F0ZUZhbGxiYWNrLCBuYXZpZ2F0ZUZhbGxiYWNrQWxsb3dsaXN0LCBuYXZpZ2F0ZUZhbGxiYWNrRGVueWxpc3QsIHBsdWdpbnMgPSBbXSwgZmFsbGJhY2tUb05ldHdvcmsgPSB0cnVlLCBjb25jdXJyZW50UHJlY2FjaGluZyA9IDEsIHNraXBXYWl0aW5nID0gZmFsc2UsIGltcG9ydFNjcmlwdHMsIG5hdmlnYXRpb25QcmVsb2FkID0gZmFsc2UsIGNhY2hlSWQsIGNsaWVudHNDbGFpbTogY2xpZW50c0NsYWltJDEgPSBmYWxzZSwgcnVudGltZUNhY2hpbmcsIG9mZmxpbmVBbmFseXRpY3NDb25maWcsIGRpc2FibGVEZXZMb2dzOiBkaXNhYmxlRGV2TG9ncyQxID0gZmFsc2UsIGZhbGxiYWNrcyB9ID0ge30pe1xuICAgICAgICB0aGlzLl9jb25jdXJyZW50UHJlY2FjaGluZyA9IGNvbmN1cnJlbnRQcmVjYWNoaW5nO1xuICAgICAgICB0aGlzLl9wcmVjYWNoZVN0cmF0ZWd5ID0gbmV3IFByZWNhY2hlU3RyYXRlZ3koe1xuICAgICAgICAgICAgY2FjaGVOYW1lOiBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShwcmVjYWNoZU9wdGlvbnM/LmNhY2hlTmFtZSksXG4gICAgICAgICAgICBwbHVnaW5zOiBbXG4gICAgICAgICAgICAgICAgLi4ucGx1Z2lucyxcbiAgICAgICAgICAgICAgICBuZXcgUHJlY2FjaGVDYWNoZUtleVBsdWdpbih7XG4gICAgICAgICAgICAgICAgICAgIHByZWNhY2hlQ29udHJvbGxlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZmFsbGJhY2tUb05ldHdvcmtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JvdXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5zdGFsbCA9IHRoaXMuaGFuZGxlSW5zdGFsbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUFjdGl2YXRlID0gdGhpcy5oYW5kbGVBY3RpdmF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUZldGNoID0gdGhpcy5oYW5kbGVGZXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNhY2hlID0gdGhpcy5oYW5kbGVDYWNoZS5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAoISFpbXBvcnRTY3JpcHRzICYmIGltcG9ydFNjcmlwdHMubGVuZ3RoID4gMCkgc2VsZi5pbXBvcnRTY3JpcHRzKC4uLmltcG9ydFNjcmlwdHMpO1xuICAgICAgICBpZiAobmF2aWdhdGlvblByZWxvYWQpIGVuYWJsZU5hdmlnYXRpb25QcmVsb2FkKCk7XG4gICAgICAgIGlmIChjYWNoZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNldENhY2hlTmFtZURldGFpbHMoe1xuICAgICAgICAgICAgICAgIHByZWZpeDogY2FjaGVJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBXYWl0aW5nKSB7XG4gICAgICAgICAgICBzZWxmLnNraXBXYWl0aW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChldmVudCk9PntcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUgPT09IFwiU0tJUF9XQUlUSU5HXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5za2lwV2FpdGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGllbnRzQ2xhaW0kMSkgY2xpZW50c0NsYWltKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJSb3V0ZShuZXcgUHJlY2FjaGVSb3V0ZSh0aGlzLCBwcmVjYWNoZU9wdGlvbnMpKTtcbiAgICAgICAgaWYgKCEhcHJlY2FjaGVFbnRyaWVzICYmIHByZWNhY2hlRW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRvUHJlY2FjaGVMaXN0KHByZWNhY2hlRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsZWFudXBPdXRkYXRlZENhY2hlcyQxKSB7XG4gICAgICAgICAgICBjbGVhbnVwT3V0ZGF0ZWRDYWNoZXMocHJlY2FjaGVPcHRpb25zPy5jYWNoZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXZpZ2F0ZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyUm91dGUobmV3IE5hdmlnYXRpb25Sb3V0ZSh0aGlzLmNyZWF0ZUhhbmRsZXJCb3VuZFRvVXJsKG5hdmlnYXRlRmFsbGJhY2spLCB7XG4gICAgICAgICAgICAgICAgYWxsb3dsaXN0OiBuYXZpZ2F0ZUZhbGxiYWNrQWxsb3dsaXN0LFxuICAgICAgICAgICAgICAgIGRlbnlsaXN0OiBuYXZpZ2F0ZUZhbGxiYWNrRGVueWxpc3RcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2ZmbGluZUFuYWx5dGljc0NvbmZpZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9mZmxpbmVBbmFseXRpY3NDb25maWcgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgb2ZmbGluZUFuYWx5dGljc0NvbmZpZyAmJiBpbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgc2Vyd2lzdDogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ub2ZmbGluZUFuYWx5dGljc0NvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgc2Vyd2lzdDogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChydW50aW1lQ2FjaGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZmFsbGJhY2tzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja1BsdWdpbiA9IG5ldyBQcmVjYWNoZUZhbGxiYWNrUGx1Z2luKHtcbiAgICAgICAgICAgICAgICAgICAgZmFsbGJhY2tVcmxzOiBmYWxsYmFja3MuZW50cmllcyxcbiAgICAgICAgICAgICAgICAgICAgc2Vyd2lzdDogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJ1bnRpbWVDYWNoaW5nLmZvckVhY2goKGNhY2hlRW50cnkpPT57XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZUVudHJ5LmhhbmRsZXIgaW5zdGFuY2VvZiBTdHJhdGVneSAmJiAhY2FjaGVFbnRyeS5oYW5kbGVyLnBsdWdpbnMuc29tZSgocGx1Z2luKT0+XCJoYW5kbGVyRGlkRXJyb3JcIiBpbiBwbHVnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUVudHJ5LmhhbmRsZXIucGx1Z2lucy5wdXNoKGZhbGxiYWNrUGx1Z2luKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBydW50aW1lQ2FjaGluZyl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckNhcHR1cmUoZW50cnkubWF0Y2hlciwgZW50cnkuaGFuZGxlciwgZW50cnkubWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzYWJsZURldkxvZ3MkMSkgZGlzYWJsZURldkxvZ3MoKTtcbiAgICB9XG4gICAgZ2V0IHByZWNhY2hlU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVjYWNoZVN0cmF0ZWd5O1xuICAgIH1cbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVzO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiaW5zdGFsbFwiLCB0aGlzLmhhbmRsZUluc3RhbGwpO1xuICAgICAgICBzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJhY3RpdmF0ZVwiLCB0aGlzLmhhbmRsZUFjdGl2YXRlKTtcbiAgICAgICAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwiZmV0Y2hcIiwgdGhpcy5oYW5kbGVGZXRjaCk7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5oYW5kbGVDYWNoZSk7XG4gICAgfVxuICAgIGFkZFRvUHJlY2FjaGVMaXN0KGVudHJpZXMpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzQXJyYXkoZW50cmllcywge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiYWRkVG9DYWNoZUxpc3RcIixcbiAgICAgICAgICAgICAgICBwYXJhbU5hbWU6IFwiZW50cmllc1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmxzVG9XYXJuQWJvdXQgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKXtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB1cmxzVG9XYXJuQWJvdXQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5ICYmICFlbnRyeS5pbnRlZ3JpdHkgJiYgZW50cnkucmV2aXNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVybHNUb1dhcm5BYm91dC5wdXNoKGVudHJ5LnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlS2V5LCB1cmwgfSA9IGNyZWF0ZUNhY2hlS2V5KGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlTW9kZSA9IHR5cGVvZiBlbnRyeSAhPT0gXCJzdHJpbmdcIiAmJiBlbnRyeS5yZXZpc2lvbiA/IFwicmVsb2FkXCIgOiBcImRlZmF1bHRcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLl91cmxzVG9DYWNoZUtleXMuaGFzKHVybCkgJiYgdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmwpICE9PSBjYWNoZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RFbnRyeTogdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmwpLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmRFbnRyeTogY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkgIT09IFwic3RyaW5nXCIgJiYgZW50cnkuaW50ZWdyaXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhY2hlS2V5c1RvSW50ZWdyaXRpZXMuaGFzKGNhY2hlS2V5KSAmJiB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmdldChjYWNoZUtleSkgIT09IGVudHJ5LmludGVncml0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctaW50ZWdyaXRpZXNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLnNldChjYWNoZUtleSwgZW50cnkuaW50ZWdyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3VybHNUb0NhY2hlS2V5cy5zZXQodXJsLCBjYWNoZUtleSk7XG4gICAgICAgICAgICB0aGlzLl91cmxzVG9DYWNoZU1vZGVzLnNldCh1cmwsIGNhY2hlTW9kZSk7XG4gICAgICAgICAgICBpZiAodXJsc1RvV2FybkFib3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXJuaW5nTWVzc2FnZSA9IGBTZXJ3aXN0IGlzIHByZWNhY2hpbmcgVVJMcyB3aXRob3V0IHJldmlzaW9uIGluZm86ICR7dXJsc1RvV2FybkFib3V0LmpvaW4oXCIsIFwiKX1cXG5UaGlzIGlzIGdlbmVyYWxseSBOT1Qgc2FmZS4gTGVhcm4gbW9yZSBhdCBodHRwczovL2JpdC5seS93Yi1wcmVjYWNoZWA7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKHdhcm5pbmdNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlSW5zdGFsbChldmVudCkge1xuICAgICAgICByZXR1cm4gd2FpdFVudGlsKGV2ZW50LCBhc3luYyAoKT0+e1xuICAgICAgICAgICAgY29uc3QgaW5zdGFsbFJlcG9ydFBsdWdpbiA9IG5ldyBQcmVjYWNoZUluc3RhbGxSZXBvcnRQbHVnaW4oKTtcbiAgICAgICAgICAgIHRoaXMucHJlY2FjaGVTdHJhdGVneS5wbHVnaW5zLnB1c2goaW5zdGFsbFJlcG9ydFBsdWdpbik7XG4gICAgICAgICAgICBhd2FpdCBwYXJhbGxlbCh0aGlzLl9jb25jdXJyZW50UHJlY2FjaGluZywgQXJyYXkuZnJvbSh0aGlzLl91cmxzVG9DYWNoZUtleXMuZW50cmllcygpKSwgYXN5bmMgKFt1cmwsIGNhY2hlS2V5XSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JpdHkgPSB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmdldChjYWNoZUtleSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVNb2RlID0gdGhpcy5fdXJsc1RvQ2FjaGVNb2Rlcy5nZXQodXJsKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncml0eSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGNhY2hlTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMucHJlY2FjaGVTdHJhdGVneS5oYW5kbGVBbGwoe1xuICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBuZXcgVVJMKHJlcXVlc3QudXJsKSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IHVwZGF0ZWRVUkxzLCBub3RVcGRhdGVkVVJMcyB9ID0gaW5zdGFsbFJlcG9ydFBsdWdpbjtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwcmludEluc3RhbGxEZXRhaWxzKHVwZGF0ZWRVUkxzLCBub3RVcGRhdGVkVVJMcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRVUkxzLFxuICAgICAgICAgICAgICAgIG5vdFVwZGF0ZWRVUkxzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlQWN0aXZhdGUoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHdhaXRVbnRpbChldmVudCwgYXN5bmMgKCk9PntcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlID0gYXdhaXQgc2VsZi5jYWNoZXMub3Blbih0aGlzLnByZWNhY2hlU3RyYXRlZ3kuY2FjaGVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRseUNhY2hlZFJlcXVlc3RzID0gYXdhaXQgY2FjaGUua2V5cygpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRDYWNoZUtleXMgPSBuZXcgU2V0KHRoaXMuX3VybHNUb0NhY2hlS2V5cy52YWx1ZXMoKSk7XG4gICAgICAgICAgICBjb25zdCBkZWxldGVkQ2FjaGVSZXF1ZXN0cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIGN1cnJlbnRseUNhY2hlZFJlcXVlc3RzKXtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGVjdGVkQ2FjaGVLZXlzLmhhcyhyZXF1ZXN0LnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2FjaGUuZGVsZXRlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVkQ2FjaGVSZXF1ZXN0cy5wdXNoKHJlcXVlc3QudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcHJpbnRDbGVhbnVwRGV0YWlscyhkZWxldGVkQ2FjaGVSZXF1ZXN0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWRDYWNoZVJlcXVlc3RzXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRmV0Y2goZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyByZXF1ZXN0IH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0gdGhpcy5oYW5kbGVSZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBldmVudFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgICAgICAgICAgZXZlbnQucmVzcG9uZFdpdGgocmVzcG9uc2VQcm9taXNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVDYWNoZShldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQuZGF0YSAmJiBldmVudC5kYXRhLnR5cGUgPT09IFwiQ0FDSEVfVVJMU1wiKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBheWxvYWQgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiQ2FjaGluZyBVUkxzIGZyb20gdGhlIHdpbmRvd1wiLCBwYXlsb2FkLnVybHNUb0NhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQcm9taXNlcyA9IFByb21pc2UuYWxsKHBheWxvYWQudXJsc1RvQ2FjaGUubWFwKChlbnRyeSk9PntcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChlbnRyeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KC4uLmVudHJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBldmVudC53YWl0VW50aWwocmVxdWVzdFByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb3J0cz8uWzBdKSB7XG4gICAgICAgICAgICAgICAgdm9pZCByZXF1ZXN0UHJvbWlzZXMudGhlbigoKT0+ZXZlbnQucG9ydHNbMF0ucG9zdE1lc3NhZ2UodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldERlZmF1bHRIYW5kbGVyKGhhbmRsZXIsIG1ldGhvZCA9IGRlZmF1bHRNZXRob2QpIHtcbiAgICAgICAgdGhpcy5fZGVmYXVsdEhhbmRsZXJNYXAuc2V0KG1ldGhvZCwgbm9ybWFsaXplSGFuZGxlcihoYW5kbGVyKSk7XG4gICAgfVxuICAgIHNldENhdGNoSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2NhdGNoSGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2FwdHVyZShjYXB0dXJlLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICAgICAgY29uc3Qgcm91dGUgPSBwYXJzZVJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG4gICAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9XG4gICAgcmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKHJvdXRlLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJvdXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmhhc01ldGhvZChyb3V0ZSwgXCJtYXRjaFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJvdXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShyb3V0ZS5oYW5kbGVyLCBcIm9iamVjdFwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJvdXRlXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmhhc01ldGhvZChyb3V0ZS5oYW5kbGVyLCBcImhhbmRsZVwiLCB7XG4gICAgICAgICAgICAgICAgbW9kdWxlTmFtZTogXCJzZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcIlNlcndpc3RcIixcbiAgICAgICAgICAgICAgICBmdW5jTmFtZTogXCJyZWdpc3RlclJvdXRlXCIsXG4gICAgICAgICAgICAgICAgcGFyYW1OYW1lOiBcInJvdXRlLmhhbmRsZXJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmaW5hbEFzc2VydEV4cG9ydHMuaXNUeXBlKHJvdXRlLm1ldGhvZCwgXCJzdHJpbmdcIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwicmVnaXN0ZXJSb3V0ZVwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJyb3V0ZS5tZXRob2RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXMuaGFzKHJvdXRlLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JvdXRlcy5zZXQocm91dGUubWV0aG9kLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm91dGVzLmdldChyb3V0ZS5tZXRob2QpLnB1c2gocm91dGUpO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yb3V0ZXMuaGFzKHJvdXRlLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJ1bnJlZ2lzdGVyLXJvdXRlLWJ1dC1ub3QtZm91bmQtd2l0aC1tZXRob2RcIiwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogcm91dGUubWV0aG9kXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3V0ZUluZGV4ID0gdGhpcy5fcm91dGVzLmdldChyb3V0ZS5tZXRob2QpLmluZGV4T2Yocm91dGUpO1xuICAgICAgICBpZiAocm91dGVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkuc3BsaWNlKHJvdXRlSW5kZXgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcInVucmVnaXN0ZXItcm91dGUtcm91dGUtbm90LXJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VXJsc1RvUHJlY2FjaGVLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsc1RvQ2FjaGVLZXlzO1xuICAgIH1cbiAgICBnZXRQcmVjYWNoZWRVcmxzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4udGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmtleXMoKVxuICAgICAgICBdO1xuICAgIH1cbiAgICBnZXRQcmVjYWNoZUtleUZvclVybCh1cmwpIHtcbiAgICAgICAgY29uc3QgdXJsT2JqZWN0ID0gbmV3IFVSTCh1cmwsIGxvY2F0aW9uLmhyZWYpO1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJsc1RvQ2FjaGVLZXlzLmdldCh1cmxPYmplY3QuaHJlZik7XG4gICAgfVxuICAgIGdldEludGVncml0eUZvclByZWNhY2hlS2V5KGNhY2hlS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUtleXNUb0ludGVncml0aWVzLmdldChjYWNoZUtleSk7XG4gICAgfVxuICAgIGFzeW5jIG1hdGNoUHJlY2FjaGUocmVxdWVzdCkge1xuICAgICAgICBjb25zdCB1cmwgPSByZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IHJlcXVlc3QudXJsIDogcmVxdWVzdDtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldFByZWNhY2hlS2V5Rm9yVXJsKHVybCk7XG4gICAgICAgIGlmIChjYWNoZUtleSkge1xuICAgICAgICAgICAgY29uc3QgY2FjaGUgPSBhd2FpdCBzZWxmLmNhY2hlcy5vcGVuKHRoaXMucHJlY2FjaGVTdHJhdGVneS5jYWNoZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlLm1hdGNoKGNhY2hlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjcmVhdGVIYW5kbGVyQm91bmRUb1VybCh1cmwpIHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldFByZWNhY2hlS2V5Rm9yVXJsKHVybCk7XG4gICAgICAgIGlmICghY2FjaGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJub24tcHJlY2FjaGVkLXVybFwiLCB7XG4gICAgICAgICAgICAgICAgdXJsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG9wdGlvbnMpPT57XG4gICAgICAgICAgICBvcHRpb25zLnJlcXVlc3QgPSBuZXcgUmVxdWVzdCh1cmwpO1xuICAgICAgICAgICAgb3B0aW9ucy5wYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5wYXJhbXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmVjYWNoZVN0cmF0ZWd5LmhhbmRsZShvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFuZGxlUmVxdWVzdCh7IHJlcXVlc3QsIGV2ZW50IH0pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzSW5zdGFuY2UocmVxdWVzdCwgUmVxdWVzdCwge1xuICAgICAgICAgICAgICAgIG1vZHVsZU5hbWU6IFwic2Vyd2lzdFwiLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJTZXJ3aXN0XCIsXG4gICAgICAgICAgICAgICAgZnVuY05hbWU6IFwiaGFuZGxlUmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIHBhcmFtTmFtZTogXCJvcHRpb25zLnJlcXVlc3RcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCwgbG9jYXRpb24uaHJlZik7XG4gICAgICAgIGlmICghdXJsLnByb3RvY29sLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFwiUm91dGVyIG9ubHkgc3VwcG9ydHMgVVJMcyB0aGF0IHN0YXJ0IHdpdGggJ2h0dHAnLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1lT3JpZ2luID0gdXJsLm9yaWdpbiA9PT0gbG9jYXRpb24ub3JpZ2luO1xuICAgICAgICBjb25zdCB7IHBhcmFtcywgcm91dGUgfSA9IHRoaXMuZmluZE1hdGNoaW5nUm91dGUoe1xuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgc2FtZU9yaWdpbixcbiAgICAgICAgICAgIHVybFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSByb3V0ZT8uaGFuZGxlcjtcbiAgICAgICAgY29uc3QgZGVidWdNZXNzYWdlcyA9IFtdO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgIFwiRm91bmQgYSByb3V0ZSB0byBoYW5kbGUgdGhpcyByZXF1ZXN0OlwiLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBQYXNzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1zIHRvIHRoZSByb3V0ZSdzIGhhbmRsZXI6YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgICAgIGlmICghaGFuZGxlciAmJiB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5oYXMobWV0aG9kKSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGRlYnVnTWVzc2FnZXMucHVzaChgRmFpbGVkIHRvIGZpbmQgYSBtYXRjaGluZyByb3V0ZS4gRmFsbGluZyBiYWNrIHRvIHRoZSBkZWZhdWx0IGhhbmRsZXIgZm9yICR7bWV0aG9kfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9kZWZhdWx0SGFuZGxlck1hcC5nZXQobWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoYE5vIHJvdXRlIGZvdW5kIGZvcjogJHtnZXRGcmllbmRseVVSTCh1cmwpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUm91dGVyIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbXNnIG9mIGRlYnVnTWVzc2FnZXMpe1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmxvZyguLi5tc2cpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gaGFuZGxlci5oYW5kbGUoe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXRjaEhhbmRsZXIgPSByb3V0ZT8uY2F0Y2hIYW5kbGVyO1xuICAgICAgICBpZiAocmVzcG9uc2VQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSAmJiAodGhpcy5fY2F0Y2hIYW5kbGVyIHx8IGNhdGNoSGFuZGxlcikpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZSA9IHJlc3BvbnNlUHJvbWlzZS5jYXRjaChhc3luYyAoZXJyKT0+e1xuICAgICAgICAgICAgICAgIGlmIChjYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIHJvdXRlJ3MgQ2F0Y2ggSGFuZGxlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihcIkVycm9yIHRocm93biBieTpcIiwgcm91dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGNhdGNoSGFuZGxlci5oYW5kbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGNhdGNoRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2F0Y2hFcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyciA9IGNhdGNoRXJyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXRjaEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIGdsb2JhbCBDYXRjaCBIYW5kbGVyLmApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKFwiRXJyb3IgdGhyb3duIGJ5OlwiLCByb3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYXRjaEhhbmRsZXIuaGFuZGxlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9XG4gICAgZmluZE1hdGNoaW5nUm91dGUoeyB1cmwsIHNhbWVPcmlnaW4sIHJlcXVlc3QsIGV2ZW50IH0pIHtcbiAgICAgICAgY29uc3Qgcm91dGVzID0gdGhpcy5fcm91dGVzLmdldChyZXF1ZXN0Lm1ldGhvZCkgfHwgW107XG4gICAgICAgIGZvciAoY29uc3Qgcm91dGUgb2Ygcm91dGVzKXtcbiAgICAgICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgICAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHJvdXRlLm1hdGNoKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgc2FtZU9yaWdpbixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFdoaWxlIHJvdXRpbmcgJHtnZXRGcmllbmRseVVSTCh1cmwpfSwgYW4gYXN5bmMgbWF0Y2hDYWxsYmFjayBmdW5jdGlvbiB3YXMgdXNlZC4gUGxlYXNlIGNvbnZlcnQgdGhlIGZvbGxvd2luZyByb3V0ZSB0byB1c2UgYSBzeW5jaHJvbm91cyBtYXRjaENhbGxiYWNrIGZ1bmN0aW9uOmAsIHJvdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBtYXRjaFJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpICYmIHBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hSZXN1bHQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3Qua2V5cyhtYXRjaFJlc3VsdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaFJlc3VsdCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge307XG4gICAgfVxufVxuXG5leHBvcnQgeyBOYXZpZ2F0aW9uUm91dGUgYXMgTiwgUHJlY2FjaGVSb3V0ZSBhcyBQLCBSZWdFeHBSb3V0ZSBhcyBSLCBTZXJ3aXN0IGFzIFMsIGNsaWVudHNDbGFpbSBhcyBhLCBjb3B5UmVzcG9uc2UgYXMgYiwgY2xlYW51cE91dGRhdGVkQ2FjaGVzIGFzIGMsIGRpc2FibGVEZXZMb2dzIGFzIGQsIGRpc2FibGVOYXZpZ2F0aW9uUHJlbG9hZCBhcyBlLCBlbmFibGVOYXZpZ2F0aW9uUHJlbG9hZCBhcyBmLCBQcmVjYWNoZVN0cmF0ZWd5IGFzIGcsIGNyZWF0ZUNhY2hlS2V5IGFzIGgsIGlzTmF2aWdhdGlvblByZWxvYWRTdXBwb3J0ZWQgYXMgaSwgcGFyYWxsZWwgYXMgaiwgcHJpbnRJbnN0YWxsRGV0YWlscyBhcyBrLCBwcmludENsZWFudXBEZXRhaWxzIGFzIGwsIFByZWNhY2hlSW5zdGFsbFJlcG9ydFBsdWdpbiBhcyBtLCBnZW5lcmF0ZVVSTFZhcmlhdGlvbnMgYXMgbiwgcGFyc2VSb3V0ZSBhcyBwLCBzZXRDYWNoZU5hbWVEZXRhaWxzIGFzIHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/Serwist.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/registerQuotaErrorCallback.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/registerQuotaErrorCallback.js ***!
  \*************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   r: function() { return /* binding */ registerQuotaErrorCallback; }\n/* harmony export */ });\n/* harmony import */ var _timeout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./timeout.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js\");\n\n\nconst registerQuotaErrorCallback = (callback)=>{\n    if (true) {\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.f.isType(callback, \"function\", {\n            moduleName: \"@serwist/core\",\n            funcName: \"register\",\n            paramName: \"callback\"\n        });\n    }\n    _timeout_js__WEBPACK_IMPORTED_MODULE_0__.q.add(callback);\n    if (true) {\n        _timeout_js__WEBPACK_IMPORTED_MODULE_0__.l.log(\"Registered a callback to respond to quota errors.\", callback);\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvcmVnaXN0ZXJRdW90YUVycm9yQ2FsbGJhY2suanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBOEY7O0FBRTlGO0FBQ0EsUUFBUSxJQUFxQztBQUM3QyxRQUFRLDBDQUFrQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxJQUFJLDBDQUFtQjtBQUN2QixRQUFRLElBQXFDO0FBQzdDLFFBQVEsMENBQU07QUFDZDtBQUNBOztBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvcmVnaXN0ZXJRdW90YUVycm9yQ2FsbGJhY2suanM/ODlhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmIGFzIGZpbmFsQXNzZXJ0RXhwb3J0cywgcSBhcyBxdW90YUVycm9yQ2FsbGJhY2tzLCBsIGFzIGxvZ2dlciB9IGZyb20gJy4vdGltZW91dC5qcyc7XG5cbmNvbnN0IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrID0gKGNhbGxiYWNrKT0+e1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgZmluYWxBc3NlcnRFeHBvcnRzLmlzVHlwZShjYWxsYmFjaywgXCJmdW5jdGlvblwiLCB7XG4gICAgICAgICAgICBtb2R1bGVOYW1lOiBcIkBzZXJ3aXN0L2NvcmVcIixcbiAgICAgICAgICAgIGZ1bmNOYW1lOiBcInJlZ2lzdGVyXCIsXG4gICAgICAgICAgICBwYXJhbU5hbWU6IFwiY2FsbGJhY2tcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcXVvdGFFcnJvckNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgbG9nZ2VyLmxvZyhcIlJlZ2lzdGVyZWQgYSBjYWxsYmFjayB0byByZXNwb25kIHRvIHF1b3RhIGVycm9ycy5cIiwgY2FsbGJhY2spO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHJlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrIGFzIHIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/registerQuotaErrorCallback.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js ***!
  \******************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   D: function() { return /* binding */ Deferred; },\n/* harmony export */   S: function() { return /* binding */ SerwistError; },\n/* harmony export */   a: function() { return /* binding */ cacheMatchIgnoreParams; },\n/* harmony export */   c: function() { return /* binding */ cacheNames; },\n/* harmony export */   e: function() { return /* binding */ executeQuotaErrorCallbacks; },\n/* harmony export */   f: function() { return /* binding */ finalAssertExports; },\n/* harmony export */   g: function() { return /* binding */ getFriendlyURL; },\n/* harmony export */   l: function() { return /* binding */ logger; },\n/* harmony export */   q: function() { return /* binding */ quotaErrorCallbacks; },\n/* harmony export */   t: function() { return /* binding */ timeout; }\n/* harmony export */ });\nconst _cacheNameDetails = {\n    googleAnalytics: \"googleAnalytics\",\n    precache: \"precache-v2\",\n    prefix: \"serwist\",\n    runtime: \"runtime\",\n    suffix: typeof registration !== \"undefined\" ? registration.scope : \"\"\n};\nconst _createCacheName = (cacheName)=>{\n    return [\n        _cacheNameDetails.prefix,\n        cacheName,\n        _cacheNameDetails.suffix\n    ].filter((value)=>value && value.length > 0).join(\"-\");\n};\nconst eachCacheNameDetail = (fn)=>{\n    for (const key of Object.keys(_cacheNameDetails)){\n        fn(key);\n    }\n};\nconst cacheNames = {\n    updateDetails: (details)=>{\n        eachCacheNameDetail((key)=>{\n            const detail = details[key];\n            if (typeof detail === \"string\") {\n                _cacheNameDetails[key] = detail;\n            }\n        });\n    },\n    getGoogleAnalyticsName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getPrefix: ()=>{\n        return _cacheNameDetails.prefix;\n    },\n    getRuntimeName: (userCacheName)=>{\n        return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    },\n    getSuffix: ()=>{\n        return _cacheNameDetails.suffix;\n    }\n};\n\nconst logger =  false ? 0 : (()=>{\n    if (!(\"__WB_DISABLE_DEV_LOGS\" in globalThis)) {\n        self.__WB_DISABLE_DEV_LOGS = false;\n    }\n    let inGroup = false;\n    const methodToColorMap = {\n        debug: \"#7f8c8d\",\n        log: \"#2ecc71\",\n        warn: \"#f39c12\",\n        error: \"#c0392b\",\n        groupCollapsed: \"#3498db\",\n        groupEnd: null\n    };\n    const print = (method, args)=>{\n        if (self.__WB_DISABLE_DEV_LOGS) {\n            return;\n        }\n        if (method === \"groupCollapsed\") {\n            if (typeof navigator !== \"undefined\" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n                console[method](...args);\n                return;\n            }\n        }\n        const styles = [\n            `background: ${methodToColorMap[method]}`,\n            \"border-radius: 0.5em\",\n            \"color: white\",\n            \"font-weight: bold\",\n            \"padding: 2px 0.5em\"\n        ];\n        const logPrefix = inGroup ? [] : [\n            \"%cserwist\",\n            styles.join(\";\")\n        ];\n        console[method](...logPrefix, ...args);\n        if (method === \"groupCollapsed\") {\n            inGroup = true;\n        }\n        if (method === \"groupEnd\") {\n            inGroup = false;\n        }\n    };\n    const loggerMethods = Object.keys(methodToColorMap);\n    return loggerMethods.reduce((api, method)=>{\n        api[method] = (...args)=>{\n            print(method, args);\n        };\n        return api;\n    }, {});\n})();\n\nconst messages = {\n    \"invalid-value\": ({ paramName, validValueDescription, value })=>{\n        if (!paramName || !validValueDescription) {\n            throw new Error(`Unexpected input to 'invalid-value' error.`);\n        }\n        return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n    },\n    \"not-an-array\": ({ moduleName, className, funcName, paramName })=>{\n        if (!moduleName || !className || !funcName || !paramName) {\n            throw new Error(`Unexpected input to 'not-an-array' error.`);\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n    },\n    \"incorrect-type\": ({ expectedType, paramName, moduleName, className, funcName })=>{\n        if (!expectedType || !paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-type' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}` + `${funcName}()' must be of type ${expectedType}.`;\n    },\n    \"incorrect-class\": ({ expectedClassName, paramName, moduleName, className, funcName, isReturnValueProblem })=>{\n        if (!expectedClassName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'incorrect-class' error.`);\n        }\n        const classNameStr = className ? `${className}.` : \"\";\n        if (isReturnValueProblem) {\n            return `The return value from '${moduleName}.${classNameStr}${funcName}()' must be an instance of class ${expectedClassName}.`;\n        }\n        return `The parameter '${paramName}' passed into ` + `'${moduleName}.${classNameStr}${funcName}()' ` + `must be an instance of class ${expectedClassName}.`;\n    },\n    \"missing-a-method\": ({ expectedMethod, paramName, moduleName, className, funcName })=>{\n        if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n            throw new Error(`Unexpected input to 'missing-a-method' error.`);\n        }\n        return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n    },\n    \"add-to-cache-list-unexpected-type\": ({ entry })=>{\n        return `An unexpected entry was passed to 'serwist.Serwist.addToPrecacheList()' The entry '${JSON.stringify(entry)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`;\n    },\n    \"add-to-cache-list-conflicting-entries\": ({ firstEntry, secondEntry })=>{\n        if (!firstEntry || !secondEntry) {\n            throw new Error(\"Unexpected input to \" + `'add-to-cache-list-duplicate-entries' error.`);\n        }\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${firstEntry} but different revision details. Serwist is unable to cache and version the asset correctly. Please remove one of the entries.`;\n    },\n    \"plugin-error-request-will-fetch\": ({ thrownErrorMessage })=>{\n        if (!thrownErrorMessage) {\n            throw new Error(\"Unexpected input to \" + `'plugin-error-request-will-fetch', error.`);\n        }\n        return `An error was thrown by a plugin's 'requestWillFetch()' method. The thrown error message was: '${thrownErrorMessage}'.`;\n    },\n    \"invalid-cache-name\": ({ cacheNameId, value })=>{\n        if (!cacheNameId) {\n            throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n        }\n        return `You must provide a name containing at least one character for setCacheDetails({${cacheNameId}: '...'}). Received a value of '${JSON.stringify(value)}'`;\n    },\n    \"unregister-route-but-not-found-with-method\": ({ method })=>{\n        if (!method) {\n            throw new Error(\"Unexpected input to \" + `'unregister-route-but-not-found-with-method' error.`);\n        }\n        return `The route you're trying to unregister was not  previously registered for the method type '${method}'.`;\n    },\n    \"unregister-route-route-not-registered\": ()=>{\n        return `The route you're trying to unregister was not previously ` + \"registered.\";\n    },\n    \"queue-replay-failed\": ({ name })=>{\n        return `Replaying the background sync queue '${name}' failed.`;\n    },\n    \"duplicate-queue-name\": ({ name })=>{\n        return `The Queue name '${name}' is already being used. All instances of backgroundSync.Queue must be given unique names.`;\n    },\n    \"expired-test-without-max-age\": ({ methodName, paramName })=>{\n        return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n    },\n    \"unsupported-route-type\": ({ moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter was an unsupported type. Please check the docs for ${moduleName}.${className}.${funcName} for valid input types.`;\n    },\n    \"not-array-of-class\": ({ value, expectedClass, moduleName, className, funcName, paramName })=>{\n        return `The supplied '${paramName}' parameter must be an array of '${expectedClass}' objects. Received '${JSON.stringify(value)},'. Please check the call to ${moduleName}.${className}.${funcName}() to fix the issue.`;\n    },\n    \"max-entries-or-age-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.maxEntries' or 'config.maxAgeSeconds' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"statuses-or-headers-required\": ({ moduleName, className, funcName })=>{\n        return `You must define either 'config.statuses' or 'config.headers' in '${moduleName}.${className}.${funcName}'`;\n    },\n    \"invalid-string\": ({ moduleName, funcName, paramName })=>{\n        if (!paramName || !moduleName || !funcName) {\n            throw new Error(`Unexpected input to 'invalid-string' error.`);\n        }\n        return `When using strings, the '${paramName}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${moduleName}.${funcName}() for more info.`;\n    },\n    \"channel-name-required\": ()=>{\n        return \"You must provide a channelName to construct a \" + \"BroadcastCacheUpdate instance.\";\n    },\n    \"invalid-responses-are-same-args\": ()=>{\n        return \"The arguments passed into responsesAreSame() appear to be \" + \"invalid. Please ensure valid Responses are used.\";\n    },\n    \"expire-custom-caches-only\": ()=>{\n        return `You must provide a 'cacheName' property when using the ` + \"expiration plugin with a runtime caching strategy.\";\n    },\n    \"unit-must-be-bytes\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n        }\n        return `The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"single-range-only\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'single-range-only' error.`);\n        }\n        return `Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"invalid-range-values\": ({ normalizedRangeHeader })=>{\n        if (!normalizedRangeHeader) {\n            throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n        }\n        return `The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    \"no-range-header\": ()=>{\n        return \"No Range header was found in the Request provided.\";\n    },\n    \"range-not-satisfiable\": ({ size, start, end })=>{\n        return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n    },\n    \"attempt-to-cache-non-get-request\": ({ url, method })=>{\n        return `Unable to cache '${url}' because it is a '${method}' request and only 'GET' requests can be cached.`;\n    },\n    \"cache-put-with-no-response\": ({ url })=>{\n        return `There was an attempt to cache '${url}' but the response was not defined.`;\n    },\n    \"no-response\": ({ url, error })=>{\n        let message = `The strategy could not generate a response for '${url}'.`;\n        if (error) {\n            message += ` The underlying error is ${error}.`;\n        }\n        return message;\n    },\n    \"bad-precaching-response\": ({ url, status })=>{\n        return `The precaching request for '${url}' failed${status ? ` with an HTTP status of ${status}.` : \".\"}`;\n    },\n    \"non-precached-url\": ({ url })=>{\n        return `'createHandlerBoundToURL(\"${url}\")' was called, but that URL is not precached. Please pass in a URL that is precached instead.`;\n    },\n    \"add-to-cache-list-conflicting-integrities\": ({ url })=>{\n        return `Two of the entries passed to 'serwist.Serwist.addToPrecacheList()' had the URL ${url} with different integrity values. Please remove one of them.`;\n    },\n    \"missing-precache-entry\": ({ cacheName, url })=>{\n        return `Unable to find a precached response in ${cacheName} for ${url}.`;\n    },\n    \"cross-origin-copy-response\": ({ origin })=>{\n        return `'@serwist/core.copyResponse()' can only be used with same-origin responses. It was passed a response with origin ${origin}.`;\n    },\n    \"opaque-streams-source\": ({ type })=>{\n        const message = `One of the '@serwist/streams' sources resulted in an '${type}' response.`;\n        if (type === \"opaqueredirect\") {\n            return `${message} Please do not use a navigation request that results in a redirect as a source.`;\n        }\n        return `${message} Please ensure your sources are CORS-enabled.`;\n    }\n};\n\nconst fallback = (code, ...args)=>{\n    let msg = code;\n    if (args.length > 0) {\n        msg += ` :: ${JSON.stringify(args)}`;\n    }\n    return msg;\n};\nconst generatorFunction = (code, details = {})=>{\n    const message = messages[code];\n    if (!message) {\n        throw new Error(`Unable to find message for code '${code}'.`);\n    }\n    return message(details);\n};\nconst messageGenerator =  false ? 0 : generatorFunction;\n\nclass SerwistError extends Error {\n    details;\n    constructor(errorCode, details){\n        const message = messageGenerator(errorCode, details);\n        super(message);\n        this.name = errorCode;\n        this.details = details;\n    }\n}\n\nconst isArray = (value, details)=>{\n    if (!Array.isArray(value)) {\n        throw new SerwistError(\"not-an-array\", details);\n    }\n};\nconst hasMethod = (object, expectedMethod, details)=>{\n    const type = typeof object[expectedMethod];\n    if (type !== \"function\") {\n        details.expectedMethod = expectedMethod;\n        throw new SerwistError(\"missing-a-method\", details);\n    }\n};\nconst isType = (object, expectedType, details)=>{\n    if (typeof object !== expectedType) {\n        details.expectedType = expectedType;\n        throw new SerwistError(\"incorrect-type\", details);\n    }\n};\nconst isInstance = (object, expectedClass, details)=>{\n    if (!(object instanceof expectedClass)) {\n        details.expectedClassName = expectedClass.name;\n        throw new SerwistError(\"incorrect-class\", details);\n    }\n};\nconst isOneOf = (value, validValues, details)=>{\n    if (!validValues.includes(value)) {\n        details.validValueDescription = `Valid values are ${JSON.stringify(validValues)}.`;\n        throw new SerwistError(\"invalid-value\", details);\n    }\n};\nconst isArrayOfClass = (value, expectedClass, details)=>{\n    const error = new SerwistError(\"not-array-of-class\", details);\n    if (!Array.isArray(value)) {\n        throw error;\n    }\n    for (const item of value){\n        if (!(item instanceof expectedClass)) {\n            throw error;\n        }\n    }\n};\nconst finalAssertExports =  false ? 0 : {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isType,\n    isArrayOfClass\n};\n\nconst getFriendlyURL = (url)=>{\n    const urlObj = new URL(String(url), location.href);\n    return urlObj.href.replace(new RegExp(`^${location.origin}`), \"\");\n};\n\nclass Deferred {\n    promise;\n    resolve;\n    reject;\n    constructor(){\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\n\nfunction stripParams(fullURL, ignoreParams) {\n    const strippedURL = new URL(fullURL);\n    for (const param of ignoreParams){\n        strippedURL.searchParams.delete(param);\n    }\n    return strippedURL.href;\n}\nasync function cacheMatchIgnoreParams(cache, request, ignoreParams, matchOptions) {\n    const strippedRequestURL = stripParams(request.url, ignoreParams);\n    if (request.url === strippedRequestURL) {\n        return cache.match(request, matchOptions);\n    }\n    const keysOptions = {\n        ...matchOptions,\n        ignoreSearch: true\n    };\n    const cacheKeys = await cache.keys(request, keysOptions);\n    for (const cacheKey of cacheKeys){\n        const strippedCacheKeyURL = stripParams(cacheKey.url, ignoreParams);\n        if (strippedRequestURL === strippedCacheKeyURL) {\n            return cache.match(cacheKey, matchOptions);\n        }\n    }\n    return;\n}\n\nconst quotaErrorCallbacks = new Set();\n\nconst executeQuotaErrorCallbacks = async ()=>{\n    if (true) {\n        logger.log(`About to run ${quotaErrorCallbacks.size} callbacks to clean up caches.`);\n    }\n    for (const callback of quotaErrorCallbacks){\n        await callback();\n        if (true) {\n            logger.log(callback, \"is complete.\");\n        }\n    }\n    if (true) {\n        logger.log(\"Finished running callbacks.\");\n    }\n};\n\nfunction timeout(ms) {\n    return new Promise((resolve)=>setTimeout(resolve, ms));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvdGltZW91dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLE1BQXFDLEdBQUcsQ0FBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVCxDQUFDOztBQUVEO0FBQ0Esd0JBQXdCLHlDQUF5QztBQUNqRTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSwrREFBK0QsdUJBQXVCLDJCQUEyQixzQkFBc0I7QUFDeEssS0FBSztBQUNMLHVCQUF1Qiw0Q0FBNEM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVUsc0JBQXNCLFdBQVcsR0FBRyxVQUFVLEdBQUcsU0FBUztBQUNyRyxLQUFLO0FBQ0wseUJBQXlCLDBEQUEwRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RCxpQ0FBaUMsVUFBVSxzQkFBc0IsV0FBVyxHQUFHLGFBQWEsT0FBTyxTQUFTLHNCQUFzQixhQUFhO0FBQy9JLEtBQUs7QUFDTCwwQkFBMEIscUZBQXFGO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0EsNkNBQTZDLFdBQVcsR0FBRyxhQUFhLEVBQUUsU0FBUyxtQ0FBbUMsa0JBQWtCO0FBQ3hJO0FBQ0EsaUNBQWlDLFVBQVUsc0JBQXNCLFdBQVcsR0FBRyxhQUFhLEVBQUUsU0FBUyx3Q0FBd0Msa0JBQWtCO0FBQ2pLLEtBQUs7QUFDTCwyQkFBMkIsNERBQTREO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXLEdBQUcsVUFBVSxHQUFHLFNBQVMsd0JBQXdCLFVBQVUsMkJBQTJCLGVBQWU7QUFDbEksS0FBSztBQUNMLDRDQUE0QyxPQUFPO0FBQ25ELHFHQUFxRyxzQkFBc0I7QUFDM0gsS0FBSztBQUNMLGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLFlBQVk7QUFDN0csS0FBSztBQUNMLDBDQUEwQyxvQkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILG1CQUFtQjtBQUNuSSxLQUFLO0FBQ0wsNkJBQTZCLG9CQUFvQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsRUFBRSxZQUFZLFFBQVEsMEJBQTBCLHNCQUFzQjtBQUNySyxLQUFLO0FBQ0wscURBQXFELFFBQVE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsNEdBQTRHLE9BQU87QUFDbkgsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLE1BQU07QUFDcEMsdURBQXVELEtBQUs7QUFDNUQsS0FBSztBQUNMLCtCQUErQixNQUFNO0FBQ3JDLGtDQUFrQyxLQUFLO0FBQ3ZDLEtBQUs7QUFDTCx1Q0FBdUMsdUJBQXVCO0FBQzlELHVCQUF1QixXQUFXLDZDQUE2QyxVQUFVO0FBQ3pGLEtBQUs7QUFDTCxpQ0FBaUMsNENBQTRDO0FBQzdFLGdDQUFnQyxVQUFVLGlFQUFpRSxXQUFXLEdBQUcsVUFBVSxHQUFHLFVBQVU7QUFDaEosS0FBSztBQUNMLDZCQUE2QixrRUFBa0U7QUFDL0YsZ0NBQWdDLFVBQVUsbUNBQW1DLGNBQWMsdUJBQXVCLHNCQUFzQiwrQkFBK0IsV0FBVyxHQUFHLFVBQVUsR0FBRyxTQUFTO0FBQzNNLEtBQUs7QUFDTCxzQ0FBc0MsaUNBQWlDO0FBQ3ZFLDJGQUEyRixXQUFXLEdBQUcsVUFBVSxHQUFHLFNBQVM7QUFDL0gsS0FBSztBQUNMLHVDQUF1QyxpQ0FBaUM7QUFDeEUsbUZBQW1GLFdBQVcsR0FBRyxVQUFVLEdBQUcsU0FBUztBQUN2SCxLQUFLO0FBQ0wseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVSwwSEFBMEgsV0FBVyxHQUFHLFNBQVM7QUFDdE0sS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsZ0hBQWdILHNCQUFzQjtBQUN0SSxLQUFLO0FBQ0wsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSw4SUFBOEksc0JBQXNCO0FBQ3BLLEtBQUs7QUFDTCwrQkFBK0IsdUJBQXVCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSixzQkFBc0I7QUFDdEssS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLGtCQUFrQjtBQUNsRCw2QkFBNkIsTUFBTSxhQUFhLElBQUksa0ZBQWtGLE1BQU07QUFDNUksS0FBSztBQUNMLDJDQUEyQyxhQUFhO0FBQ3hELG1DQUFtQyxJQUFJLHFCQUFxQixPQUFPO0FBQ25FLEtBQUs7QUFDTCxxQ0FBcUMsS0FBSztBQUMxQyxpREFBaUQsSUFBSTtBQUNyRCxLQUFLO0FBQ0wsc0JBQXNCLFlBQVk7QUFDbEMseUVBQXlFLElBQUk7QUFDN0U7QUFDQSxtREFBbUQsTUFBTTtBQUN6RDtBQUNBO0FBQ0EsS0FBSztBQUNMLGtDQUFrQyxhQUFhO0FBQy9DLDhDQUE4QyxJQUFJLFVBQVUsb0NBQW9DLE9BQU8sU0FBUztBQUNoSCxLQUFLO0FBQ0wsNEJBQTRCLEtBQUs7QUFDakMsNENBQTRDLElBQUk7QUFDaEQsS0FBSztBQUNMLG9EQUFvRCxLQUFLO0FBQ3pELGlHQUFpRyxLQUFLO0FBQ3RHLEtBQUs7QUFDTCxpQ0FBaUMsZ0JBQWdCO0FBQ2pELHlEQUF5RCxXQUFXLE1BQU0sSUFBSTtBQUM5RSxLQUFLO0FBQ0wscUNBQXFDLFFBQVE7QUFDN0MsbUlBQW1JLE9BQU87QUFDMUksS0FBSztBQUNMLGdDQUFnQyxNQUFNO0FBQ3RDLGlGQUFpRixLQUFLO0FBQ3RGO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBcUMsR0FBRyxDQUFROztBQUV6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCw0QkFBNEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFxQyxHQUFHLENBQUk7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QyxtQ0FBbUMsMEJBQTBCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUU4TiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3MvdGltZW91dC5qcz9mYjE1Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF9jYWNoZU5hbWVEZXRhaWxzID0ge1xuICAgIGdvb2dsZUFuYWx5dGljczogXCJnb29nbGVBbmFseXRpY3NcIixcbiAgICBwcmVjYWNoZTogXCJwcmVjYWNoZS12MlwiLFxuICAgIHByZWZpeDogXCJzZXJ3aXN0XCIsXG4gICAgcnVudGltZTogXCJydW50aW1lXCIsXG4gICAgc3VmZml4OiB0eXBlb2YgcmVnaXN0cmF0aW9uICE9PSBcInVuZGVmaW5lZFwiID8gcmVnaXN0cmF0aW9uLnNjb3BlIDogXCJcIlxufTtcbmNvbnN0IF9jcmVhdGVDYWNoZU5hbWUgPSAoY2FjaGVOYW1lKT0+e1xuICAgIHJldHVybiBbXG4gICAgICAgIF9jYWNoZU5hbWVEZXRhaWxzLnByZWZpeCxcbiAgICAgICAgY2FjaGVOYW1lLFxuICAgICAgICBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXhcbiAgICBdLmZpbHRlcigodmFsdWUpPT52YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAwKS5qb2luKFwiLVwiKTtcbn07XG5jb25zdCBlYWNoQ2FjaGVOYW1lRGV0YWlsID0gKGZuKT0+e1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKF9jYWNoZU5hbWVEZXRhaWxzKSl7XG4gICAgICAgIGZuKGtleSk7XG4gICAgfVxufTtcbmNvbnN0IGNhY2hlTmFtZXMgPSB7XG4gICAgdXBkYXRlRGV0YWlsczogKGRldGFpbHMpPT57XG4gICAgICAgIGVhY2hDYWNoZU5hbWVEZXRhaWwoKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IGRldGFpbCA9IGRldGFpbHNba2V5XTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgX2NhY2hlTmFtZURldGFpbHNba2V5XSA9IGRldGFpbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXRHb29nbGVBbmFseXRpY3NOYW1lOiAodXNlckNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5nb29nbGVBbmFseXRpY3MpO1xuICAgIH0sXG4gICAgZ2V0UHJlY2FjaGVOYW1lOiAodXNlckNhY2hlTmFtZSk9PntcbiAgICAgICAgcmV0dXJuIHVzZXJDYWNoZU5hbWUgfHwgX2NyZWF0ZUNhY2hlTmFtZShfY2FjaGVOYW1lRGV0YWlscy5wcmVjYWNoZSk7XG4gICAgfSxcbiAgICBnZXRQcmVmaXg6ICgpPT57XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5wcmVmaXg7XG4gICAgfSxcbiAgICBnZXRSdW50aW1lTmFtZTogKHVzZXJDYWNoZU5hbWUpPT57XG4gICAgICAgIHJldHVybiB1c2VyQ2FjaGVOYW1lIHx8IF9jcmVhdGVDYWNoZU5hbWUoX2NhY2hlTmFtZURldGFpbHMucnVudGltZSk7XG4gICAgfSxcbiAgICBnZXRTdWZmaXg6ICgpPT57XG4gICAgICAgIHJldHVybiBfY2FjaGVOYW1lRGV0YWlscy5zdWZmaXg7XG4gICAgfVxufTtcblxuY29uc3QgbG9nZ2VyID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbnVsbCA6ICgoKT0+e1xuICAgIGlmICghKFwiX19XQl9ESVNBQkxFX0RFVl9MT0dTXCIgaW4gZ2xvYmFsVGhpcykpIHtcbiAgICAgICAgc2VsZi5fX1dCX0RJU0FCTEVfREVWX0xPR1MgPSBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGluR3JvdXAgPSBmYWxzZTtcbiAgICBjb25zdCBtZXRob2RUb0NvbG9yTWFwID0ge1xuICAgICAgICBkZWJ1ZzogXCIjN2Y4YzhkXCIsXG4gICAgICAgIGxvZzogXCIjMmVjYzcxXCIsXG4gICAgICAgIHdhcm46IFwiI2YzOWMxMlwiLFxuICAgICAgICBlcnJvcjogXCIjYzAzOTJiXCIsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBcIiMzNDk4ZGJcIixcbiAgICAgICAgZ3JvdXBFbmQ6IG51bGxcbiAgICB9O1xuICAgIGNvbnN0IHByaW50ID0gKG1ldGhvZCwgYXJncyk9PntcbiAgICAgICAgaWYgKHNlbGYuX19XQl9ESVNBQkxFX0RFVl9MT0dTKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJncm91cENvbGxhcHNlZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZVttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZXMgPSBbXG4gICAgICAgICAgICBgYmFja2dyb3VuZDogJHttZXRob2RUb0NvbG9yTWFwW21ldGhvZF19YCxcbiAgICAgICAgICAgIFwiYm9yZGVyLXJhZGl1czogMC41ZW1cIixcbiAgICAgICAgICAgIFwiY29sb3I6IHdoaXRlXCIsXG4gICAgICAgICAgICBcImZvbnQtd2VpZ2h0OiBib2xkXCIsXG4gICAgICAgICAgICBcInBhZGRpbmc6IDJweCAwLjVlbVwiXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxvZ1ByZWZpeCA9IGluR3JvdXAgPyBbXSA6IFtcbiAgICAgICAgICAgIFwiJWNzZXJ3aXN0XCIsXG4gICAgICAgICAgICBzdHlsZXMuam9pbihcIjtcIilcbiAgICAgICAgXTtcbiAgICAgICAgY29uc29sZVttZXRob2RdKC4uLmxvZ1ByZWZpeCwgLi4uYXJncyk7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiZ3JvdXBDb2xsYXBzZWRcIikge1xuICAgICAgICAgICAgaW5Hcm91cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJncm91cEVuZFwiKSB7XG4gICAgICAgICAgICBpbkdyb3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvZ2dlck1ldGhvZHMgPSBPYmplY3Qua2V5cyhtZXRob2RUb0NvbG9yTWFwKTtcbiAgICByZXR1cm4gbG9nZ2VyTWV0aG9kcy5yZWR1Y2UoKGFwaSwgbWV0aG9kKT0+e1xuICAgICAgICBhcGlbbWV0aG9kXSA9ICguLi5hcmdzKT0+e1xuICAgICAgICAgICAgcHJpbnQobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFwaTtcbiAgICB9LCB7fSk7XG59KSgpO1xuXG5jb25zdCBtZXNzYWdlcyA9IHtcbiAgICBcImludmFsaWQtdmFsdWVcIjogKHsgcGFyYW1OYW1lLCB2YWxpZFZhbHVlRGVzY3JpcHRpb24sIHZhbHVlIH0pPT57XG4gICAgICAgIGlmICghcGFyYW1OYW1lIHx8ICF2YWxpZFZhbHVlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW52YWxpZC12YWx1ZScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHdhcyBnaXZlbiBhIHZhbHVlIHdpdGggYW4gYCArIGB1bmV4cGVjdGVkIHZhbHVlLiAke3ZhbGlkVmFsdWVEZXNjcmlwdGlvbn0gUmVjZWl2ZWQgYSB2YWx1ZSBvZiBgICsgYCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfS5gO1xuICAgIH0sXG4gICAgXCJub3QtYW4tYXJyYXlcIjogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pPT57XG4gICAgICAgIGlmICghbW9kdWxlTmFtZSB8fCAhY2xhc3NOYW1lIHx8ICFmdW5jTmFtZSB8fCAhcGFyYW1OYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ25vdC1hbi1hcnJheScgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgcGFyYW1ldGVyICcke3BhcmFtTmFtZX0nIHBhc3NlZCBpbnRvIGAgKyBgJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCknIG11c3QgYmUgYW4gYXJyYXkuYDtcbiAgICB9LFxuICAgIFwiaW5jb3JyZWN0LXR5cGVcIjogKHsgZXhwZWN0ZWRUeXBlLCBwYXJhbU5hbWUsIG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSk9PntcbiAgICAgICAgaWYgKCFleHBlY3RlZFR5cGUgfHwgIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW5jb3JyZWN0LXR5cGUnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZVN0ciA9IGNsYXNzTmFtZSA/IGAke2NsYXNzTmFtZX0uYCA6IFwiXCI7XG4gICAgICAgIHJldHVybiBgVGhlIHBhcmFtZXRlciAnJHtwYXJhbU5hbWV9JyBwYXNzZWQgaW50byBgICsgYCcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lU3RyfWAgKyBgJHtmdW5jTmFtZX0oKScgbXVzdCBiZSBvZiB0eXBlICR7ZXhwZWN0ZWRUeXBlfS5gO1xuICAgIH0sXG4gICAgXCJpbmNvcnJlY3QtY2xhc3NcIjogKHsgZXhwZWN0ZWRDbGFzc05hbWUsIHBhcmFtTmFtZSwgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgaXNSZXR1cm5WYWx1ZVByb2JsZW0gfSk9PntcbiAgICAgICAgaWYgKCFleHBlY3RlZENsYXNzTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhZnVuY05hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnaW5jb3JyZWN0LWNsYXNzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGFzc05hbWVTdHIgPSBjbGFzc05hbWUgPyBgJHtjbGFzc05hbWV9LmAgOiBcIlwiO1xuICAgICAgICBpZiAoaXNSZXR1cm5WYWx1ZVByb2JsZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBgVGhlIHJldHVybiB2YWx1ZSBmcm9tICcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lU3RyfSR7ZnVuY05hbWV9KCknIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgY2xhc3MgJHtleHBlY3RlZENsYXNzTmFtZX0uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSBwYXJhbWV0ZXIgJyR7cGFyYW1OYW1lfScgcGFzc2VkIGludG8gYCArIGAnJHttb2R1bGVOYW1lfS4ke2NsYXNzTmFtZVN0cn0ke2Z1bmNOYW1lfSgpJyBgICsgYG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgY2xhc3MgJHtleHBlY3RlZENsYXNzTmFtZX0uYDtcbiAgICB9LFxuICAgIFwibWlzc2luZy1hLW1ldGhvZFwiOiAoeyBleHBlY3RlZE1ldGhvZCwgcGFyYW1OYW1lLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lIH0pPT57XG4gICAgICAgIGlmICghZXhwZWN0ZWRNZXRob2QgfHwgIXBhcmFtTmFtZSB8fCAhbW9kdWxlTmFtZSB8fCAhY2xhc3NOYW1lIHx8ICFmdW5jTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdtaXNzaW5nLWEtbWV0aG9kJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCkgZXhwZWN0ZWQgdGhlIGAgKyBgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIHRvIGV4cG9zZSBhICcke2V4cGVjdGVkTWV0aG9kfScgbWV0aG9kLmA7XG4gICAgfSxcbiAgICBcImFkZC10by1jYWNoZS1saXN0LXVuZXhwZWN0ZWQtdHlwZVwiOiAoeyBlbnRyeSB9KT0+e1xuICAgICAgICByZXR1cm4gYEFuIHVuZXhwZWN0ZWQgZW50cnkgd2FzIHBhc3NlZCB0byAnc2Vyd2lzdC5TZXJ3aXN0LmFkZFRvUHJlY2FjaGVMaXN0KCknIFRoZSBlbnRyeSAnJHtKU09OLnN0cmluZ2lmeShlbnRyeSl9JyBpc24ndCBzdXBwb3J0ZWQuIFlvdSBtdXN0IHN1cHBseSBhbiBhcnJheSBvZiBzdHJpbmdzIHdpdGggb25lIG9yIG1vcmUgY2hhcmFjdGVycywgb2JqZWN0cyB3aXRoIGEgdXJsIHByb3BlcnR5IG9yIFJlcXVlc3Qgb2JqZWN0cy5gO1xuICAgIH0sXG4gICAgXCJhZGQtdG8tY2FjaGUtbGlzdC1jb25mbGljdGluZy1lbnRyaWVzXCI6ICh7IGZpcnN0RW50cnksIHNlY29uZEVudHJ5IH0pPT57XG4gICAgICAgIGlmICghZmlyc3RFbnRyeSB8fCAhc2Vjb25kRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaW5wdXQgdG8gXCIgKyBgJ2FkZC10by1jYWNoZS1saXN0LWR1cGxpY2F0ZS1lbnRyaWVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFR3byBvZiB0aGUgZW50cmllcyBwYXNzZWQgdG8gJ3Nlcndpc3QuU2Vyd2lzdC5hZGRUb1ByZWNhY2hlTGlzdCgpJyBoYWQgdGhlIFVSTCAke2ZpcnN0RW50cnl9IGJ1dCBkaWZmZXJlbnQgcmV2aXNpb24gZGV0YWlscy4gU2Vyd2lzdCBpcyB1bmFibGUgdG8gY2FjaGUgYW5kIHZlcnNpb24gdGhlIGFzc2V0IGNvcnJlY3RseS4gUGxlYXNlIHJlbW92ZSBvbmUgb2YgdGhlIGVudHJpZXMuYDtcbiAgICB9LFxuICAgIFwicGx1Z2luLWVycm9yLXJlcXVlc3Qtd2lsbC1mZXRjaFwiOiAoeyB0aHJvd25FcnJvck1lc3NhZ2UgfSk9PntcbiAgICAgICAgaWYgKCF0aHJvd25FcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgaW5wdXQgdG8gXCIgKyBgJ3BsdWdpbi1lcnJvci1yZXF1ZXN0LXdpbGwtZmV0Y2gnLCBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYEFuIGVycm9yIHdhcyB0aHJvd24gYnkgYSBwbHVnaW4ncyAncmVxdWVzdFdpbGxGZXRjaCgpJyBtZXRob2QuIFRoZSB0aHJvd24gZXJyb3IgbWVzc2FnZSB3YXM6ICcke3Rocm93bkVycm9yTWVzc2FnZX0nLmA7XG4gICAgfSxcbiAgICBcImludmFsaWQtY2FjaGUtbmFtZVwiOiAoeyBjYWNoZU5hbWVJZCwgdmFsdWUgfSk9PntcbiAgICAgICAgaWYgKCFjYWNoZU5hbWVJZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhICdjYWNoZU5hbWVJZCcgZm9yIGVycm9yICdpbnZhbGlkLWNhY2hlLW5hbWUnYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBwcm92aWRlIGEgbmFtZSBjb250YWluaW5nIGF0IGxlYXN0IG9uZSBjaGFyYWN0ZXIgZm9yIHNldENhY2hlRGV0YWlscyh7JHtjYWNoZU5hbWVJZH06ICcuLi4nfSkuIFJlY2VpdmVkIGEgdmFsdWUgb2YgJyR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSdgO1xuICAgIH0sXG4gICAgXCJ1bnJlZ2lzdGVyLXJvdXRlLWJ1dC1ub3QtZm91bmQtd2l0aC1tZXRob2RcIjogKHsgbWV0aG9kIH0pPT57XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGlucHV0IHRvIFwiICsgYCd1bnJlZ2lzdGVyLXJvdXRlLWJ1dC1ub3QtZm91bmQtd2l0aC1tZXRob2QnIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgVGhlIHJvdXRlIHlvdSdyZSB0cnlpbmcgdG8gdW5yZWdpc3RlciB3YXMgbm90ICBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgZm9yIHRoZSBtZXRob2QgdHlwZSAnJHttZXRob2R9Jy5gO1xuICAgIH0sXG4gICAgXCJ1bnJlZ2lzdGVyLXJvdXRlLXJvdXRlLW5vdC1yZWdpc3RlcmVkXCI6ICgpPT57XG4gICAgICAgIHJldHVybiBgVGhlIHJvdXRlIHlvdSdyZSB0cnlpbmcgdG8gdW5yZWdpc3RlciB3YXMgbm90IHByZXZpb3VzbHkgYCArIFwicmVnaXN0ZXJlZC5cIjtcbiAgICB9LFxuICAgIFwicXVldWUtcmVwbGF5LWZhaWxlZFwiOiAoeyBuYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgUmVwbGF5aW5nIHRoZSBiYWNrZ3JvdW5kIHN5bmMgcXVldWUgJyR7bmFtZX0nIGZhaWxlZC5gO1xuICAgIH0sXG4gICAgXCJkdXBsaWNhdGUtcXVldWUtbmFtZVwiOiAoeyBuYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlIFF1ZXVlIG5hbWUgJyR7bmFtZX0nIGlzIGFscmVhZHkgYmVpbmcgdXNlZC4gQWxsIGluc3RhbmNlcyBvZiBiYWNrZ3JvdW5kU3luYy5RdWV1ZSBtdXN0IGJlIGdpdmVuIHVuaXF1ZSBuYW1lcy5gO1xuICAgIH0sXG4gICAgXCJleHBpcmVkLXRlc3Qtd2l0aG91dC1tYXgtYWdlXCI6ICh7IG1ldGhvZE5hbWUsIHBhcmFtTmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFRoZSAnJHttZXRob2ROYW1lfSgpJyBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCB3aGVuIHRoZSBgICsgYCcke3BhcmFtTmFtZX0nIGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLmA7XG4gICAgfSxcbiAgICBcInVuc3VwcG9ydGVkLXJvdXRlLXR5cGVcIjogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSwgcGFyYW1OYW1lIH0pPT57XG4gICAgICAgIHJldHVybiBgVGhlIHN1cHBsaWVkICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciB3YXMgYW4gdW5zdXBwb3J0ZWQgdHlwZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzIGZvciAke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSBmb3IgdmFsaWQgaW5wdXQgdHlwZXMuYDtcbiAgICB9LFxuICAgIFwibm90LWFycmF5LW9mLWNsYXNzXCI6ICh7IHZhbHVlLCBleHBlY3RlZENsYXNzLCBtb2R1bGVOYW1lLCBjbGFzc05hbWUsIGZ1bmNOYW1lLCBwYXJhbU5hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgc3VwcGxpZWQgJyR7cGFyYW1OYW1lfScgcGFyYW1ldGVyIG11c3QgYmUgYW4gYXJyYXkgb2YgJyR7ZXhwZWN0ZWRDbGFzc30nIG9iamVjdHMuIFJlY2VpdmVkICcke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0sJy4gUGxlYXNlIGNoZWNrIHRoZSBjYWxsIHRvICR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9KCkgdG8gZml4IHRoZSBpc3N1ZS5gO1xuICAgIH0sXG4gICAgXCJtYXgtZW50cmllcy1vci1hZ2UtcmVxdWlyZWRcIjogKHsgbW9kdWxlTmFtZSwgY2xhc3NOYW1lLCBmdW5jTmFtZSB9KT0+e1xuICAgICAgICByZXR1cm4gYFlvdSBtdXN0IGRlZmluZSBlaXRoZXIgJ2NvbmZpZy5tYXhFbnRyaWVzJyBvciAnY29uZmlnLm1heEFnZVNlY29uZHMnIGluICcke21vZHVsZU5hbWV9LiR7Y2xhc3NOYW1lfS4ke2Z1bmNOYW1lfSdgO1xuICAgIH0sXG4gICAgXCJzdGF0dXNlcy1vci1oZWFkZXJzLXJlcXVpcmVkXCI6ICh7IG1vZHVsZU5hbWUsIGNsYXNzTmFtZSwgZnVuY05hbWUgfSk9PntcbiAgICAgICAgcmV0dXJuIGBZb3UgbXVzdCBkZWZpbmUgZWl0aGVyICdjb25maWcuc3RhdHVzZXMnIG9yICdjb25maWcuaGVhZGVycycgaW4gJyR7bW9kdWxlTmFtZX0uJHtjbGFzc05hbWV9LiR7ZnVuY05hbWV9J2A7XG4gICAgfSxcbiAgICBcImludmFsaWQtc3RyaW5nXCI6ICh7IG1vZHVsZU5hbWUsIGZ1bmNOYW1lLCBwYXJhbU5hbWUgfSk9PntcbiAgICAgICAgaWYgKCFwYXJhbU5hbWUgfHwgIW1vZHVsZU5hbWUgfHwgIWZ1bmNOYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW5wdXQgdG8gJ2ludmFsaWQtc3RyaW5nJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFdoZW4gdXNpbmcgc3RyaW5ncywgdGhlICcke3BhcmFtTmFtZX0nIHBhcmFtZXRlciBtdXN0IHN0YXJ0IHdpdGggJ2h0dHAnIChmb3IgY3Jvc3Mtb3JpZ2luIG1hdGNoZXMpIG9yICcvJyAoZm9yIHNhbWUtb3JpZ2luIG1hdGNoZXMpLiBQbGVhc2Ugc2VlIHRoZSBkb2NzIGZvciAke21vZHVsZU5hbWV9LiR7ZnVuY05hbWV9KCkgZm9yIG1vcmUgaW5mby5gO1xuICAgIH0sXG4gICAgXCJjaGFubmVsLW5hbWUtcmVxdWlyZWRcIjogKCk9PntcbiAgICAgICAgcmV0dXJuIFwiWW91IG11c3QgcHJvdmlkZSBhIGNoYW5uZWxOYW1lIHRvIGNvbnN0cnVjdCBhIFwiICsgXCJCcm9hZGNhc3RDYWNoZVVwZGF0ZSBpbnN0YW5jZS5cIjtcbiAgICB9LFxuICAgIFwiaW52YWxpZC1yZXNwb25zZXMtYXJlLXNhbWUtYXJnc1wiOiAoKT0+e1xuICAgICAgICByZXR1cm4gXCJUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHJlc3BvbnNlc0FyZVNhbWUoKSBhcHBlYXIgdG8gYmUgXCIgKyBcImludmFsaWQuIFBsZWFzZSBlbnN1cmUgdmFsaWQgUmVzcG9uc2VzIGFyZSB1c2VkLlwiO1xuICAgIH0sXG4gICAgXCJleHBpcmUtY3VzdG9tLWNhY2hlcy1vbmx5XCI6ICgpPT57XG4gICAgICAgIHJldHVybiBgWW91IG11c3QgcHJvdmlkZSBhICdjYWNoZU5hbWUnIHByb3BlcnR5IHdoZW4gdXNpbmcgdGhlIGAgKyBcImV4cGlyYXRpb24gcGx1Z2luIHdpdGggYSBydW50aW1lIGNhY2hpbmcgc3RyYXRlZ3kuXCI7XG4gICAgfSxcbiAgICBcInVuaXQtbXVzdC1iZS1ieXRlc1wiOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSk9PntcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAndW5pdC1tdXN0LWJlLWJ5dGVzJyBlcnJvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFRoZSAndW5pdCcgcG9ydGlvbiBvZiB0aGUgUmFuZ2UgaGVhZGVyIG11c3QgYmUgc2V0IHRvICdieXRlcycuIFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgXCJzaW5nbGUtcmFuZ2Utb25seVwiOiAoeyBub3JtYWxpemVkUmFuZ2VIZWFkZXIgfSk9PntcbiAgICAgICAgaWYgKCFub3JtYWxpemVkUmFuZ2VIZWFkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBpbnB1dCB0byAnc2luZ2xlLXJhbmdlLW9ubHknIGVycm9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgTXVsdGlwbGUgcmFuZ2VzIGFyZSBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGEgIHNpbmdsZSBzdGFydCB2YWx1ZSwgYW5kIG9wdGlvbmFsIGVuZCB2YWx1ZS4gVGhlIFJhbmdlIGhlYWRlciBwcm92aWRlZCB3YXMgXCIke25vcm1hbGl6ZWRSYW5nZUhlYWRlcn1cImA7XG4gICAgfSxcbiAgICBcImludmFsaWQtcmFuZ2UtdmFsdWVzXCI6ICh7IG5vcm1hbGl6ZWRSYW5nZUhlYWRlciB9KT0+e1xuICAgICAgICBpZiAoIW5vcm1hbGl6ZWRSYW5nZUhlYWRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIGlucHV0IHRvICdpbnZhbGlkLXJhbmdlLXZhbHVlcycgZXJyb3IuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBUaGUgUmFuZ2UgaGVhZGVyIGlzIG1pc3NpbmcgYm90aCBzdGFydCBhbmQgZW5kIHZhbHVlcy4gQXQgbGVhc3Qgb25lIG9mIHRob3NlIHZhbHVlcyBpcyBuZWVkZWQuIFRoZSBSYW5nZSBoZWFkZXIgcHJvdmlkZWQgd2FzIFwiJHtub3JtYWxpemVkUmFuZ2VIZWFkZXJ9XCJgO1xuICAgIH0sXG4gICAgXCJuby1yYW5nZS1oZWFkZXJcIjogKCk9PntcbiAgICAgICAgcmV0dXJuIFwiTm8gUmFuZ2UgaGVhZGVyIHdhcyBmb3VuZCBpbiB0aGUgUmVxdWVzdCBwcm92aWRlZC5cIjtcbiAgICB9LFxuICAgIFwicmFuZ2Utbm90LXNhdGlzZmlhYmxlXCI6ICh7IHNpemUsIHN0YXJ0LCBlbmQgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgc3RhcnQgKCR7c3RhcnR9KSBhbmQgZW5kICgke2VuZH0pIHZhbHVlcyBpbiB0aGUgUmFuZ2UgYXJlIGAgKyBgbm90IHNhdGlzZmlhYmxlIGJ5IHRoZSBjYWNoZWQgcmVzcG9uc2UsIHdoaWNoIGlzICR7c2l6ZX0gYnl0ZXMuYDtcbiAgICB9LFxuICAgIFwiYXR0ZW1wdC10by1jYWNoZS1ub24tZ2V0LXJlcXVlc3RcIjogKHsgdXJsLCBtZXRob2QgfSk9PntcbiAgICAgICAgcmV0dXJuIGBVbmFibGUgdG8gY2FjaGUgJyR7dXJsfScgYmVjYXVzZSBpdCBpcyBhICcke21ldGhvZH0nIHJlcXVlc3QgYW5kIG9ubHkgJ0dFVCcgcmVxdWVzdHMgY2FuIGJlIGNhY2hlZC5gO1xuICAgIH0sXG4gICAgXCJjYWNoZS1wdXQtd2l0aC1uby1yZXNwb25zZVwiOiAoeyB1cmwgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGVyZSB3YXMgYW4gYXR0ZW1wdCB0byBjYWNoZSAnJHt1cmx9JyBidXQgdGhlIHJlc3BvbnNlIHdhcyBub3QgZGVmaW5lZC5gO1xuICAgIH0sXG4gICAgXCJuby1yZXNwb25zZVwiOiAoeyB1cmwsIGVycm9yIH0pPT57XG4gICAgICAgIGxldCBtZXNzYWdlID0gYFRoZSBzdHJhdGVneSBjb3VsZCBub3QgZ2VuZXJhdGUgYSByZXNwb25zZSBmb3IgJyR7dXJsfScuYDtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGAgVGhlIHVuZGVybHlpbmcgZXJyb3IgaXMgJHtlcnJvcn0uYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIFwiYmFkLXByZWNhY2hpbmctcmVzcG9uc2VcIjogKHsgdXJsLCBzdGF0dXMgfSk9PntcbiAgICAgICAgcmV0dXJuIGBUaGUgcHJlY2FjaGluZyByZXF1ZXN0IGZvciAnJHt1cmx9JyBmYWlsZWQke3N0YXR1cyA/IGAgd2l0aCBhbiBIVFRQIHN0YXR1cyBvZiAke3N0YXR1c30uYCA6IFwiLlwifWA7XG4gICAgfSxcbiAgICBcIm5vbi1wcmVjYWNoZWQtdXJsXCI6ICh7IHVybCB9KT0+e1xuICAgICAgICByZXR1cm4gYCdjcmVhdGVIYW5kbGVyQm91bmRUb1VSTChcIiR7dXJsfVwiKScgd2FzIGNhbGxlZCwgYnV0IHRoYXQgVVJMIGlzIG5vdCBwcmVjYWNoZWQuIFBsZWFzZSBwYXNzIGluIGEgVVJMIHRoYXQgaXMgcHJlY2FjaGVkIGluc3RlYWQuYDtcbiAgICB9LFxuICAgIFwiYWRkLXRvLWNhY2hlLWxpc3QtY29uZmxpY3RpbmctaW50ZWdyaXRpZXNcIjogKHsgdXJsIH0pPT57XG4gICAgICAgIHJldHVybiBgVHdvIG9mIHRoZSBlbnRyaWVzIHBhc3NlZCB0byAnc2Vyd2lzdC5TZXJ3aXN0LmFkZFRvUHJlY2FjaGVMaXN0KCknIGhhZCB0aGUgVVJMICR7dXJsfSB3aXRoIGRpZmZlcmVudCBpbnRlZ3JpdHkgdmFsdWVzLiBQbGVhc2UgcmVtb3ZlIG9uZSBvZiB0aGVtLmA7XG4gICAgfSxcbiAgICBcIm1pc3NpbmctcHJlY2FjaGUtZW50cnlcIjogKHsgY2FjaGVOYW1lLCB1cmwgfSk9PntcbiAgICAgICAgcmV0dXJuIGBVbmFibGUgdG8gZmluZCBhIHByZWNhY2hlZCByZXNwb25zZSBpbiAke2NhY2hlTmFtZX0gZm9yICR7dXJsfS5gO1xuICAgIH0sXG4gICAgXCJjcm9zcy1vcmlnaW4tY29weS1yZXNwb25zZVwiOiAoeyBvcmlnaW4gfSk9PntcbiAgICAgICAgcmV0dXJuIGAnQHNlcndpc3QvY29yZS5jb3B5UmVzcG9uc2UoKScgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIHNhbWUtb3JpZ2luIHJlc3BvbnNlcy4gSXQgd2FzIHBhc3NlZCBhIHJlc3BvbnNlIHdpdGggb3JpZ2luICR7b3JpZ2lufS5gO1xuICAgIH0sXG4gICAgXCJvcGFxdWUtc3RyZWFtcy1zb3VyY2VcIjogKHsgdHlwZSB9KT0+e1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYE9uZSBvZiB0aGUgJ0BzZXJ3aXN0L3N0cmVhbXMnIHNvdXJjZXMgcmVzdWx0ZWQgaW4gYW4gJyR7dHlwZX0nIHJlc3BvbnNlLmA7XG4gICAgICAgIGlmICh0eXBlID09PSBcIm9wYXF1ZXJlZGlyZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHttZXNzYWdlfSBQbGVhc2UgZG8gbm90IHVzZSBhIG5hdmlnYXRpb24gcmVxdWVzdCB0aGF0IHJlc3VsdHMgaW4gYSByZWRpcmVjdCBhcyBhIHNvdXJjZS5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHttZXNzYWdlfSBQbGVhc2UgZW5zdXJlIHlvdXIgc291cmNlcyBhcmUgQ09SUy1lbmFibGVkLmA7XG4gICAgfVxufTtcblxuY29uc3QgZmFsbGJhY2sgPSAoY29kZSwgLi4uYXJncyk9PntcbiAgICBsZXQgbXNnID0gY29kZTtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1zZyArPSBgIDo6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YDtcbiAgICB9XG4gICAgcmV0dXJuIG1zZztcbn07XG5jb25zdCBnZW5lcmF0b3JGdW5jdGlvbiA9IChjb2RlLCBkZXRhaWxzID0ge30pPT57XG4gICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW2NvZGVdO1xuICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIG1lc3NhZ2UgZm9yIGNvZGUgJyR7Y29kZX0nLmApO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZShkZXRhaWxzKTtcbn07XG5jb25zdCBtZXNzYWdlR2VuZXJhdG9yID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gZmFsbGJhY2sgOiBnZW5lcmF0b3JGdW5jdGlvbjtcblxuY2xhc3MgU2Vyd2lzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGRldGFpbHM7XG4gICAgY29uc3RydWN0b3IoZXJyb3JDb2RlLCBkZXRhaWxzKXtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VHZW5lcmF0b3IoZXJyb3JDb2RlLCBkZXRhaWxzKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVycm9yQ29kZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICB9XG59XG5cbmNvbnN0IGlzQXJyYXkgPSAodmFsdWUsIGRldGFpbHMpPT57XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwibm90LWFuLWFycmF5XCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBoYXNNZXRob2QgPSAob2JqZWN0LCBleHBlY3RlZE1ldGhvZCwgZGV0YWlscyk9PntcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIG9iamVjdFtleHBlY3RlZE1ldGhvZF07XG4gICAgaWYgKHR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkZXRhaWxzLmV4cGVjdGVkTWV0aG9kID0gZXhwZWN0ZWRNZXRob2Q7XG4gICAgICAgIHRocm93IG5ldyBTZXJ3aXN0RXJyb3IoXCJtaXNzaW5nLWEtbWV0aG9kXCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc1R5cGUgPSAob2JqZWN0LCBleHBlY3RlZFR5cGUsIGRldGFpbHMpPT57XG4gICAgaWYgKHR5cGVvZiBvYmplY3QgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBkZXRhaWxzLmV4cGVjdGVkVHlwZSA9IGV4cGVjdGVkVHlwZTtcbiAgICAgICAgdGhyb3cgbmV3IFNlcndpc3RFcnJvcihcImluY29ycmVjdC10eXBlXCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc0luc3RhbmNlID0gKG9iamVjdCwgZXhwZWN0ZWRDbGFzcywgZGV0YWlscyk9PntcbiAgICBpZiAoIShvYmplY3QgaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICBkZXRhaWxzLmV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lO1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW5jb3JyZWN0LWNsYXNzXCIsIGRldGFpbHMpO1xuICAgIH1cbn07XG5jb25zdCBpc09uZU9mID0gKHZhbHVlLCB2YWxpZFZhbHVlcywgZGV0YWlscyk9PntcbiAgICBpZiAoIXZhbGlkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICBkZXRhaWxzLnZhbGlkVmFsdWVEZXNjcmlwdGlvbiA9IGBWYWxpZCB2YWx1ZXMgYXJlICR7SlNPTi5zdHJpbmdpZnkodmFsaWRWYWx1ZXMpfS5gO1xuICAgICAgICB0aHJvdyBuZXcgU2Vyd2lzdEVycm9yKFwiaW52YWxpZC12YWx1ZVwiLCBkZXRhaWxzKTtcbiAgICB9XG59O1xuY29uc3QgaXNBcnJheU9mQ2xhc3MgPSAodmFsdWUsIGV4cGVjdGVkQ2xhc3MsIGRldGFpbHMpPT57XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU2Vyd2lzdEVycm9yKFwibm90LWFycmF5LW9mLWNsYXNzXCIsIGRldGFpbHMpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSl7XG4gICAgICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgZmluYWxBc3NlcnRFeHBvcnRzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbnVsbCA6IHtcbiAgICBoYXNNZXRob2QsXG4gICAgaXNBcnJheSxcbiAgICBpc0luc3RhbmNlLFxuICAgIGlzT25lT2YsXG4gICAgaXNUeXBlLFxuICAgIGlzQXJyYXlPZkNsYXNzXG59O1xuXG5jb25zdCBnZXRGcmllbmRseVVSTCA9ICh1cmwpPT57XG4gICAgY29uc3QgdXJsT2JqID0gbmV3IFVSTChTdHJpbmcodXJsKSwgbG9jYXRpb24uaHJlZik7XG4gICAgcmV0dXJuIHVybE9iai5ocmVmLnJlcGxhY2UobmV3IFJlZ0V4cChgXiR7bG9jYXRpb24ub3JpZ2lufWApLCBcIlwiKTtcbn07XG5cbmNsYXNzIERlZmVycmVkIHtcbiAgICBwcm9taXNlO1xuICAgIHJlc29sdmU7XG4gICAgcmVqZWN0O1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RyaXBQYXJhbXMoZnVsbFVSTCwgaWdub3JlUGFyYW1zKSB7XG4gICAgY29uc3Qgc3RyaXBwZWRVUkwgPSBuZXcgVVJMKGZ1bGxVUkwpO1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgaWdub3JlUGFyYW1zKXtcbiAgICAgICAgc3RyaXBwZWRVUkwuc2VhcmNoUGFyYW1zLmRlbGV0ZShwYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpcHBlZFVSTC5ocmVmO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FjaGVNYXRjaElnbm9yZVBhcmFtcyhjYWNoZSwgcmVxdWVzdCwgaWdub3JlUGFyYW1zLCBtYXRjaE9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHJpcHBlZFJlcXVlc3RVUkwgPSBzdHJpcFBhcmFtcyhyZXF1ZXN0LnVybCwgaWdub3JlUGFyYW1zKTtcbiAgICBpZiAocmVxdWVzdC51cmwgPT09IHN0cmlwcGVkUmVxdWVzdFVSTCkge1xuICAgICAgICByZXR1cm4gY2FjaGUubWF0Y2gocmVxdWVzdCwgbWF0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgY29uc3Qga2V5c09wdGlvbnMgPSB7XG4gICAgICAgIC4uLm1hdGNoT3B0aW9ucyxcbiAgICAgICAgaWdub3JlU2VhcmNoOiB0cnVlXG4gICAgfTtcbiAgICBjb25zdCBjYWNoZUtleXMgPSBhd2FpdCBjYWNoZS5rZXlzKHJlcXVlc3QsIGtleXNPcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlS2V5IG9mIGNhY2hlS2V5cyl7XG4gICAgICAgIGNvbnN0IHN0cmlwcGVkQ2FjaGVLZXlVUkwgPSBzdHJpcFBhcmFtcyhjYWNoZUtleS51cmwsIGlnbm9yZVBhcmFtcyk7XG4gICAgICAgIGlmIChzdHJpcHBlZFJlcXVlc3RVUkwgPT09IHN0cmlwcGVkQ2FjaGVLZXlVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5tYXRjaChjYWNoZUtleSwgbWF0Y2hPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG59XG5cbmNvbnN0IHF1b3RhRXJyb3JDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmNvbnN0IGV4ZWN1dGVRdW90YUVycm9yQ2FsbGJhY2tzID0gYXN5bmMgKCk9PntcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGxvZ2dlci5sb2coYEFib3V0IHRvIHJ1biAke3F1b3RhRXJyb3JDYWxsYmFja3Muc2l6ZX0gY2FsbGJhY2tzIHRvIGNsZWFuIHVwIGNhY2hlcy5gKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBxdW90YUVycm9yQ2FsbGJhY2tzKXtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2soKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLmxvZyhjYWxsYmFjaywgXCJpcyBjb21wbGV0ZS5cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBsb2dnZXIubG9nKFwiRmluaXNoZWQgcnVubmluZyBjYWxsYmFja3MuXCIpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHRpbWVvdXQobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpPT5zZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbmV4cG9ydCB7IERlZmVycmVkIGFzIEQsIFNlcndpc3RFcnJvciBhcyBTLCBjYWNoZU1hdGNoSWdub3JlUGFyYW1zIGFzIGEsIGNhY2hlTmFtZXMgYXMgYywgZXhlY3V0ZVF1b3RhRXJyb3JDYWxsYmFja3MgYXMgZSwgZmluYWxBc3NlcnRFeHBvcnRzIGFzIGYsIGdldEZyaWVuZGx5VVJMIGFzIGcsIGxvZ2dlciBhcyBsLCBxdW90YUVycm9yQ2FsbGJhY2tzIGFzIHEsIHRpbWVvdXQgYXMgdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/waitUntil.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/waitUntil.js ***!
  \********************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   c: function() { return /* binding */ canConstructResponseFromBodyStream; },\n/* harmony export */   w: function() { return /* binding */ waitUntil; }\n/* harmony export */ });\nlet supportStatus;\nfunction canConstructResponseFromBodyStream() {\n    if (supportStatus === undefined) {\n        const testResponse = new Response(\"\");\n        if (\"body\" in testResponse) {\n            try {\n                new Response(testResponse.body);\n                supportStatus = true;\n            } catch (error) {\n                supportStatus = false;\n            }\n        }\n        supportStatus = false;\n    }\n    return supportStatus;\n}\n\nconst waitUntil = (event, asyncFn)=>{\n    const returnPromise = asyncFn();\n    event.waitUntil(returnPromise);\n    return returnPromise;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3Mvd2FpdFVudGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9jaHVua3Mvd2FpdFVudGlsLmpzP2U3NTciXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHN1cHBvcnRTdGF0dXM7XG5mdW5jdGlvbiBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtKCkge1xuICAgIGlmIChzdXBwb3J0U3RhdHVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGVzdFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKFwiXCIpO1xuICAgICAgICBpZiAoXCJib2R5XCIgaW4gdGVzdFJlc3BvbnNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ldyBSZXNwb25zZSh0ZXN0UmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICAgICAgc3VwcG9ydFN0YXR1cyA9IHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBwb3J0U3RhdHVzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0U3RhdHVzO1xufVxuXG5jb25zdCB3YWl0VW50aWwgPSAoZXZlbnQsIGFzeW5jRm4pPT57XG4gICAgY29uc3QgcmV0dXJuUHJvbWlzZSA9IGFzeW5jRm4oKTtcbiAgICBldmVudC53YWl0VW50aWwocmV0dXJuUHJvbWlzZSk7XG4gICAgcmV0dXJuIHJldHVyblByb21pc2U7XG59O1xuXG5leHBvcnQgeyBjYW5Db25zdHJ1Y3RSZXNwb25zZUZyb21Cb2R5U3RyZWFtIGFzIGMsIHdhaXRVbnRpbCBhcyB3IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/waitUntil.js\n"));

/***/ }),

/***/ "./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/index.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NavigationRoute: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.N; },\n/* harmony export */   PrecacheRoute: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.P; },\n/* harmony export */   PrecacheStrategy: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.g; },\n/* harmony export */   RegExpRoute: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.R; },\n/* harmony export */   Route: function() { return /* reexport safe */ _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_3__.R; },\n/* harmony export */   Serwist: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.S; },\n/* harmony export */   cacheNames: function() { return /* binding */ cacheNames; },\n/* harmony export */   cleanupOutdatedCaches: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.c; },\n/* harmony export */   clientsClaim: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.a; },\n/* harmony export */   copyResponse: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.b; },\n/* harmony export */   disableDevLogs: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.d; },\n/* harmony export */   disableNavigationPreload: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.e; },\n/* harmony export */   enableNavigationPreload: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.f; },\n/* harmony export */   isNavigationPreloadSupported: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.i; },\n/* harmony export */   parseRoute: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.p; },\n/* harmony export */   registerQuotaErrorCallback: function() { return /* reexport safe */ _chunks_registerQuotaErrorCallback_js__WEBPACK_IMPORTED_MODULE_2__.r; },\n/* harmony export */   setCacheNameDetails: function() { return /* reexport safe */ _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__.s; }\n/* harmony export */ });\n/* harmony import */ var _chunks_timeout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/timeout.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/timeout.js\");\n/* harmony import */ var _chunks_Serwist_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/Serwist.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/Serwist.js\");\n/* harmony import */ var _chunks_registerQuotaErrorCallback_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/registerQuotaErrorCallback.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/registerQuotaErrorCallback.js\");\n/* harmony import */ var _chunks_PrecacheFallbackPlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunks/PrecacheFallbackPlugin.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/PrecacheFallbackPlugin.js\");\n/* harmony import */ var _chunks_waitUntil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunks/waitUntil.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/waitUntil.js\");\n/* harmony import */ var _chunks_NetworkOnly_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunks/NetworkOnly.js */ \"./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/chunks/NetworkOnly.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! idb */ \"./node_modules/.pnpm/idb@8.0.0/node_modules/idb/build/index.js\");\n\n\n\n\n\n\n\n\nconst cacheNames = {\n    get googleAnalytics () {\n        return _chunks_timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getGoogleAnalyticsName();\n    },\n    get precache () {\n        return _chunks_timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrecacheName();\n    },\n    get prefix () {\n        return _chunks_timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getPrefix();\n    },\n    get runtime () {\n        return _chunks_timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getRuntimeName();\n    },\n    get suffix () {\n        return _chunks_timeout_js__WEBPACK_IMPORTED_MODULE_0__.c.getSuffix();\n    }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvLnBucG0vc2Vyd2lzdEA5LjAuMC1wcmV2aWV3LjI0X3R5cGVzY3JpcHRANS40LjUvbm9kZV9tb2R1bGVzL3Nlcndpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDZ1Q7QUFDL1E7QUFDekI7QUFDakM7QUFDRTtBQUNwQjs7QUFFYjtBQUNBO0FBQ0EsZUFBZSxpREFBWTtBQUMzQixLQUFLO0FBQ0w7QUFDQSxlQUFlLGlEQUFZO0FBQzNCLEtBQUs7QUFDTDtBQUNBLGVBQWUsaURBQVk7QUFDM0IsS0FBSztBQUNMO0FBQ0EsZUFBZSxpREFBWTtBQUMzQixLQUFLO0FBQ0w7QUFDQSxlQUFlLGlEQUFZO0FBQzNCO0FBQ0E7O0FBRXNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy8ucG5wbS9zZXJ3aXN0QDkuMC4wLXByZXZpZXcuMjRfdHlwZXNjcmlwdEA1LjQuNS9ub2RlX21vZHVsZXMvc2Vyd2lzdC9kaXN0L2luZGV4LmpzPzVkYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYyBhcyBjYWNoZU5hbWVzJDEgfSBmcm9tICcuL2NodW5rcy90aW1lb3V0LmpzJztcbmV4cG9ydCB7IE4gYXMgTmF2aWdhdGlvblJvdXRlLCBQIGFzIFByZWNhY2hlUm91dGUsIGcgYXMgUHJlY2FjaGVTdHJhdGVneSwgUiBhcyBSZWdFeHBSb3V0ZSwgUyBhcyBTZXJ3aXN0LCBjIGFzIGNsZWFudXBPdXRkYXRlZENhY2hlcywgYSBhcyBjbGllbnRzQ2xhaW0sIGIgYXMgY29weVJlc3BvbnNlLCBkIGFzIGRpc2FibGVEZXZMb2dzLCBlIGFzIGRpc2FibGVOYXZpZ2F0aW9uUHJlbG9hZCwgZiBhcyBlbmFibGVOYXZpZ2F0aW9uUHJlbG9hZCwgaSBhcyBpc05hdmlnYXRpb25QcmVsb2FkU3VwcG9ydGVkLCBwIGFzIHBhcnNlUm91dGUsIHMgYXMgc2V0Q2FjaGVOYW1lRGV0YWlscyB9IGZyb20gJy4vY2h1bmtzL1Nlcndpc3QuanMnO1xuZXhwb3J0IHsgciBhcyByZWdpc3RlclF1b3RhRXJyb3JDYWxsYmFjayB9IGZyb20gJy4vY2h1bmtzL3JlZ2lzdGVyUXVvdGFFcnJvckNhbGxiYWNrLmpzJztcbmV4cG9ydCB7IFIgYXMgUm91dGUgfSBmcm9tICcuL2NodW5rcy9QcmVjYWNoZUZhbGxiYWNrUGx1Z2luLmpzJztcbmltcG9ydCAnLi9jaHVua3Mvd2FpdFVudGlsLmpzJztcbmltcG9ydCAnLi9jaHVua3MvTmV0d29ya09ubHkuanMnO1xuaW1wb3J0ICdpZGInO1xuXG5jb25zdCBjYWNoZU5hbWVzID0ge1xuICAgIGdldCBnb29nbGVBbmFseXRpY3MgKCkge1xuICAgICAgICByZXR1cm4gY2FjaGVOYW1lcyQxLmdldEdvb2dsZUFuYWx5dGljc05hbWUoKTtcbiAgICB9LFxuICAgIGdldCBwcmVjYWNoZSAoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZU5hbWVzJDEuZ2V0UHJlY2FjaGVOYW1lKCk7XG4gICAgfSxcbiAgICBnZXQgcHJlZml4ICgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZXMkMS5nZXRQcmVmaXgoKTtcbiAgICB9LFxuICAgIGdldCBydW50aW1lICgpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlTmFtZXMkMS5nZXRSdW50aW1lTmFtZSgpO1xuICAgIH0sXG4gICAgZ2V0IHN1ZmZpeCAoKSB7XG4gICAgICAgIHJldHVybiBjYWNoZU5hbWVzJDEuZ2V0U3VmZml4KCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgY2FjaGVOYW1lcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/.pnpm/serwist@9.0.0-preview.24_typescript@5.4.5/node_modules/serwist/dist/index.js\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./app/sw.js");
/******/ 	
/******/ })()
;